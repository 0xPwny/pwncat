<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>pwncat API documentation</title>
    <meta name="description" content="Python netcat implementation." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#pwncat.APPNAME">APPNAME</a></li>
    <li class="mono"><a href="#pwncat.APPREPO">APPREPO</a></li>
    <li class="mono"><a href="#pwncat.LOGLEVEL_TRACE_NUM">LOGLEVEL_TRACE_NUM</a></li>
    <li class="mono"><a href="#pwncat.PIPE">PIPE</a></li>
    <li class="mono"><a href="#pwncat.TIMEOUT_READ_STDIN">TIMEOUT_READ_STDIN</a></li>
    <li class="mono"><a href="#pwncat.TIMEOUT_RECV_SOCKET">TIMEOUT_RECV_SOCKET</a></li>
    <li class="mono"><a href="#pwncat.TIMEOUT_RECV_SOCKET_RETRY">TIMEOUT_RECV_SOCKET_RETRY</a></li>
    <li class="mono"><a href="#pwncat.VERSION">VERSION</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#pwncat.get_args">get_args</a></li>
    <li class="mono"><a href="#pwncat.get_version">get_version</a></li>
    <li class="mono"><a href="#pwncat.logtrace">logtrace</a></li>
    <li class="mono"><a href="#pwncat.main">main</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#pwncat.ABC">ABC</a></span>
        
        </li>
        <li class="mono">
        <span class="class_name"><a href="#pwncat.AbstractNetcatPlugin">AbstractNetcatPlugin</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pwncat.AbstractNetcatPlugin.__init__">__init__</a></li>
    <li class="mono"><a href="#pwncat.AbstractNetcatPlugin.consumer">consumer</a></li>
    <li class="mono"><a href="#pwncat.AbstractNetcatPlugin.interrupt">interrupt</a></li>
    <li class="mono"><a href="#pwncat.AbstractNetcatPlugin.producer">producer</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pwncat.AbstractSocket">AbstractSocket</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pwncat.AbstractSocket.__init__">__init__</a></li>
    <li class="mono"><a href="#pwncat.AbstractSocket.accept">accept</a></li>
    <li class="mono"><a href="#pwncat.AbstractSocket.bind">bind</a></li>
    <li class="mono"><a href="#pwncat.AbstractSocket.connect">connect</a></li>
    <li class="mono"><a href="#pwncat.AbstractSocket.create_socket">create_socket</a></li>
    <li class="mono"><a href="#pwncat.AbstractSocket.gethostbyname">gethostbyname</a></li>
    <li class="mono"><a href="#pwncat.AbstractSocket.listen">listen</a></li>
    <li class="mono"><a href="#pwncat.AbstractSocket.receive">receive</a></li>
    <li class="mono"><a href="#pwncat.AbstractSocket.send">send</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pwncat.NetcatClient">NetcatClient</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pwncat.NetcatClient.__init__">__init__</a></li>
    <li class="mono"><a href="#pwncat.NetcatClient.accept">accept</a></li>
    <li class="mono"><a href="#pwncat.NetcatClient.bind">bind</a></li>
    <li class="mono"><a href="#pwncat.NetcatClient.connect">connect</a></li>
    <li class="mono"><a href="#pwncat.NetcatClient.create_socket">create_socket</a></li>
    <li class="mono"><a href="#pwncat.NetcatClient.gethostbyname">gethostbyname</a></li>
    <li class="mono"><a href="#pwncat.NetcatClient.listen">listen</a></li>
    <li class="mono"><a href="#pwncat.NetcatClient.receive">receive</a></li>
    <li class="mono"><a href="#pwncat.NetcatClient.send">send</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pwncat.NetcatPluginCommand">NetcatPluginCommand</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pwncat.NetcatPluginCommand.__init__">__init__</a></li>
    <li class="mono"><a href="#pwncat.NetcatPluginCommand.consumer">consumer</a></li>
    <li class="mono"><a href="#pwncat.NetcatPluginCommand.interrupt">interrupt</a></li>
    <li class="mono"><a href="#pwncat.NetcatPluginCommand.producer">producer</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pwncat.NetcatPluginOutput">NetcatPluginOutput</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pwncat.NetcatPluginOutput.__init__">__init__</a></li>
    <li class="mono"><a href="#pwncat.NetcatPluginOutput.consumer">consumer</a></li>
    <li class="mono"><a href="#pwncat.NetcatPluginOutput.interrupt">interrupt</a></li>
    <li class="mono"><a href="#pwncat.NetcatPluginOutput.producer">producer</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pwncat.NetcatServer">NetcatServer</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pwncat.NetcatServer.__init__">__init__</a></li>
    <li class="mono"><a href="#pwncat.NetcatServer.accept">accept</a></li>
    <li class="mono"><a href="#pwncat.NetcatServer.bind">bind</a></li>
    <li class="mono"><a href="#pwncat.NetcatServer.connect">connect</a></li>
    <li class="mono"><a href="#pwncat.NetcatServer.create_socket">create_socket</a></li>
    <li class="mono"><a href="#pwncat.NetcatServer.gethostbyname">gethostbyname</a></li>
    <li class="mono"><a href="#pwncat.NetcatServer.listen">listen</a></li>
    <li class="mono"><a href="#pwncat.NetcatServer.receive">receive</a></li>
    <li class="mono"><a href="#pwncat.NetcatServer.send">send</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pwncat.Runner">Runner</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pwncat.Runner.__init__">__init__</a></li>
    <li class="mono"><a href="#pwncat.Runner.add_action">add_action</a></li>
    <li class="mono"><a href="#pwncat.Runner.add_timer">add_timer</a></li>
    <li class="mono"><a href="#pwncat.Runner.run">run</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pwncat.StopSignal">StopSignal</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pwncat.StopSignal.has_stop">has_stop</a></li>
    <li class="mono"><a href="#pwncat.StopSignal.raise_stop">raise_stop</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pwncat.StringEncoder">StringEncoder</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pwncat.StringEncoder.__init__">__init__</a></li>
    <li class="mono"><a href="#pwncat.StringEncoder.decode">decode</a></li>
    <li class="mono"><a href="#pwncat.StringEncoder.encode">encode</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">pwncat</span> module</h1>
  <p>Python netcat implementation.</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat', this);">Show source &equiv;</a></p>
  <div id="source-pwncat" class="source">
    <pre><code>#!/usr/bin/env python3
"""Python netcat implementation."""

#
# TODO: where to use sys.stdout.flush ??
# TODO: change docstring to this format: https://sphinxcontrib-napoleon.readthedocs.io/en/latest/
#
# Behaviour Server
# 1. (tty and non-tty mode) TCP Server should always quit if client disconnects
# 2. (tty and non-tty mode) TCP Server should always quit if connection is gone/broken
# 3. (tty and non-tty mode) UDP Will always stay open (can't determine if connection is gone)
#
#
# Behaviour Client
# 1. (tty and non-tty mode) Client will always stay open until manually quit
##

from __future__ import print_function
from abc import ABCMeta, abstractmethod
from subprocess import Popen, PIPE
import argparse
import atexit
import logging
import os
import re
import socket
import subprocess
import sys
import threading
import time

# Python 2 + Python 3 support
ABC = ABCMeta("ABC", (object,), {"__slots__": ()})

# TODO: Find windows import
if os.name != "nt":
    import select

# -------------------------------------------------------------------------------------------------
# GLOBALS
# -------------------------------------------------------------------------------------------------

APPNAME = "pwncat"
APPREPO = "https://github.com/cytopia/pwncat"
VERSION = "0.0.7-alpha"

# Custom loglevel numer for TRACE
LOGLEVEL_TRACE_NUM = 9

# Default timeout for timeout-based sys.stdin and socket.recv
TIMEOUT_READ_STDIN = 0.1
TIMEOUT_RECV_SOCKET = 0.1
TIMEOUT_RECV_SOCKET_RETRY = 2


# #################################################################################################
# #################################################################################################
# ###
# ###   1 / 3   L I B R A R Y   C L A S S E S
# ###
# #################################################################################################
# #################################################################################################

# -------------------------------------------------------------------------------------------------
# CLASS: StringEncoder
# -------------------------------------------------------------------------------------------------
class StringEncoder(object):
    """
    Takes care about Python 2/3 string encoding/decoding.

    This allows to parse all string/byte values internally between all
    classes or functions as strings to keep full Python 2/3 compat.
    """

    # https://stackoverflow.com/questions/606191/27527728#27527728
    codec = "cp437"

    def __init__(self):
        self.py3 = sys.version_info >= (3, 0)

    def encode(self, data):
        """Convert string into a byte type for Python3."""
        if self.py3:
            data = data.encode(self.codec)
        return data

    def decode(self, data):
        """Convert bytes into a string type for Python3."""
        if self.py3:
            data = data.decode(self.codec)
        return data


# -------------------------------------------------------------------------------------------------
# ABSTRCT CLASS: AbstractSocket
# -------------------------------------------------------------------------------------------------
class AbstractSocket(object):
    """Abstract class which provides TCP, UDP and IPv4, IPv6 Socket funcionality."""

    sock = None  # server binding socket (until accept())
    conn = None  # client/server communication socket

    # The instance role must be 'server' or 'client' and
    # is used to determine how to reconnect broken connections.
    # Either listen again (tcp-only) or re-connect to upstream.
    role = None  # Must be 'server' or 'client'

    # Specify a float of seconds for the socket timeout.
    # A default of None means it is blocking.
    recv_timeout = None

    # If no data is received, the socket will timeout and counts subsequent timeouts
    # with no data received. If 'recv_timeout_retry' many timeouts occured, the socket
    # will stop reading data.
    # The internal counter is reset as soon as data is received again.
    recv_timeout_retry = 0

    options = {
        "bufsize": 1024,  # Receive buffer size
        "backlog": 0,  # Listen backlog
        "nodns": False,  # Do not resolve hostname
        "udp": False,  # Is TCP or UDP?
        "http": False,  # Use HTTP instead
        "https": False,  # Use HTTPS instead
        "keep_open": False,  # Keep server open for new connections
        "rebind": False,  # False (never), True (indefinite) or int for how many times to rebind
        "reconn": False,  # False (never), True (indefinite) or int for how many times to reconnect
        "rebind_wait": 0,  # Time in seconds between re-binds
        "reconn_wait": 0,  # Time in seconds between reconnects
        "rebind_robin": [],  # Ports to round-robind for bindings
        "reconn_robin": [],  # Ports to round-robin for reconnects
        "wait": False,  # Close client if it is idle for x many seconds
        "udp_ping_init": False,  # Send initial UDP ping packet
        "udp_ping_intvl": False,  # Interval in sec for UDP client to ping server
        "udp_ping_word": "\0",  # The char/string to send as UDP ping probe
        "udp_ping_robing": [],  # Ports to round-robing during UDP ping probes
        "safe_word": False,  # Once this is received, the application quits
    }

    # Store the address of the remote end.
    # If we are in server role and running in UDP mode,
    # it must wait for the client to connect first in order
    # to retrieve its addr and port in order to be able
    # to send data back to it.
    remote_addr = None
    remote_port = None

    # ------------------------------------------------------------------------------
    # Constructor / Destructor
    # ------------------------------------------------------------------------------
    def __init__(self, encoder, role, recv_timeout, recv_timeout_retry, options={}):
        """Constructor."""
        assert type(self) is not AbstractSocket, "AbstractSocket cannot be instantiated directly."
        assert role in ["server", "client"], "The role must be 'server' or 'client'."

        self.log = logging.getLogger(__name__)
        self.enc = encoder
        self.role = role

        self.recv_timeout = recv_timeout
        self.recv_timeout_retry = recv_timeout_retry

        # Ensure to provide all items (be explicit - currently helps to find bugs)
        for index in self.options:
            assert index in options, "Provided options are missing key: {}".format(index)
        # Ensure to only provide option itenms that are defined/exist (helps to find bugs)
        for index in options:
            assert index in self.options, "Provided an invalid option item"
            self.options[index] = options[index]

        # Register destructor
        atexit.register(self.__exit__)

    def __exit__(self):
        """Destructor."""

        self.log.trace("Closing 'sock' socket")
        self.__close_socket(self.sock)
        self.sock = None
        self.log.trace("Closing 'conn' socket")
        self.__close_socket(self.conn)
        self.conn = None

    # ------------------------------------------------------------------------------
    # Private Functions
    # ------------------------------------------------------------------------------
    def __close_socket(self, sock):
        """Close a socket."""
        try:
            # (SHUT_RD)   0 = Done receiving (disallows receiving)
            # (SHUT_WR)   1 = Done sending (disallows sending)
            # (SHUT_RDWR) 2 = Both
            sock.shutdown(socket.SHUT_RDWR)
        except (AttributeError, OSError, socket.error):
            self.log.trace("Could not shutdown socket")
            pass
        try:
            sock.close()
        except (AttributeError, OSError, socket.error):
            self.log.trace("Could not shutdown socket")

    def __reconnect(self):
        """Reconnect to a server if upstream has gone."""
        self.__close_socket(self.conn)
        self.__close_socket(self.sock)
        self.create_socket()
        self.conn = self.sock
        if not self.connect():
            self.__reconnect_to_server()

    def __reaccept_from_client(self):
        """Ensure the server is able to keep connection open by re-accepting new clients."""
        # Only for server
        assert self.role == "server", "Only the role 'server' can accept connections."
        # Do not re-accept for UDP
        assert not self.options["udp"], "This should have been caught during arg check."

        # [NO] Do not re-accept
        if not self.options["keep_open"]:
            self.log.info("No automatic re-accept specified. Shutting down.")
            return False
        # [YES] Re-accept indefinitely
        self.log.info("Re-accepting new clients")
        self.__close_socket(self.conn)
        self.accept()
        return True

    def __reconnect_to_server(self):
        """Ensure the client re-connects to the remote server, if the remote server hang up."""
        # Only for Clients
        assert self.role == "client", "Only the role 'client' can re-connect."
        # Do not re-connect with UDP
        assert not self.options["udp"], "This should have been caught during arg check."

        # [NO] Never re-connect
        if type(self.options["reconn"]) is bool and not self.options["reconn"]:
            self.log.info("No automatic reconnect specified. Shutting down.")
            return False
        # [YES] Always re-connect indefinitely
        if type(self.options["reconn"]) is bool and self.options["reconn"]:
            self.log.info(
                "Reconnecting in {} sec (indefinitely)".format(self.options["reconn_wait"])
            )
            time.sleep(self.options["reconn_wait"])
            self.__reconnect()
            return True
        # [YES] Re-connect x many times
        if self.options["reconn"] > 0:
            self.log.info(
                "Reconnecting in {} sec ({} more times left)".format(
                    self.options["reconn_wait"], self.options["reconn"]
                )
            )
            self.options["reconn"] -= 1
            time.sleep(self.options["reconn_wait"])
            self.__reconnect()
            return True
        # [NO] Re-connect count is used up
        self.log.info("Reconnect count is used up. Shutting down.")
        return False

    # ------------------------------------------------------------------------------
    # Helper Functions
    # ------------------------------------------------------------------------------
    def gethostbyname(self, host, port, family):
        """Translate hostname into IP address."""
        socktype = socket.SOCK_DGRAM if self.options["udp"] else socket.SOCK_STREAM
        flags = 0
        if self.options["nodns"]:
            flags = socket.AI_NUMERICHOST
        try:
            self.log.debug("Resolving hostname: {}".format(host))
            (family, socktype, proto, canonname, sockaddr) = socket.getaddrinfo(
                host, port, socket.AF_INET, socktype, flags
            )[0]
        except socket.gaierror as error:
            self.log.error("Resolve Error: {}".format(error))
            sys.exit(1)
        self.log.debug("Resolved hostname:  {}".format(sockaddr[0]))
        return sockaddr[0]

    def create_socket(self):
        """Create TCP or UDP socket."""
        try:
            if self.options["udp"]:
                self.log.debug("Creating UDP socket")
                self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            else:
                self.log.debug("Creating TCP socket")
                self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        except socket.error as error:
            self.log.error("Failed to create the socket: {}".format(error))
            sys.exit(1)
        # Get around the "[Errno 98] Address already in use" error, if the socket is still in wait
        # we instruct it to reuse the address anyway.
        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    def bind(self, addr, port):
        """Bind the socket to an address."""
        try:
            self.log.debug("Binding socket to {}:{}".format(addr, port))
            self.sock.bind((addr, port))
        except (OverflowError, OSError, socket.error) as error:
            self.log.error("Binding socket to {}:{} failed: {}".format(addr, port, error))
            sys.exit(1)

    def listen(self):
        """Listen for connections made to the socket."""
        try:
            self.log.debug("Listening with backlog={}".format(self.options["backlog"]))
            self.sock.listen(self.options["backlog"])
        except socket.error as error:
            self.log.error("Listening failed: {}".format(error))
            sys.exit(1)

    def accept(self):
        """Accept a connection."""
        try:
            self.log.debug("Waiting for TCP client")
            self.conn, client = self.sock.accept()
            addr, port = client
            self.remote_addr = addr
            self.remote_port = port
            self.log.info("Client connected from {}:{}".format(addr, port))
        except (socket.gaierror, socket.error) as error:
            self.log.error("Accept failed: {}".format(error))
            sys.exit(1)

    def connect(self):
        """Connect to a remote socket at given address and port (TCP-only)."""
        try:
            self.log.debug("Connecting to {}:{}".format(self.remote_addr, self.remote_port))
            self.sock.connect((self.remote_addr, self.remote_port))
            return True
        except socket.error as error:
            self.log.error(
                "Connecting to {}:{} failed: {}".format(self.remote_addr, self.remote_port, error)
            )
            return False

    # ------------------------------------------------------------------------------
    # Send / Receive Functions
    # ------------------------------------------------------------------------------
    def send(self, data):
        """Send data."""
        # In case of sending data back to an udp client we need to wait
        # until the client has first connected and told us its addr/port
        if self.options["udp"] and self.remote_addr is None and self.remote_port is None:
            self.log.warning("UDP client has not yet connected. Queueing message")
            while self.remote_addr is None and self.remote_port is None:
                time.sleep(0.1)  # Less wastefull than using 'pass'

        curr = 0  # bytes send during one loop iteration
        send = 0  # total bytes send
        size = len(data)  # bytes of data that needs to be send
        data = self.enc.encode(data)
        assert size == len(data), "Encoding messed up string length, might need to do len() after."

        # Loop until all bytes have been send
        while send < size:
            try:
                self.log.debug(
                    "Trying to send {} bytes to {}:{}".format(
                        size - send, self.remote_addr, self.remote_port
                    )
                )
                self.log.trace("Trying to send: {}".format(repr(data)))
                if self.options["udp"]:
                    curr = self.conn.sendto(data, (self.remote_addr, self.remote_port))
                    send += curr
                else:
                    curr = self.conn.send(data)
                    send += curr
                if curr == 0:
                    self.log.error("No bytes send during loop round.")
                    return
                # Remove 'curr' many bytes from data for the next round
                data = data[curr:]
                self.log.debug(
                    "Sent {} bytes to {}:{} ({} bytes remaining)".format(
                        curr, self.remote_addr, self.remote_port, size - send
                    )
                )
            except socket.error as error:
                if error.errno == socket.errno.EPIPE:
                    self.log.error("TODO:Add desc. Socket error({}): {}".format(error.errno, error))
                    return
                # Most likely nothing to see here??
                # FIXME: TODO: Need to re-accepd new client
                self.log.error("TODO:Add desc. Socket Error: {}".format(error))
                if self.role == "server":
                    if self.__reaccept_from_client():
                        continue
                self.log.warning("Shutdown")
                return
            except (OSError) as error:
                self.log.error("Socket OS Error: {}".format(error))
                return

    def receive(self, ssig):
        """
        Generator function to receive data endlessly by yielding it.

        :param function interrupter: A Func that returns True/False to tell us to stop or not.
        """
        # Set current receive timeout
        self.conn.settimeout(self.recv_timeout)
        self.log.trace("Socket Timeout: {}".format(self.recv_timeout))
        # Counts how many times we had a ready timeout for later to decide
        # if we exceeded maximum retires
        curr_recv_timeout_retry = 0

        while True:
            # Ensure to signal that we do not stop receiving data
            # if ssig.has_stop():
            #    self.log.debug("Interrupt has been requested for receive()")
            #    return

            if self.conn is None:
                self.log.error("Exit. Socket is gone in receive()")
                ssig.raise_stop()
                return

            # Non-blocking socket with timeout. If the timeout threshold is hit,
            # it will throw an socket.timeout exception. This is required to see if other
            # threads have been terminated already.
            try:
                # https://manpages.debian.org/buster/manpages-dev/recv.2.en.html
                (byte, addr) = self.conn.recvfrom(self.options["bufsize"])

            # [1/5] Finished receiving all data
            # NOTE: This is the place where we can do any checks in between reads as the
            # socket has been changed from blocking to time-out based.
            # NOTE: This is also the place, where we quit in case --wait was specified.
            except socket.timeout:
                # Let's ask the interrupter() function if we should terminate?
                if not ssig.has_stop():
                    # No action required, continue the loop and read again.
                    continue
                self.log.debug("Interrupt has been requested for receive()")
                # Other threads are done. Let's try to read a few more times before
                # returning and ending this function (might be data left)
                if curr_recv_timeout_retry < self.recv_timeout_retry:
                    self.log.trace(
                        "Final socket read: {}/{} before quitting.".format(
                            curr_recv_timeout_retry, self.recv_timeout_retry
                        )
                    )
                    curr_recv_timeout_retry += 1
                    continue
                ssig.raise_stop()
                return

            # [2/5] Connection was forcibly closed
            # [Errno 10054] An existing connection was forcibly closed by the remote host
            # [WinError 10054] An existing connection was forcibly closed by the remote host
            # So we will just warn (instead of error our), ignore (don't return here) and
            # let the bottom of this function decide whether we should just quit or
            # reconnect/bind (if the user specified this.
            except socket.error as error:
                # Also ensure we reset the 'byte' value to none so that the below check can kick in.
                byte = None
                self.log.warning("Socket Receive: {}".format(error))

            # [3/5] TODO: Still need to figure out what this error is and when it is thrown
            except AttributeError as error:
                self.log.error("TODO: What happens here?Attribute Receive Error: {}".format(error))
                ssig.raise_stop()
                return

            # We're receiving data again, so let's reset the retry/terminate counter
            # The counter is incremented in 'except socket.timeout' above.
            curr_recv_timeout_retry = 0

            # If we're receiving data from a UDP client
            # we can firstly/finally set its addr/port in order
            # to send data back to it (see send() function)
            if self.options["udp"]:
                self.remote_addr, self.remote_port = addr
                self.log.debug("Client connected: {}:{}".format(self.remote_addr, self.remote_port))

            # [4/5] Upstream (server or client) is gone. Do we reconnect or quit?
            if not byte:
                self.log.trace("Socket: Empty data received or otherwise caught.")

                if self.role == "server":
                    # Yay, we want to continue and allow new clients
                    if self.__reaccept_from_client():
                        self.log.trace("Server can continue, because of --keep-open")
                        continue
                if self.role == "client":
                    # Yay, we want to continue and our client will re-connect upstream again
                    if self.__reconnect_to_server():
                        self.log.trace("Client can continue, because of --reconn")
                        continue

                self.log.warning("Exit. Upstream connection gone. No --keep-open/--reconn set.")
                ssig.raise_stop()
                return

            # [5/5] We have data to process
            data = self.enc.decode(byte)
            self.log.debug(
                "Received {} bytes from {}:{}".format(len(data), self.remote_addr, self.remote_port)
            )
            self.log.trace("Received: {}".format(repr(data)))

            yield data


# -------------------------------------------------------------------------------------------------
# CLASS: NetcatServer
# -------------------------------------------------------------------------------------------------
class NetcatServer(AbstractSocket):
    """Netcat Server implementation."""

    def __init__(self, encoder, host, port, recv_timeout, recv_timeout_retry, options={}):
        """Construct a listening server."""
        super(NetcatServer, self).__init__(
            encoder, "server", recv_timeout, recv_timeout_retry, options
        )

        # Listen on 0.0.0.0 by default
        addr = "0.0.0.0"
        if host is not None:
            addr = self.gethostbyname(host, port, socket.AF_INET)

        # Setup server
        self.create_socket()
        self.bind(addr, port)
        if self.options["udp"]:
            self.conn = self.sock
            self.log.info(
                "Listening on {} (family {}/UDP, port {})".format(addr, socket.AF_INET, port)
            )
        else:
            self.listen()
            self.log.info(
                "Listening on {} (family {}/TCP, port {})".format(addr, socket.AF_INET, port)
            )
            self.accept()


# -------------------------------------------------------------------------------------------------
# CLASS: NetcatClient
# -------------------------------------------------------------------------------------------------
class NetcatClient(AbstractSocket):
    """Netcat Client implementation."""

    def __init__(self, encoder, host, port, recv_timeout, recv_timeout_retry, options={}):
        """Construct a connecting clientt."""
        super(NetcatClient, self).__init__(
            encoder, "client", recv_timeout, recv_timeout_retry, options
        )

        # Setup client
        addr = self.gethostbyname(host, port, socket.AF_INET)
        self.create_socket()
        self.conn = self.sock

        self.remote_addr = addr
        self.remote_port = port
        if not self.options["udp"]:
            if self.connect():
                return
            if self._AbstractSocket__reconnect_to_server():
                return
            sys.exit(1)


# #################################################################################################
# #################################################################################################
# ###
# ###   2 / 3   N E T C A T   P L U G I N S
# ###
# #################################################################################################
# #################################################################################################

# -------------------------------------------------------------------------------------------------
# ABSTRACT CLASS: AbstractNetcatPlugin
# -------------------------------------------------------------------------------------------------
class AbstractNetcatPlugin(ABC):
    """
    Abstract class to for netcat plugins.

    This is a skeleton that defines how the plugins for Netcat should look like.

    The "input_generator" should constantly yield data received from some sort of input
    which could be user input, output from a shell command data from a socket.

    The "input_callback" will apply some sort of action on the data received from a input_generator
    which could be output to stdout, send it to the shell or to a socket.

    "The "input_interrupter" can implement a mechanism to trigger the input_generator to stop
    and return to its parent thread/function. The input_generator must also be implemented
    in a way that it is able to act on the event which the "input_interrupter" emitted.
    """

    __metaclass__ = ABCMeta

    @abstractmethod
    def __init__(self, options={}):
        """
        Set specific options for this plugin.

        Args:
            options (dict):    A dict which allows you to add custom options to your module
        """
        raise NotImplementedError("Should have implemented this")

    @abstractmethod
    def producer(self, ssig):
        """
        Implement a generator function which constantly yields data.

        The data could be from various sources such as: received from a socket,
        received from user input, received from shell command output or anything else.

        Args:
            ssig (StopSignal): A StopSignal instance providing has_stop() and raise_stop() functions
        """
        raise NotImplementedError("Should have implemented this")

    @abstractmethod
    def consumer(self, data):
        """The consumer takes the consumers' output as input and processes it in some form."""
        raise NotImplementedError("Should have implemented this")

    @abstractmethod
    def interrupt(self):
        """Defines an interrupt function which will stop the producer.

        Various producer might call blocking functions and they won't be able to stop themself
        as they hang on that blocking function. This method is triggered from outside and is
        supposed to stop/shutdown the producer.
        If no such interrupt is required, imeplemt it empty."""
        raise NotImplementedError("Should have implemented this")


# -------------------------------------------------------------------------------------------------
# CLASS: NetcatPluginOutput (Module for: user-input -> send -> receive -> output)
# -------------------------------------------------------------------------------------------------
class NetcatPluginOutput(AbstractNetcatPlugin):
    """Implement basic input/output plugin.

    This plugin provides a generator which continuously reads from stdin
    (non-blocking on POSIX and blocking on windows) as well as a
    callback that writes to stdout.
    """

    # Replace '\n' linefeeds (if they exist) with CRLF ('\r\n')?
    crlf = False

    # Non-blocking read from stdin achieved via timeout.
    # Specify timeout in seconds.
    input_timeout = None

    # ------------------------------------------------------------------------------
    # Constructor / Destructor
    # ------------------------------------------------------------------------------
    def __init__(self, options={}):
        """Set specific options for this plugin."""
        super(AbstractNetcatPlugin, self).__init__()
        assert "encoder" in options
        assert "input_timeout" in options
        assert "crlf" in options

        self.log = logging.getLogger(__name__)
        self.enc = options["encoder"]
        if "input_timeout" in options:
            self.input_timeout = options["input_timeout"]
        if "crlf" in options:
            self.crlf = options["crlf"]

    # ------------------------------------------------------------------------------
    # Private Functions
    # ------------------------------------------------------------------------------
    def __use_linefeeds(self, data):
        """Ensure the user input has the desired linefeeds --crlf or not."""
        # No replacement requested
        if not self.crlf:
            return data
        # Already have CRLF at the end
        if data.endswith("\r\n"):
            return data
        # Replace current newline character with CRLF
        if data.endswith("\n"):
            self.log.debug("Replacing LF with CRLF")
            return data[:-1] + "\r\n"
        # Otherwise just return as it is
        return data

    def __set_input_timeout(self):
        """Throws a catchable BaseException for sys.stdin after timeout (Linux only)."""
        i, o, e = select.select([sys.stdin], [], [], self.input_timeout)
        if not i:
            raise BaseException("timed out")

    # ------------------------------------------------------------------------------
    # Public Functions
    # ------------------------------------------------------------------------------

    def producer(self, ssig):
        """Constantly ask for user input."""
        # https://stackoverflow.com/questions/1450393/#38670261
        # while True: line = sys.stdin.readline() <- reads a whole line (faster)
        # for line in sys.stdin.readlin():        <- reads one byte at a time
        while True:
            if ssig.has_stop():
                self.log.trace("Stop signal acknowledged for reading STDIN-1")
                return
            try:
                # TODO: select() does not work for windows on stdin/stdout
                if os.name != "nt":
                    self.__set_input_timeout()
                line = sys.stdin.readline()
            except BaseException:
                # When using select() with timeout, we don't have any input
                # at this point and simply continue the loop or quit if
                # a terminate request has been made by other threads.
                if ssig.has_stop():
                    self.log.trace("Stop signal acknowledged for reading STDIN-2")
                    return
                # TODO: Re-enable this for very verbose logging
                # self.log.trace("STDIN: timeout. Waiting for input...")
                continue
            if line:
                self.log.debug("Received {} bytes from STDIN".format(len(line)))
                self.log.trace("Received: {}".format(repr(line)))
                yield self.__use_linefeeds(line)
            # EOF or <Ctrl>+<d>
            else:
                # DO NOT RETURN HERE BLINDLY, THE UPSTREAM CONNECTION MUST GO FIRST!
                if ssig.has_stop():
                    self.log.trace("Stop signal acknowledged for reading STDIN-3")
                    return
                # TODO: Re-enable this for very verbose logging
                # self.log.trace("STDIN: Reached EOF, repeating")

    def consumer(self, data):
        """Print received data to stdout."""
        print(data, end="")
        sys.stdout.flush()  # TODO:Is this required? What does this do? Test this!

    def interrupt(self):
        """Empty interrupt."""
        pass


# -------------------------------------------------------------------------------------------------
# CLASS: NetcatPluginCommand (Module for user-input -> send -> execute -> send-back -> output)
# -------------------------------------------------------------------------------------------------
class NetcatPluginCommand(AbstractNetcatPlugin):
    """Implement command execution functionality."""

    executable = None

    # ------------------------------------------------------------------------------
    # Constructor / Destructor
    # ------------------------------------------------------------------------------
    def __init__(self, options={}):
        """Set specific options for this plugin."""
        assert "encoder" in options
        assert "executable" in options

        self.log = logging.getLogger(__name__)
        self.enc = options["encoder"]
        self.executable = options["executable"]
        self.log.debug("Setting '{}' as executable".format(self.executable))

        # Open executable to wait for commands
        env = os.environ.copy()
        try:
            self.p = Popen(
                # TODO: should I also use 'bufsize=1'?
                self.executable,
                stdin=PIPE,
                stdout=PIPE,
                stderr=subprocess.STDOUT,
                shell=False,
                env=env,
            )
        # Python-2 compat (doesn't have FileNotFoundError)
        except OSError:
            self.log.error("Specified executable '{}' not found".format(self.executable))
            sys.exit(1)
        except FileNotFoundError:
            self.log.error("Specified executable '{}' not found".format(self.executable))
            sys.exit(1)

        # Define destructor
        atexit.register(self.__exit__)

    def __exit__(self):
        """Destructor."""
        self.log.trace("Killing executable: {} with pid {}".format(self.executable, self.p.pid))
        self.p.kill()

    def __set_input_timeout(self, timeout=0.1):
        """Throw a TimeOutError Exception for sys.stdin (Linux only)."""
        # select((rlist, wlist, xlist, timeout)
        # rlist: wait until ready for reading
        # wlist: wait until ready for writing
        # xlist: wait for an "exceptional condition"
        i, o, e = select.select([self.p.stdout], [], [], timeout)
        if not i:
            raise BaseException("timed out")

    # ------------------------------------------------------------------------------
    # Public Functions
    # ------------------------------------------------------------------------------
    def interrupt(self):
        """Stop function that can be called externally to close this instance."""
        self.log.trace("[NetcatPluginCommand] subprocess.kill() was raised by input_unterrupter()")
        self.p.kill()

    def producer(self, ssig):
        """Constantly ask for input."""
        while True:
            if ssig.has_stop():
                self.log.trace("Stop signal acknowledged in Command")
                return
            self.log.trace("Reading command output")
            # TODO: non-blocking read does not seem to work or?
            # try:
            # self.__set_input_timeout(timeout=1.5)
            data = self.p.stdout.readline()  # Much better performance than self.p.read(1)
            self.log.trace(data)
            # except BaseException:
            #    if THREAD_TERMINATE:
            #        return
            #    # No input, just check again
            #    #self.p.stdout.flush()
            #    continue
            data = self.enc.decode(data)
            self.log.trace("Command output: {}".format(data))
            if not data:
                self.log.trace("Command output was empty. Exiting loop.")
                break
            yield data

    def consumer(self, data):
        """Send data received to stdin (command input)."""
        data = self.enc.encode(data)
        self.log.trace("Appending to stdin: {}".format(data))
        self.p.stdin.write(data)
        self.p.stdin.flush()


# #################################################################################################
# #################################################################################################
# ###
# ###   3 / 3   N E T C A T   P L U G I N   R U N N E R
# ###
# #################################################################################################
# #################################################################################################

# -------------------------------------------------------------------------------------------------
# CLASS: Runner
# -------------------------------------------------------------------------------------------------
class StopSignal(object):

    __stop = False

    def has_stop(self):
        return self.__stop

    def raise_stop(self):
        self.__stop = True


class Runner(object):
    """Runner class that takes care about putting everything into threads."""

    # Dict of producer/consumer action to run in a Thread.
    # Each list item will be run in a single thread
    # {
    #   "name": {
    #     {
    #       "producer": "function",     # A func which yields data
    #       "consumer": "function",     # A callback func to process the data
    #       "interrupter": "function",  # A interrupt func to tell the producer to stop
    #   }
    # }
    __actions = {}
    __timers = {}

    # A dict which holds the threads created from actions.
    # The name is based on the __actions name
    # {"name": "<thread>"}
    __threads = {}

    # ------------------------------------------------------------------------------
    # Constructor / Destructor
    # ------------------------------------------------------------------------------
    def __init__(self):
        """Constructor."""
        self.log = logging.getLogger(__name__)

    # ------------------------------------------------------------------------------
    # Public Functions
    # ------------------------------------------------------------------------------
    def add_action(self, action):
        """
        Enables a function to run threaded by the producer/consumer runner.

        :param str      name:        Name for logging output
        :param function producer:    A generator function which yields data
        :param function consumer:    A callback which consumes data from the generator
        :param function interrupter: A func that signals a stop event to the producer
        """
        assert "name" in action
        assert "producer" in action
        assert "consumer" in action
        assert "signal" in action
        assert "interrupt" in action
        self.__actions[action["name"]] = {
            "name": action["name"],
            "producer": action["producer"],
            "consumer": action["consumer"],
            "signal": action["signal"],
            "interrupt": action["interrupt"],
        }

    def add_timer(self, timer):
        self.__timers[timer["name"]] = {
            "action": timer["action"],
            "intvl": timer["intvl"],
            "args": timer["args"] if "args" in timer else None,
            "kwargs": timer["kwargs"] if "kwargs" in timer else {},
            "signal": timer["signal"],
        }

    def run(self):
        """Run threaded NetCat."""

        def run_action(name, producer, consumer, ssig):
            """
            Receive data (network, user-input, shell-output) and process it (send, output).

            :param str        name:        Name for logging output
            :param function   producer:    A generator function which yields data
            :param function   consumer:    A callback which consumes data from the generator
            :param StopSignal ssig:        Providing has_stop() and raise_stop()
            """
            self.log.trace("[{}] Producer Start".format(name))
            for data in producer(ssig):
                self.log.trace("[{}] Producer received: {}".format(name, repr(data)))
                consumer(data)
            self.log.trace("[{}] Producer Stop".format(name))

        def run_timer(name, action, intvl, ssig, *args, **kwargs):
            """Execute periodic tasks by an optional provided time_action."""
            self.log.trace("[{}] Timer Start (exec every {} sec)".format(name, intvl))
            time_last = int(time.time())
            while True:
                if ssig.has_stop():
                    self.log.trace("Stop signal acknowledged for timer {}".format(name))
                    return
                time_now = int(time.time())
                if time_now > time_last + intvl:
                    self.log.debug("[{}] Executing timed function".format(time_now))
                    if args is not None:
                        if kwargs:
                            action(*args, **kwargs)
                        else:
                            action(*args)
                    else:
                        if kwargs:
                            action(**kwargs)
                        else:
                            action()
                    time_last = time_now  # Reset previous time
                time.sleep(1)

        # Start available action in a thread
        for key in self.__actions:
            # Create Thread object
            thread = threading.Thread(
                target=run_action,
                name=key,
                args=(
                    key,
                    self.__actions[key]["producer"],
                    self.__actions[key]["consumer"],
                    self.__actions[key]["signal"],
                ),
            )
            thread.daemon = False
            thread.start()
            self.__threads[key] = thread
        # Start available timers in a thread
        for key in self.__timers:
            # Create Thread object
            thread = threading.Thread(
                target=run_timer,
                name=key,
                args=(
                    key,
                    self.__timers[key]["action"],
                    self.__timers[key]["intvl"],
                    self.__timers[key]["signal"],
                    self.__timers[key]["args"],
                ),
                kwargs=self.__timers[key]["kwargs"],
            )
            thread.daemon = False
            thread.start()

        def stop(force):
            """Stop threads."""
            for key in self.__threads:
                if not self.__threads[key].is_alive() or force:
                    self.log.trace("Raise stop signal for {}".format(self.__threads[key].getName()))
                    self.__actions[key]["signal"].raise_stop()
                    self.log.trace("Call interrupt for {}".format(self.__threads[key].getName()))
                    self.__actions[key]["interrupt"]()
                    self.log.trace("Joining {}".format(self.__threads[key].getName()))
                    self.__threads[key].join(timeout=0.1)
            # If all threads have died, exit
            if not all([self.__threads[key].is_alive() for key in self.__threads]) or force:
                if force:
                    sys.exit(1)
                else:
                    sys.exit(0)

        try:
            while True:
                stop(False)
                # Need a timeout to not skyrocket the CPU
                time.sleep(0.1)
        except KeyboardInterrupt:
            print()
            stop(True)


# -------------------------------------------------------------------------------------------------
# COMMAND LINE ARGUMENTS
# -------------------------------------------------------------------------------------------------
def get_version():
    """Return version information."""
    return """%(prog)s: Version %(version)s (%(url)s) by %(author)s""" % (
        {"prog": APPNAME, "version": VERSION, "url": APPREPO, "author": "cytopia"}
    )


def _args_check_port(value):
    """Check arguments for invalid port number."""
    min_port = 1
    max_port = 65535
    intvalue = int(value)

    if intvalue < min_port or intvalue > max_port:
        raise argparse.ArgumentTypeError("%s is an invalid port number" % value)
    return intvalue


def _args_check_forwards(value):
    """Check forward argument (-L/-R) for correct pattern."""
    match = re.search(r"(.+):(.+)", value)
    if match is None or len(match.groups()) != 2:
        raise argparse.ArgumentTypeError("%s is not a valid 'addr:port' format." % value)
    _args_check_port(match.group(2))
    return value


def _args_check_rebind(value):
    """Check rebind argument for correct value."""
    intvalue = int(value)
    if intvalue < 0:
        raise argparse.ArgumentTypeError("must be equal or greater than 0." % value)
    return intvalue


def _args_check_reconn(value):
    """Check reconn argument for correct value."""
    intvalue = int(value)
    if intvalue < 0:
        raise argparse.ArgumentTypeError("must be equal or greater than 0." % value)
    return intvalue


def _args_check_robin_ports(value):
    """Check round-robin argument for comma separated string or range."""
    mcomma = re.search(r"^[0-9]+(,([0-9]+))*$", value)
    mrange = re.search(r"^[0-9]+\-[0-9]+$", value)

    if mcomma is None:
        if mrange is None:
            raise argparse.ArgumentTypeError("%s is not a valid port specifier" % value)

    if mcomma:
        ports = mcomma.group(0).split(",")
        for port in ports:
            _args_check_port(port)
        return ports

    if mrange:
        ranges = mrange.group(0).split("-")
        if int(ranges[0]) >= (int(ranges[1]) + 1):
            raise argparse.ArgumentTypeError(
                "Left side of range must be smaller or equal than right side."
            )
        ports = []
        for port in range(int(ranges[0]), int(ranges[1]) + 1):
            _args_check_port(port)
            ports.append(port)
        return ports


def _args_check_mutually_exclusive(parser, args):
    """Check mutually exclusive arguments."""

    # This is connect mode
    connect_mode = not args.listen and not args.zero and not args.local

    # [MODE] --listen
    if args.listen and (args.zero or args.local):
        parser.print_usage()
        print(
            "%s: error: -l/--listen mutually exclusive with -z/-zero or -L/--local" % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # [MODE] --zero
    if args.zero and (args.listen or args.local):
        parser.print_usage()
        print(
            "%s: error: -z/--zero mutually exclusive with -l/--listen or -L/--local" % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # [MODE --local
    if args.local and (args.listen or args.zero):
        parser.print_usage()
        print(
            "%s: error: -L/--local mutually exclusive with -l/--listen or -z/--zero" % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # [MODULE] --exec
    if args.cmd and (args.local or args.zero):
        parser.print_usage()
        print(
            "%s: error: -e/--exec mutually exclusive with -L/--local or -z/--zero" % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # [OPTIONS] --udp
    if args.udp and args.zero:
        parser.print_usage()
        print(
            "%s: error: -u/--udp mutually exclusive with -z/--zero" % (APPNAME), file=sys.stderr,
        )
        sys.exit(1)

    # [ADVANCED] --http
    if args.http and (args.https or args.udp or args.zero):
        parser.print_usage()
        print(
            "%s: error: --http mutually exclusive with --https, -u/--udp or -z/--zero" % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # [ADVANCED] --https
    if args.https and (args.http or args.udp or args.zero):
        parser.print_usage()
        print(
            "%s: error: --https mutually exclusive with --http, -z/--udp or -z/--zero" % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # [ADVANCED] --keep-open
    if args.keep_open and (args.udp):
        parser.print_usage()
        print(
            "%s: error: --keep-open mutually exclusive with -u/--udp" % (APPNAME), file=sys.stderr,
        )
        sys.exit(1)
    if args.keep_open and not args.listen:
        parser.print_usage()
        print(
            "%s: error: --keep-open only works with -l/--listen" % (APPNAME), file=sys.stderr,
        )
        sys.exit(1)

    # [ADVANCED] --rebind
    if args.rebind is not False and not args.listen:
        parser.print_usage()
        print(
            "%s: error: --rebind only works with -l/--listen" % (APPNAME), file=sys.stderr,
        )
        sys.exit(1)

    # [ADVANCED] --reconn
    if args.reconn is not False and (args.udp):
        parser.print_usage()
        print(
            "%s: error: --reconn mutually excl. with -u/--udp" % (APPNAME), file=sys.stderr,
        )
        sys.exit(1)
    if args.reconn is not False and not (connect_mode or args.zero):
        parser.print_usage()
        print(
            "%s: error: --reconn only works with connect mode or -z/--zero" % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # [ADVANCED] --wait
    if args.wait is not False and (args.udp):
        parser.print_usage()
        print(
            "%s: error: -w/--wait mutually excl. with -u/--udp" % (APPNAME), file=sys.stderr,
        )
        sys.exit(1)
    if args.wait is not False and not (connect_mode):
        parser.print_usage()
        print(
            "%s: error: -w/--wait only works with connect mode" % (APPNAME), file=sys.stderr,
        )
        sys.exit(1)

    # [ADVANCED] --udp-ping-init
    if args.udp_ping_init is not False and (args.listen or args.local):
        parser.print_usage()
        print(
            "%s: error: --udp-ping-init mutually excl. with -l/--listen or -L/--local" % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)
    if args.udp_ping_init is not False and not (args.udp):
        parser.print_usage()
        print(
            "%s: error: --udp-ping-init only works with -u/--udp" % (APPNAME), file=sys.stderr,
        )
        sys.exit(1)


def get_args():
    """Retrieve command line arguments."""
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawTextHelpFormatter,
        add_help=False,
        usage="""%(prog)s [-Cnuv] [-e cmd] hostname port
       %(prog)s [-Cnuv] [-e cmd] -l [hostname] port
       %(prog)s [-Cnuv] -z hostname port
       %(prog)s [-Cnuv] -L addr:port [hostname] port
       %(prog)s -V, --version
       %(prog)s -h, --help
       """
        % ({"prog": APPNAME}),
        description="""
Enhanced and comptaible Netcat implementation written in Python (2 and 3) with
connect, zero-i/o, listen and forward modes and techniques to detect and evade
firewalls and intrusion detection/prevention systems.

If no mode arguments are specified, pwncat will run in connect mode and act as
a client to connect to a remote endpoint. If the connection to the remote
endoint is lost, pwncat will quit. See advanced options for how to automatically
reconnect.""",
    )

    positional = parser.add_argument_group("positional arguments")
    mode = parser.add_argument_group("mode arguments")
    optional = parser.add_argument_group("optional arguments")
    advanced = parser.add_argument_group("advanced arguments")
    misc = parser.add_argument_group("misc arguments")

    positional.add_argument(
        "hostname", nargs="?", type=str, help="Address to listen, forward or connect to"
    )
    positional.add_argument(
        "port", type=_args_check_port, help="Port to listen, forward or connect to"
    )

    mode.add_argument(
        "-l",
        "--listen",
        action="store_true",
        default=False,
        help="""[Listen mode]:
Start a server and listen for incoming connections.
If using TCP and a connected client disconnects or the
connection is interrupted otherwise, the server will
quit. See -k/--keep-open to change this behaviour.

""",
    )
    mode.add_argument(
        "-z",
        "--zero",
        action="store_true",
        default=False,
        help="""[Zero-I/0 mode]:
Connect to a remote endpoint and report status only.
Used for port scanning.

""",
    )
    mode.add_argument(
        "-L",
        "--local",
        metavar="addr:port",
        default=False,
        type=_args_check_forwards,
        help="""[Local forward mode]:
This mode will start a server and a client internally.
The internal server will listen locally on specified
hostname/port (positional arguments). Same as with -l.
The server will then forward traffic to the internal
client which connects to another server specified by
address given via -L/--local addr:port.
(I.e.: proxies a remote service to a local address)
"""
        % ({"prog": APPNAME}),
    )
    optional.add_argument(
        "-e",
        "--exec",
        metavar="cmd",
        dest="cmd",
        default=False,
        type=str,
        help="Execute shell command. Only for connect or listen mode.",
    )
    optional.add_argument(
        "-C",
        "--crlf",
        action="store_true",
        default=False,
        help="Replace LF with CRLF from stdin (default: don't)",
    )
    optional.add_argument(
        "-n", "--nodns", action="store_true", default=False, help="Do not resolve DNS.",
    )
    optional.add_argument(
        "-u",
        "--udp",
        action="store_true",
        default=False,
        help="Use UDP for the connection instead of TCP.",
    )
    optional.add_argument(
        "-v",
        "--verbose",
        action="count",
        default=0,
        help="""Be verbose and print info to stderr. Use -v, -vv, -vvv
or -vvvv for more verbosity. The server performance will
decrease drastically if you use more than three times.""",
    )

    advanced.add_argument(
        "--http",
        action="store_true",
        default=False,
        help="""Connect / Listen / Local forward mode (TCP only):
Hide traffic in http packets to fool Firewalls/IDS/IPS.

""",
    )
    advanced.add_argument(
        "--https",
        action="store_true",
        default=False,
        help="""Connect / Listen / Local forward mode (TCP only):
Hide traffic in https packets to fool Firewalls/IDS/IPS.

""",
    )
    advanced.add_argument(
        "-k",
        "--keep-open",
        action="store_true",
        default=False,
        help="""Listen mode (TCP only):
Re-accept new clients in listen mode after a client has
disconnected or the connection is unterrupted otherwise.
(default: server will quit after connection is gone)

""",
    )
    advanced.add_argument(
        "--rebind",
        metavar="x",
        default=False,
        type=_args_check_rebind,
        help="""Listen mode (TCP and UDP):
If the server is unable to bind or accept clients, it
will re-initialize itself x many times before giving up.
Use 0 to re-initialize endlessly. (default: fail after
first unsuccessful try).

""",
    )
    advanced.add_argument(
        "--rebind-wait",
        metavar="s",
        default=1,
        type=int,
        help="""Listen mode (TCP and UDP):
Wait x seconds between re-initialization. (default: 1)

""",
    )
    advanced.add_argument(
        "--rebind-robin",
        metavar="port",
        default=[],
        type=_args_check_robin_ports,
        help="""Listen mode (TCP and UDP):
If the server is unable to initialize (e.g: cannot bind
and --rebind is specified, it it will shuffle ports in
round-robin mode to bind to. Use comma separated string
such as '80,81,82' or a range of ports '80-100'.
Set --rebind to at least the number of ports to probe +1
This option requires --rebind to be specified.

""",
    )
    advanced.add_argument(
        "--reconn",
        metavar="x",
        default=False,
        type=_args_check_reconn,
        help="""Connect mode / Zero-I/O mode (TCP only):
If the remote server is not reachable or the connection
is interrupted, the client will connect again x many
times before giving up. Use 0 to retry endlessly.
(default: quit if the remote is not available or the
connection was interrupted)
This might be handy for stable TCP reverse shells ;-)

""",
    )
    advanced.add_argument(
        "--reconn-wait",
        metavar="s",
        default=1,
        type=int,
        help="""Connect mode / Zero-I/O mode (TCP only):
Wait x seconds between re-connects. (default: 1)

""",
    )
    advanced.add_argument(
        "--reconn-robin",
        metavar="port",
        default=[],
        type=_args_check_robin_ports,
        help="""Connect mode / Zero-I/O mode (TCP only):
If the remote server is not reachable or the connection
is interrupted and --reconn is specified, the client
will shuffle ports in round-robin mode to connect to.
Use comma separated string such as '80,81,82' or a range
of ports '80-100'.
Set --reconn to at least the number of ports to probe +1
This helps reverse shell to evade intrusiona prevention
systems that will cut your connection and block the
outbound port.
This is also useful in Connect or Zero-I/O mode to
figure out what outbound ports are allowed.

""",
    )
    advanced.add_argument(
        "-w",
        "--wait",
        metavar="s",
        default=False,
        type=int,
        help="""Connect mode (TCP only):
If a connection and stdin are idle for more than s sec,
then the connection is silently closed and the client
will exit. (default: wait forever).
Note: if --reconn is specified, the connection will be
re-opened.

""",
    )
    advanced.add_argument(
        "--udp-ping-init",
        action="store_true",
        default=False,
        help="""Connect mode / Zero-I/O mode (UDP only):
UDP is a stateless protocol unlike TCP, so no hand-
shake communication takes place and the client just
sends data to a server without being "accepted" by
the server first.
This means a server waiting for an UDP client to
connect to, is unable to send any data to the client,
before the client hasn't send data first. The server
simply doesn't know the IP address before an initial
connect.
The --udp-ping-init option instructs the client to send
one single initial ping packet to the server, so that it
is able to talk to the client.
This is the only way to make a UDP reverse shell work.
See --udp-ping-word for what char/string to send as
initial ping packet (default: '\\0')

""",
    )
    advanced.add_argument(
        "--udp-ping-intvl",
        metavar="s",
        default=False,
        type=int,
        help="""Connect mode / Zero-I/O mode (UDP only):
Instruct the UDP client to send ping intervalls every
s seconds. This allows you to restart your UDP server
and just wait for the client to report back in.
This might be handy for stable UDP reverse shells ;-)
See --udp-ping-word for what char/string to send as
initial ping packet (default: '\\0')

""",
    )
    advanced.add_argument(
        "--udp-ping-word",
        metavar="str",
        default="\0",
        type=str,
        help="""Connect mode / Zero-I/O mode (UDP only):
Change the default character '\\0' to use for upd ping.
Single character or strings are supported.

""",
    )
    advanced.add_argument(
        "--udp-ping-robin",
        metavar="port",
        default=[],
        type=_args_check_robin_ports,
        help="""Zero-I/O mode (UDP only):
Instruct the UDP client to shuffle the specified ports
in round-robin mode for a remote server to ping.
This might be handy to scan outbound allowed ports.
Use --udp-ping-intvl 0 to be faster.

""",
    )
    advanced.add_argument(
        "--safe-word",
        metavar="str",
        default=False,
        type=str,
        help="""All modes:
If %(prog)s is started with this argument, it will shut
down as soon as it receives the specified string. The
--keep-open (server) or --reconn (client) options will
be ignored and it won't listen again or reconnect to you.
Use a very unique string to not have it shut down
accidentally by other input.
"""
        % ({"prog": APPNAME}),
    )
    misc.add_argument("-h", "--help", action="help", help="Show this help message and exit")
    misc.add_argument(
        "-V",
        "--version",
        action="version",
        version=get_version(),
        help="Show version information and exit",
    )

    # Retrieve arguments
    args = parser.parse_args()

    # Check mutually exclive arguments
    _args_check_mutually_exclusive(parser, args)

    # Connect mode and Zero-I/O mode require hostname and port to be set
    connect_mode = not (args.listen or args.zero or args.local)
    if (connect_mode or args.zero) and not (args.hostname):
        parser.print_usage()
        print(
            "%s: error: the following arguments are required: hostname" % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # Deny unimplemented modes
    if args.http or args.https or args.rebind or args.wait or args.udp_ping_init or args.safe_word:
        print("Unimplemented options", file=sys.stderr)
        sys.exit(1)

    return args


# -------------------------------------------------------------------------------------------------
# CUSTOM FUNCTIONS
# -------------------------------------------------------------------------------------------------
def logtrace(self, message, *args, **kws):
    """Set custom log level for TRACE."""
    if self.isEnabledFor(LOGLEVEL_TRACE_NUM):
        self._log(LOGLEVEL_TRACE_NUM, message, args, **kws)


# -------------------------------------------------------------------------------------------------
# MAIN ENTRYPOINT
# -------------------------------------------------------------------------------------------------
def main():
    """Run the program."""
    args = get_args()
    host = args.hostname
    port = args.port

    # Set netcat options
    net_opts = {
        "bufsize": 8192,
        "backlog": 0,
        "nodns": args.nodns,
        "udp": args.udp,
        "http": args.http,
        "https": args.https,
        "keep_open": args.keep_open,
        "rebind": True if (type(args.rebind) is int and args.rebind == 0) else args.rebind,
        "reconn": True if (type(args.reconn) is int and args.reconn == 0) else args.reconn,
        "rebind_wait": args.rebind_wait,
        "reconn_wait": args.reconn_wait,
        "rebind_robin": args.rebind_robin,
        "reconn_robin": args.reconn_robin,
        "wait": args.wait,
        "udp_ping_init": args.udp_ping_init,
        "udp_ping_intvl": args.udp_ping_intvl,
        "udp_ping_word": args.udp_ping_word,
        "udp_ping_robing": args.udp_ping_robin,
        "safe_word": args.safe_word,
    }

    # Initialize logger
    if args.verbose == 0:
        loglevel = logging.ERROR
    elif args.verbose == 1:
        loglevel = logging.WARNING
    elif args.verbose == 2:
        loglevel = logging.INFO
    elif args.verbose == 3:
        loglevel = logging.DEBUG
    else:
        loglevel = LOGLEVEL_TRACE_NUM

    logging.addLevelName(LOGLEVEL_TRACE_NUM, "TRACE")
    logging.Logger.trace = logtrace
    logformat = "%(levelname)s %(message)s"
    if args.verbose > 2:
        logformat = "%(levelname)s [%(threadName)s]: %(message)s"
    if args.verbose > 3:
        logformat = "%(levelname)s [%(threadName)s] %(lineno)d:%(funcName)s(): %(message)s"
    logging.basicConfig(format=logformat, level=loglevel)

    # Initialize encoder
    encoder = StringEncoder()

    # Use command modulde
    if args.cmd:
        module_opts = {
            "encoder": encoder,
            "executable": args.cmd,
        }
        mod = NetcatPluginCommand(module_opts)
    # Use output module
    else:
        module_opts = {
            "encoder": encoder,
            "crlf": args.crlf,
            "input_timeout": TIMEOUT_READ_STDIN,
        }
        mod = NetcatPluginOutput(module_opts)

    # Run local port-forward
    # -> listen locally and forward traffic to remote (connect)
    if args.local:
        ssig = StopSignal()
        # TODO: Make the listen address optional!
        srv_opts = net_opts.copy()
        srv_opts["reconn"] = True
        srv_opts["keep_open"] = True
        srv_opts["reconn_wait"] = 0
        lhost = args.local.split(":")[0]
        lport = int(args.local.split(":")[1])
        # Create listen and client instances
        net_srv = NetcatServer(
            encoder, lhost, lport, TIMEOUT_RECV_SOCKET, TIMEOUT_RECV_SOCKET_RETRY, srv_opts
        )
        net_cli = NetcatClient(
            encoder, host, port, TIMEOUT_RECV_SOCKET, TIMEOUT_RECV_SOCKET_RETRY, srv_opts
        )
        # Create Runner
        run = Runner()
        run.add_action(
            {
                "name": "TRANSMIT",
                "producer": net_srv.receive,  # USER sends data to PC-SERVER
                "consumer": net_cli.send,  # Data parsed on to PC-CLIENT to send to TARGET
                "signal": ssig,
                "interrupt": object,
            }
        )
        run.add_action(
            {
                "name": "RECEIVE",
                "producer": net_cli.receive,  # Data comes back from TARGET to PC-CLIENT
                "consumer": net_srv.send,  # Data parsed on to PC-SERVER to back send to USER
                "signal": ssig,
                "interrupt": object,
            }
        )
        run.run()
    # Run server
    if args.listen:
        ssig = StopSignal()
        net = NetcatServer(
            encoder, host, port, TIMEOUT_RECV_SOCKET, TIMEOUT_RECV_SOCKET_RETRY, net_opts
        )
        run = Runner()
        run.add_action(
            {
                "name": "RECV",
                "producer": net.receive,
                "consumer": mod.consumer,
                "signal": ssig,
                "interrupt": mod.interrupt,  # Also force the producer to stop on net error
            }
        )
        run.add_action(
            {
                "name": "STDIN",
                "producer": mod.producer,
                "consumer": net.send,
                "signal": ssig,
                "interrupt": mod.interrupt,  # Externally stop the produer itself
            }
        )
        run.run()

    # Run client
    else:
        ssig = StopSignal()
        net = NetcatClient(
            encoder, host, port, TIMEOUT_RECV_SOCKET, TIMEOUT_RECV_SOCKET_RETRY, net_opts
        )
        run = Runner()
        run.add_action(
            {
                "name": "RECV",
                "producer": net.receive,
                "consumer": mod.consumer,
                "signal": ssig,
                "interrupt": mod.interrupt,  # Also force the producer to stop on net error
            }
        )
        run.add_action(
            {
                "name": "STDIN",
                "producer": mod.producer,
                "consumer": net.send,
                "signal": ssig,
                "interrupt": mod.interrupt,  # Externally stop the produer itself
            }
        )
        if type(args.udp_ping_intvl) is int and args.udp_ping_intvl > 0:
            run.add_timer(
                {
                    "name": "PING",
                    "action": net.send,
                    "intvl": args.udp_ping_intvl,
                    "args": ("\x00"),
                    "signal": ssig,
                }
            )
        run.run()


if __name__ == "__main__":
    # Catch Ctrl+c and exit without error message
    try:
        main()
    except KeyboardInterrupt:
        print()
        sys.exit(1)
</code></pre>
  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="pwncat.APPNAME" class="name">var <span class="ident">APPNAME</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pwncat.APPREPO" class="name">var <span class="ident">APPREPO</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pwncat.LOGLEVEL_TRACE_NUM" class="name">var <span class="ident">LOGLEVEL_TRACE_NUM</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pwncat.PIPE" class="name">var <span class="ident">PIPE</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pwncat.TIMEOUT_READ_STDIN" class="name">var <span class="ident">TIMEOUT_READ_STDIN</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pwncat.TIMEOUT_RECV_SOCKET" class="name">var <span class="ident">TIMEOUT_RECV_SOCKET</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pwncat.TIMEOUT_RECV_SOCKET_RETRY" class="name">var <span class="ident">TIMEOUT_RECV_SOCKET_RETRY</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pwncat.VERSION" class="name">var <span class="ident">VERSION</span></p>
      
  
  <div class="source_cont">
</div>

      </div>

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="pwncat.get_args">
    <p>def <span class="ident">get_args</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>Retrieve command line arguments.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.get_args', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.get_args" class="source">
    <pre><code>def get_args():
    """Retrieve command line arguments."""
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawTextHelpFormatter,
        add_help=False,
        usage="""%(prog)s [-Cnuv] [-e cmd] hostname port
       %(prog)s [-Cnuv] [-e cmd] -l [hostname] port
       %(prog)s [-Cnuv] -z hostname port
       %(prog)s [-Cnuv] -L addr:port [hostname] port
       %(prog)s -V, --version
       %(prog)s -h, --help
       """
        % ({"prog": APPNAME}),
        description="""
Enhanced and comptaible Netcat implementation written in Python (2 and 3) with
connect, zero-i/o, listen and forward modes and techniques to detect and evade
firewalls and intrusion detection/prevention systems.

If no mode arguments are specified, pwncat will run in connect mode and act as
a client to connect to a remote endpoint. If the connection to the remote
endoint is lost, pwncat will quit. See advanced options for how to automatically
reconnect.""",
    )

    positional = parser.add_argument_group("positional arguments")
    mode = parser.add_argument_group("mode arguments")
    optional = parser.add_argument_group("optional arguments")
    advanced = parser.add_argument_group("advanced arguments")
    misc = parser.add_argument_group("misc arguments")

    positional.add_argument(
        "hostname", nargs="?", type=str, help="Address to listen, forward or connect to"
    )
    positional.add_argument(
        "port", type=_args_check_port, help="Port to listen, forward or connect to"
    )

    mode.add_argument(
        "-l",
        "--listen",
        action="store_true",
        default=False,
        help="""[Listen mode]:
Start a server and listen for incoming connections.
If using TCP and a connected client disconnects or the
connection is interrupted otherwise, the server will
quit. See -k/--keep-open to change this behaviour.

""",
    )
    mode.add_argument(
        "-z",
        "--zero",
        action="store_true",
        default=False,
        help="""[Zero-I/0 mode]:
Connect to a remote endpoint and report status only.
Used for port scanning.

""",
    )
    mode.add_argument(
        "-L",
        "--local",
        metavar="addr:port",
        default=False,
        type=_args_check_forwards,
        help="""[Local forward mode]:
This mode will start a server and a client internally.
The internal server will listen locally on specified
hostname/port (positional arguments). Same as with -l.
The server will then forward traffic to the internal
client which connects to another server specified by
address given via -L/--local addr:port.
(I.e.: proxies a remote service to a local address)
"""
        % ({"prog": APPNAME}),
    )
    optional.add_argument(
        "-e",
        "--exec",
        metavar="cmd",
        dest="cmd",
        default=False,
        type=str,
        help="Execute shell command. Only for connect or listen mode.",
    )
    optional.add_argument(
        "-C",
        "--crlf",
        action="store_true",
        default=False,
        help="Replace LF with CRLF from stdin (default: don't)",
    )
    optional.add_argument(
        "-n", "--nodns", action="store_true", default=False, help="Do not resolve DNS.",
    )
    optional.add_argument(
        "-u",
        "--udp",
        action="store_true",
        default=False,
        help="Use UDP for the connection instead of TCP.",
    )
    optional.add_argument(
        "-v",
        "--verbose",
        action="count",
        default=0,
        help="""Be verbose and print info to stderr. Use -v, -vv, -vvv
or -vvvv for more verbosity. The server performance will
decrease drastically if you use more than three times.""",
    )

    advanced.add_argument(
        "--http",
        action="store_true",
        default=False,
        help="""Connect / Listen / Local forward mode (TCP only):
Hide traffic in http packets to fool Firewalls/IDS/IPS.

""",
    )
    advanced.add_argument(
        "--https",
        action="store_true",
        default=False,
        help="""Connect / Listen / Local forward mode (TCP only):
Hide traffic in https packets to fool Firewalls/IDS/IPS.

""",
    )
    advanced.add_argument(
        "-k",
        "--keep-open",
        action="store_true",
        default=False,
        help="""Listen mode (TCP only):
Re-accept new clients in listen mode after a client has
disconnected or the connection is unterrupted otherwise.
(default: server will quit after connection is gone)

""",
    )
    advanced.add_argument(
        "--rebind",
        metavar="x",
        default=False,
        type=_args_check_rebind,
        help="""Listen mode (TCP and UDP):
If the server is unable to bind or accept clients, it
will re-initialize itself x many times before giving up.
Use 0 to re-initialize endlessly. (default: fail after
first unsuccessful try).

""",
    )
    advanced.add_argument(
        "--rebind-wait",
        metavar="s",
        default=1,
        type=int,
        help="""Listen mode (TCP and UDP):
Wait x seconds between re-initialization. (default: 1)

""",
    )
    advanced.add_argument(
        "--rebind-robin",
        metavar="port",
        default=[],
        type=_args_check_robin_ports,
        help="""Listen mode (TCP and UDP):
If the server is unable to initialize (e.g: cannot bind
and --rebind is specified, it it will shuffle ports in
round-robin mode to bind to. Use comma separated string
such as '80,81,82' or a range of ports '80-100'.
Set --rebind to at least the number of ports to probe +1
This option requires --rebind to be specified.

""",
    )
    advanced.add_argument(
        "--reconn",
        metavar="x",
        default=False,
        type=_args_check_reconn,
        help="""Connect mode / Zero-I/O mode (TCP only):
If the remote server is not reachable or the connection
is interrupted, the client will connect again x many
times before giving up. Use 0 to retry endlessly.
(default: quit if the remote is not available or the
connection was interrupted)
This might be handy for stable TCP reverse shells ;-)

""",
    )
    advanced.add_argument(
        "--reconn-wait",
        metavar="s",
        default=1,
        type=int,
        help="""Connect mode / Zero-I/O mode (TCP only):
Wait x seconds between re-connects. (default: 1)

""",
    )
    advanced.add_argument(
        "--reconn-robin",
        metavar="port",
        default=[],
        type=_args_check_robin_ports,
        help="""Connect mode / Zero-I/O mode (TCP only):
If the remote server is not reachable or the connection
is interrupted and --reconn is specified, the client
will shuffle ports in round-robin mode to connect to.
Use comma separated string such as '80,81,82' or a range
of ports '80-100'.
Set --reconn to at least the number of ports to probe +1
This helps reverse shell to evade intrusiona prevention
systems that will cut your connection and block the
outbound port.
This is also useful in Connect or Zero-I/O mode to
figure out what outbound ports are allowed.

""",
    )
    advanced.add_argument(
        "-w",
        "--wait",
        metavar="s",
        default=False,
        type=int,
        help="""Connect mode (TCP only):
If a connection and stdin are idle for more than s sec,
then the connection is silently closed and the client
will exit. (default: wait forever).
Note: if --reconn is specified, the connection will be
re-opened.

""",
    )
    advanced.add_argument(
        "--udp-ping-init",
        action="store_true",
        default=False,
        help="""Connect mode / Zero-I/O mode (UDP only):
UDP is a stateless protocol unlike TCP, so no hand-
shake communication takes place and the client just
sends data to a server without being "accepted" by
the server first.
This means a server waiting for an UDP client to
connect to, is unable to send any data to the client,
before the client hasn't send data first. The server
simply doesn't know the IP address before an initial
connect.
The --udp-ping-init option instructs the client to send
one single initial ping packet to the server, so that it
is able to talk to the client.
This is the only way to make a UDP reverse shell work.
See --udp-ping-word for what char/string to send as
initial ping packet (default: '\\0')

""",
    )
    advanced.add_argument(
        "--udp-ping-intvl",
        metavar="s",
        default=False,
        type=int,
        help="""Connect mode / Zero-I/O mode (UDP only):
Instruct the UDP client to send ping intervalls every
s seconds. This allows you to restart your UDP server
and just wait for the client to report back in.
This might be handy for stable UDP reverse shells ;-)
See --udp-ping-word for what char/string to send as
initial ping packet (default: '\\0')

""",
    )
    advanced.add_argument(
        "--udp-ping-word",
        metavar="str",
        default="\0",
        type=str,
        help="""Connect mode / Zero-I/O mode (UDP only):
Change the default character '\\0' to use for upd ping.
Single character or strings are supported.

""",
    )
    advanced.add_argument(
        "--udp-ping-robin",
        metavar="port",
        default=[],
        type=_args_check_robin_ports,
        help="""Zero-I/O mode (UDP only):
Instruct the UDP client to shuffle the specified ports
in round-robin mode for a remote server to ping.
This might be handy to scan outbound allowed ports.
Use --udp-ping-intvl 0 to be faster.

""",
    )
    advanced.add_argument(
        "--safe-word",
        metavar="str",
        default=False,
        type=str,
        help="""All modes:
If %(prog)s is started with this argument, it will shut
down as soon as it receives the specified string. The
--keep-open (server) or --reconn (client) options will
be ignored and it won't listen again or reconnect to you.
Use a very unique string to not have it shut down
accidentally by other input.
"""
        % ({"prog": APPNAME}),
    )
    misc.add_argument("-h", "--help", action="help", help="Show this help message and exit")
    misc.add_argument(
        "-V",
        "--version",
        action="version",
        version=get_version(),
        help="Show version information and exit",
    )

    # Retrieve arguments
    args = parser.parse_args()

    # Check mutually exclive arguments
    _args_check_mutually_exclusive(parser, args)

    # Connect mode and Zero-I/O mode require hostname and port to be set
    connect_mode = not (args.listen or args.zero or args.local)
    if (connect_mode or args.zero) and not (args.hostname):
        parser.print_usage()
        print(
            "%s: error: the following arguments are required: hostname" % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # Deny unimplemented modes
    if args.http or args.https or args.rebind or args.wait or args.udp_ping_init or args.safe_word:
        print("Unimplemented options", file=sys.stderr)
        sys.exit(1)

    return args
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pwncat.get_version">
    <p>def <span class="ident">get_version</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>Return version information.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.get_version', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.get_version" class="source">
    <pre><code>def get_version():
    """Return version information."""
    return """%(prog)s: Version %(version)s (%(url)s) by %(author)s""" % (
        {"prog": APPNAME, "version": VERSION, "url": APPREPO, "author": "cytopia"}
    )
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pwncat.logtrace">
    <p>def <span class="ident">logtrace</span>(</p><p>self, message, *args, **kws)</p>
    </div>
    

    
  
    <div class="desc"><p>Set custom log level for TRACE.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.logtrace', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.logtrace" class="source">
    <pre><code>def logtrace(self, message, *args, **kws):
    """Set custom log level for TRACE."""
    if self.isEnabledFor(LOGLEVEL_TRACE_NUM):
        self._log(LOGLEVEL_TRACE_NUM, message, args, **kws)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pwncat.main">
    <p>def <span class="ident">main</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>Run the program.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.main', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.main" class="source">
    <pre><code>def main():
    """Run the program."""
    args = get_args()
    host = args.hostname
    port = args.port

    # Set netcat options
    net_opts = {
        "bufsize": 8192,
        "backlog": 0,
        "nodns": args.nodns,
        "udp": args.udp,
        "http": args.http,
        "https": args.https,
        "keep_open": args.keep_open,
        "rebind": True if (type(args.rebind) is int and args.rebind == 0) else args.rebind,
        "reconn": True if (type(args.reconn) is int and args.reconn == 0) else args.reconn,
        "rebind_wait": args.rebind_wait,
        "reconn_wait": args.reconn_wait,
        "rebind_robin": args.rebind_robin,
        "reconn_robin": args.reconn_robin,
        "wait": args.wait,
        "udp_ping_init": args.udp_ping_init,
        "udp_ping_intvl": args.udp_ping_intvl,
        "udp_ping_word": args.udp_ping_word,
        "udp_ping_robing": args.udp_ping_robin,
        "safe_word": args.safe_word,
    }

    # Initialize logger
    if args.verbose == 0:
        loglevel = logging.ERROR
    elif args.verbose == 1:
        loglevel = logging.WARNING
    elif args.verbose == 2:
        loglevel = logging.INFO
    elif args.verbose == 3:
        loglevel = logging.DEBUG
    else:
        loglevel = LOGLEVEL_TRACE_NUM

    logging.addLevelName(LOGLEVEL_TRACE_NUM, "TRACE")
    logging.Logger.trace = logtrace
    logformat = "%(levelname)s %(message)s"
    if args.verbose > 2:
        logformat = "%(levelname)s [%(threadName)s]: %(message)s"
    if args.verbose > 3:
        logformat = "%(levelname)s [%(threadName)s] %(lineno)d:%(funcName)s(): %(message)s"
    logging.basicConfig(format=logformat, level=loglevel)

    # Initialize encoder
    encoder = StringEncoder()

    # Use command modulde
    if args.cmd:
        module_opts = {
            "encoder": encoder,
            "executable": args.cmd,
        }
        mod = NetcatPluginCommand(module_opts)
    # Use output module
    else:
        module_opts = {
            "encoder": encoder,
            "crlf": args.crlf,
            "input_timeout": TIMEOUT_READ_STDIN,
        }
        mod = NetcatPluginOutput(module_opts)

    # Run local port-forward
    # -> listen locally and forward traffic to remote (connect)
    if args.local:
        ssig = StopSignal()
        # TODO: Make the listen address optional!
        srv_opts = net_opts.copy()
        srv_opts["reconn"] = True
        srv_opts["keep_open"] = True
        srv_opts["reconn_wait"] = 0
        lhost = args.local.split(":")[0]
        lport = int(args.local.split(":")[1])
        # Create listen and client instances
        net_srv = NetcatServer(
            encoder, lhost, lport, TIMEOUT_RECV_SOCKET, TIMEOUT_RECV_SOCKET_RETRY, srv_opts
        )
        net_cli = NetcatClient(
            encoder, host, port, TIMEOUT_RECV_SOCKET, TIMEOUT_RECV_SOCKET_RETRY, srv_opts
        )
        # Create Runner
        run = Runner()
        run.add_action(
            {
                "name": "TRANSMIT",
                "producer": net_srv.receive,  # USER sends data to PC-SERVER
                "consumer": net_cli.send,  # Data parsed on to PC-CLIENT to send to TARGET
                "signal": ssig,
                "interrupt": object,
            }
        )
        run.add_action(
            {
                "name": "RECEIVE",
                "producer": net_cli.receive,  # Data comes back from TARGET to PC-CLIENT
                "consumer": net_srv.send,  # Data parsed on to PC-SERVER to back send to USER
                "signal": ssig,
                "interrupt": object,
            }
        )
        run.run()
    # Run server
    if args.listen:
        ssig = StopSignal()
        net = NetcatServer(
            encoder, host, port, TIMEOUT_RECV_SOCKET, TIMEOUT_RECV_SOCKET_RETRY, net_opts
        )
        run = Runner()
        run.add_action(
            {
                "name": "RECV",
                "producer": net.receive,
                "consumer": mod.consumer,
                "signal": ssig,
                "interrupt": mod.interrupt,  # Also force the producer to stop on net error
            }
        )
        run.add_action(
            {
                "name": "STDIN",
                "producer": mod.producer,
                "consumer": net.send,
                "signal": ssig,
                "interrupt": mod.interrupt,  # Externally stop the produer itself
            }
        )
        run.run()

    # Run client
    else:
        ssig = StopSignal()
        net = NetcatClient(
            encoder, host, port, TIMEOUT_RECV_SOCKET, TIMEOUT_RECV_SOCKET_RETRY, net_opts
        )
        run = Runner()
        run.add_action(
            {
                "name": "RECV",
                "producer": net.receive,
                "consumer": mod.consumer,
                "signal": ssig,
                "interrupt": mod.interrupt,  # Also force the producer to stop on net error
            }
        )
        run.add_action(
            {
                "name": "STDIN",
                "producer": mod.producer,
                "consumer": net.send,
                "signal": ssig,
                "interrupt": mod.interrupt,  # Externally stop the produer itself
            }
        )
        if type(args.udp_ping_intvl) is int and args.udp_ping_intvl > 0:
            run.add_timer(
                {
                    "name": "PING",
                    "action": net.send,
                    "intvl": args.udp_ping_intvl,
                    "args": ("\x00"),
                    "signal": ssig,
                }
            )
        run.run()
</code></pre>
  </div>
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="pwncat.ABC" class="name">class <span class="ident">ABC</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.ABC', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.ABC" class="source">
    <pre><code>class ABC(metaclass=ABCMeta):
    """Helper class that provides a standard way to create an ABC using
    inheritance.
    """
    __slots__ = ()
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pwncat.ABC">ABC</a></li>
          <li><a href="/builtins.object.ext">builtins.object</a></li>
          </ul>
      </div>
      </div>
      
      <div class="item">
      <p id="pwncat.AbstractNetcatPlugin" class="name">class <span class="ident">AbstractNetcatPlugin</span></p>
      
  
    <div class="desc"><p>Abstract class to for netcat plugins.</p>
<p>This is a skeleton that defines how the plugins for Netcat should look like.</p>
<p>The "input_generator" should constantly yield data received from some sort of input
which could be user input, output from a shell command data from a socket.</p>
<p>The "input_callback" will apply some sort of action on the data received from a input_generator
which could be output to stdout, send it to the shell or to a socket.</p>
<p>"The "input_interrupter" can implement a mechanism to trigger the input_generator to stop
and return to its parent thread/function. The input_generator must also be implemented
in a way that it is able to act on the event which the "input_interrupter" emitted.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractNetcatPlugin', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractNetcatPlugin" class="source">
    <pre><code>class AbstractNetcatPlugin(ABC):
    """
    Abstract class to for netcat plugins.

    This is a skeleton that defines how the plugins for Netcat should look like.

    The "input_generator" should constantly yield data received from some sort of input
    which could be user input, output from a shell command data from a socket.

    The "input_callback" will apply some sort of action on the data received from a input_generator
    which could be output to stdout, send it to the shell or to a socket.

    "The "input_interrupter" can implement a mechanism to trigger the input_generator to stop
    and return to its parent thread/function. The input_generator must also be implemented
    in a way that it is able to act on the event which the "input_interrupter" emitted.
    """

    __metaclass__ = ABCMeta

    @abstractmethod
    def __init__(self, options={}):
        """
        Set specific options for this plugin.

        Args:
            options (dict):    A dict which allows you to add custom options to your module
        """
        raise NotImplementedError("Should have implemented this")

    @abstractmethod
    def producer(self, ssig):
        """
        Implement a generator function which constantly yields data.

        The data could be from various sources such as: received from a socket,
        received from user input, received from shell command output or anything else.

        Args:
            ssig (StopSignal): A StopSignal instance providing has_stop() and raise_stop() functions
        """
        raise NotImplementedError("Should have implemented this")

    @abstractmethod
    def consumer(self, data):
        """The consumer takes the consumers' output as input and processes it in some form."""
        raise NotImplementedError("Should have implemented this")

    @abstractmethod
    def interrupt(self):
        """Defines an interrupt function which will stop the producer.

        Various producer might call blocking functions and they won't be able to stop themself
        as they hang on that blocking function. This method is triggered from outside and is
        supposed to stop/shutdown the producer.
        If no such interrupt is required, imeplemt it empty."""
        raise NotImplementedError("Should have implemented this")
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pwncat.AbstractNetcatPlugin">AbstractNetcatPlugin</a></li>
          <li><a href="#pwncat.ABC">ABC</a></li>
          <li><a href="/builtins.object.ext">builtins.object</a></li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractNetcatPlugin.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, options={})</p>
    </div>
    

    
  
    <div class="desc"><p>Set specific options for this plugin.</p>
<p>Args:
    options (dict):    A dict which allows you to add custom options to your module</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractNetcatPlugin.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractNetcatPlugin.__init__" class="source">
    <pre><code>@abstractmethod
def __init__(self, options={}):
    """
    Set specific options for this plugin.
    Args:
        options (dict):    A dict which allows you to add custom options to your module
    """
    raise NotImplementedError("Should have implemented this")
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractNetcatPlugin.consumer">
    <p>def <span class="ident">consumer</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>The consumer takes the consumers' output as input and processes it in some form.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractNetcatPlugin.consumer', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractNetcatPlugin.consumer" class="source">
    <pre><code>@abstractmethod
def consumer(self, data):
    """The consumer takes the consumers' output as input and processes it in some form."""
    raise NotImplementedError("Should have implemented this")
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractNetcatPlugin.interrupt">
    <p>def <span class="ident">interrupt</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Defines an interrupt function which will stop the producer.</p>
<p>Various producer might call blocking functions and they won't be able to stop themself
as they hang on that blocking function. This method is triggered from outside and is
supposed to stop/shutdown the producer.
If no such interrupt is required, imeplemt it empty.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractNetcatPlugin.interrupt', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractNetcatPlugin.interrupt" class="source">
    <pre><code>@abstractmethod
def interrupt(self):
    """Defines an interrupt function which will stop the producer.
    Various producer might call blocking functions and they won't be able to stop themself
    as they hang on that blocking function. This method is triggered from outside and is
    supposed to stop/shutdown the producer.
    If no such interrupt is required, imeplemt it empty."""
    raise NotImplementedError("Should have implemented this")
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractNetcatPlugin.producer">
    <p>def <span class="ident">producer</span>(</p><p>self, ssig)</p>
    </div>
    

    
  
    <div class="desc"><p>Implement a generator function which constantly yields data.</p>
<p>The data could be from various sources such as: received from a socket,
received from user input, received from shell command output or anything else.</p>
<p>Args:
    ssig (StopSignal): A StopSignal instance providing has_stop() and raise_stop() functions</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractNetcatPlugin.producer', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractNetcatPlugin.producer" class="source">
    <pre><code>@abstractmethod
def producer(self, ssig):
    """
    Implement a generator function which constantly yields data.
    The data could be from various sources such as: received from a socket,
    received from user input, received from shell command output or anything else.
    Args:
        ssig (StopSignal): A StopSignal instance providing has_stop() and raise_stop() functions
    """
    raise NotImplementedError("Should have implemented this")
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="pwncat.AbstractSocket" class="name">class <span class="ident">AbstractSocket</span></p>
      
  
    <div class="desc"><p>Abstract class which provides TCP, UDP and IPv4, IPv6 Socket funcionality.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractSocket', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractSocket" class="source">
    <pre><code>class AbstractSocket(object):
    """Abstract class which provides TCP, UDP and IPv4, IPv6 Socket funcionality."""

    sock = None  # server binding socket (until accept())
    conn = None  # client/server communication socket

    # The instance role must be 'server' or 'client' and
    # is used to determine how to reconnect broken connections.
    # Either listen again (tcp-only) or re-connect to upstream.
    role = None  # Must be 'server' or 'client'

    # Specify a float of seconds for the socket timeout.
    # A default of None means it is blocking.
    recv_timeout = None

    # If no data is received, the socket will timeout and counts subsequent timeouts
    # with no data received. If 'recv_timeout_retry' many timeouts occured, the socket
    # will stop reading data.
    # The internal counter is reset as soon as data is received again.
    recv_timeout_retry = 0

    options = {
        "bufsize": 1024,  # Receive buffer size
        "backlog": 0,  # Listen backlog
        "nodns": False,  # Do not resolve hostname
        "udp": False,  # Is TCP or UDP?
        "http": False,  # Use HTTP instead
        "https": False,  # Use HTTPS instead
        "keep_open": False,  # Keep server open for new connections
        "rebind": False,  # False (never), True (indefinite) or int for how many times to rebind
        "reconn": False,  # False (never), True (indefinite) or int for how many times to reconnect
        "rebind_wait": 0,  # Time in seconds between re-binds
        "reconn_wait": 0,  # Time in seconds between reconnects
        "rebind_robin": [],  # Ports to round-robind for bindings
        "reconn_robin": [],  # Ports to round-robin for reconnects
        "wait": False,  # Close client if it is idle for x many seconds
        "udp_ping_init": False,  # Send initial UDP ping packet
        "udp_ping_intvl": False,  # Interval in sec for UDP client to ping server
        "udp_ping_word": "\0",  # The char/string to send as UDP ping probe
        "udp_ping_robing": [],  # Ports to round-robing during UDP ping probes
        "safe_word": False,  # Once this is received, the application quits
    }

    # Store the address of the remote end.
    # If we are in server role and running in UDP mode,
    # it must wait for the client to connect first in order
    # to retrieve its addr and port in order to be able
    # to send data back to it.
    remote_addr = None
    remote_port = None

    # ------------------------------------------------------------------------------
    # Constructor / Destructor
    # ------------------------------------------------------------------------------
    def __init__(self, encoder, role, recv_timeout, recv_timeout_retry, options={}):
        """Constructor."""
        assert type(self) is not AbstractSocket, "AbstractSocket cannot be instantiated directly."
        assert role in ["server", "client"], "The role must be 'server' or 'client'."

        self.log = logging.getLogger(__name__)
        self.enc = encoder
        self.role = role

        self.recv_timeout = recv_timeout
        self.recv_timeout_retry = recv_timeout_retry

        # Ensure to provide all items (be explicit - currently helps to find bugs)
        for index in self.options:
            assert index in options, "Provided options are missing key: {}".format(index)
        # Ensure to only provide option itenms that are defined/exist (helps to find bugs)
        for index in options:
            assert index in self.options, "Provided an invalid option item"
            self.options[index] = options[index]

        # Register destructor
        atexit.register(self.__exit__)

    def __exit__(self):
        """Destructor."""

        self.log.trace("Closing 'sock' socket")
        self.__close_socket(self.sock)
        self.sock = None
        self.log.trace("Closing 'conn' socket")
        self.__close_socket(self.conn)
        self.conn = None

    # ------------------------------------------------------------------------------
    # Private Functions
    # ------------------------------------------------------------------------------
    def __close_socket(self, sock):
        """Close a socket."""
        try:
            # (SHUT_RD)   0 = Done receiving (disallows receiving)
            # (SHUT_WR)   1 = Done sending (disallows sending)
            # (SHUT_RDWR) 2 = Both
            sock.shutdown(socket.SHUT_RDWR)
        except (AttributeError, OSError, socket.error):
            self.log.trace("Could not shutdown socket")
            pass
        try:
            sock.close()
        except (AttributeError, OSError, socket.error):
            self.log.trace("Could not shutdown socket")

    def __reconnect(self):
        """Reconnect to a server if upstream has gone."""
        self.__close_socket(self.conn)
        self.__close_socket(self.sock)
        self.create_socket()
        self.conn = self.sock
        if not self.connect():
            self.__reconnect_to_server()

    def __reaccept_from_client(self):
        """Ensure the server is able to keep connection open by re-accepting new clients."""
        # Only for server
        assert self.role == "server", "Only the role 'server' can accept connections."
        # Do not re-accept for UDP
        assert not self.options["udp"], "This should have been caught during arg check."

        # [NO] Do not re-accept
        if not self.options["keep_open"]:
            self.log.info("No automatic re-accept specified. Shutting down.")
            return False
        # [YES] Re-accept indefinitely
        self.log.info("Re-accepting new clients")
        self.__close_socket(self.conn)
        self.accept()
        return True

    def __reconnect_to_server(self):
        """Ensure the client re-connects to the remote server, if the remote server hang up."""
        # Only for Clients
        assert self.role == "client", "Only the role 'client' can re-connect."
        # Do not re-connect with UDP
        assert not self.options["udp"], "This should have been caught during arg check."

        # [NO] Never re-connect
        if type(self.options["reconn"]) is bool and not self.options["reconn"]:
            self.log.info("No automatic reconnect specified. Shutting down.")
            return False
        # [YES] Always re-connect indefinitely
        if type(self.options["reconn"]) is bool and self.options["reconn"]:
            self.log.info(
                "Reconnecting in {} sec (indefinitely)".format(self.options["reconn_wait"])
            )
            time.sleep(self.options["reconn_wait"])
            self.__reconnect()
            return True
        # [YES] Re-connect x many times
        if self.options["reconn"] > 0:
            self.log.info(
                "Reconnecting in {} sec ({} more times left)".format(
                    self.options["reconn_wait"], self.options["reconn"]
                )
            )
            self.options["reconn"] -= 1
            time.sleep(self.options["reconn_wait"])
            self.__reconnect()
            return True
        # [NO] Re-connect count is used up
        self.log.info("Reconnect count is used up. Shutting down.")
        return False

    # ------------------------------------------------------------------------------
    # Helper Functions
    # ------------------------------------------------------------------------------
    def gethostbyname(self, host, port, family):
        """Translate hostname into IP address."""
        socktype = socket.SOCK_DGRAM if self.options["udp"] else socket.SOCK_STREAM
        flags = 0
        if self.options["nodns"]:
            flags = socket.AI_NUMERICHOST
        try:
            self.log.debug("Resolving hostname: {}".format(host))
            (family, socktype, proto, canonname, sockaddr) = socket.getaddrinfo(
                host, port, socket.AF_INET, socktype, flags
            )[0]
        except socket.gaierror as error:
            self.log.error("Resolve Error: {}".format(error))
            sys.exit(1)
        self.log.debug("Resolved hostname:  {}".format(sockaddr[0]))
        return sockaddr[0]

    def create_socket(self):
        """Create TCP or UDP socket."""
        try:
            if self.options["udp"]:
                self.log.debug("Creating UDP socket")
                self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            else:
                self.log.debug("Creating TCP socket")
                self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        except socket.error as error:
            self.log.error("Failed to create the socket: {}".format(error))
            sys.exit(1)
        # Get around the "[Errno 98] Address already in use" error, if the socket is still in wait
        # we instruct it to reuse the address anyway.
        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    def bind(self, addr, port):
        """Bind the socket to an address."""
        try:
            self.log.debug("Binding socket to {}:{}".format(addr, port))
            self.sock.bind((addr, port))
        except (OverflowError, OSError, socket.error) as error:
            self.log.error("Binding socket to {}:{} failed: {}".format(addr, port, error))
            sys.exit(1)

    def listen(self):
        """Listen for connections made to the socket."""
        try:
            self.log.debug("Listening with backlog={}".format(self.options["backlog"]))
            self.sock.listen(self.options["backlog"])
        except socket.error as error:
            self.log.error("Listening failed: {}".format(error))
            sys.exit(1)

    def accept(self):
        """Accept a connection."""
        try:
            self.log.debug("Waiting for TCP client")
            self.conn, client = self.sock.accept()
            addr, port = client
            self.remote_addr = addr
            self.remote_port = port
            self.log.info("Client connected from {}:{}".format(addr, port))
        except (socket.gaierror, socket.error) as error:
            self.log.error("Accept failed: {}".format(error))
            sys.exit(1)

    def connect(self):
        """Connect to a remote socket at given address and port (TCP-only)."""
        try:
            self.log.debug("Connecting to {}:{}".format(self.remote_addr, self.remote_port))
            self.sock.connect((self.remote_addr, self.remote_port))
            return True
        except socket.error as error:
            self.log.error(
                "Connecting to {}:{} failed: {}".format(self.remote_addr, self.remote_port, error)
            )
            return False

    # ------------------------------------------------------------------------------
    # Send / Receive Functions
    # ------------------------------------------------------------------------------
    def send(self, data):
        """Send data."""
        # In case of sending data back to an udp client we need to wait
        # until the client has first connected and told us its addr/port
        if self.options["udp"] and self.remote_addr is None and self.remote_port is None:
            self.log.warning("UDP client has not yet connected. Queueing message")
            while self.remote_addr is None and self.remote_port is None:
                time.sleep(0.1)  # Less wastefull than using 'pass'

        curr = 0  # bytes send during one loop iteration
        send = 0  # total bytes send
        size = len(data)  # bytes of data that needs to be send
        data = self.enc.encode(data)
        assert size == len(data), "Encoding messed up string length, might need to do len() after."

        # Loop until all bytes have been send
        while send < size:
            try:
                self.log.debug(
                    "Trying to send {} bytes to {}:{}".format(
                        size - send, self.remote_addr, self.remote_port
                    )
                )
                self.log.trace("Trying to send: {}".format(repr(data)))
                if self.options["udp"]:
                    curr = self.conn.sendto(data, (self.remote_addr, self.remote_port))
                    send += curr
                else:
                    curr = self.conn.send(data)
                    send += curr
                if curr == 0:
                    self.log.error("No bytes send during loop round.")
                    return
                # Remove 'curr' many bytes from data for the next round
                data = data[curr:]
                self.log.debug(
                    "Sent {} bytes to {}:{} ({} bytes remaining)".format(
                        curr, self.remote_addr, self.remote_port, size - send
                    )
                )
            except socket.error as error:
                if error.errno == socket.errno.EPIPE:
                    self.log.error("TODO:Add desc. Socket error({}): {}".format(error.errno, error))
                    return
                # Most likely nothing to see here??
                # FIXME: TODO: Need to re-accepd new client
                self.log.error("TODO:Add desc. Socket Error: {}".format(error))
                if self.role == "server":
                    if self.__reaccept_from_client():
                        continue
                self.log.warning("Shutdown")
                return
            except (OSError) as error:
                self.log.error("Socket OS Error: {}".format(error))
                return

    def receive(self, ssig):
        """
        Generator function to receive data endlessly by yielding it.

        :param function interrupter: A Func that returns True/False to tell us to stop or not.
        """
        # Set current receive timeout
        self.conn.settimeout(self.recv_timeout)
        self.log.trace("Socket Timeout: {}".format(self.recv_timeout))
        # Counts how many times we had a ready timeout for later to decide
        # if we exceeded maximum retires
        curr_recv_timeout_retry = 0

        while True:
            # Ensure to signal that we do not stop receiving data
            # if ssig.has_stop():
            #    self.log.debug("Interrupt has been requested for receive()")
            #    return

            if self.conn is None:
                self.log.error("Exit. Socket is gone in receive()")
                ssig.raise_stop()
                return

            # Non-blocking socket with timeout. If the timeout threshold is hit,
            # it will throw an socket.timeout exception. This is required to see if other
            # threads have been terminated already.
            try:
                # https://manpages.debian.org/buster/manpages-dev/recv.2.en.html
                (byte, addr) = self.conn.recvfrom(self.options["bufsize"])

            # [1/5] Finished receiving all data
            # NOTE: This is the place where we can do any checks in between reads as the
            # socket has been changed from blocking to time-out based.
            # NOTE: This is also the place, where we quit in case --wait was specified.
            except socket.timeout:
                # Let's ask the interrupter() function if we should terminate?
                if not ssig.has_stop():
                    # No action required, continue the loop and read again.
                    continue
                self.log.debug("Interrupt has been requested for receive()")
                # Other threads are done. Let's try to read a few more times before
                # returning and ending this function (might be data left)
                if curr_recv_timeout_retry < self.recv_timeout_retry:
                    self.log.trace(
                        "Final socket read: {}/{} before quitting.".format(
                            curr_recv_timeout_retry, self.recv_timeout_retry
                        )
                    )
                    curr_recv_timeout_retry += 1
                    continue
                ssig.raise_stop()
                return

            # [2/5] Connection was forcibly closed
            # [Errno 10054] An existing connection was forcibly closed by the remote host
            # [WinError 10054] An existing connection was forcibly closed by the remote host
            # So we will just warn (instead of error our), ignore (don't return here) and
            # let the bottom of this function decide whether we should just quit or
            # reconnect/bind (if the user specified this.
            except socket.error as error:
                # Also ensure we reset the 'byte' value to none so that the below check can kick in.
                byte = None
                self.log.warning("Socket Receive: {}".format(error))

            # [3/5] TODO: Still need to figure out what this error is and when it is thrown
            except AttributeError as error:
                self.log.error("TODO: What happens here?Attribute Receive Error: {}".format(error))
                ssig.raise_stop()
                return

            # We're receiving data again, so let's reset the retry/terminate counter
            # The counter is incremented in 'except socket.timeout' above.
            curr_recv_timeout_retry = 0

            # If we're receiving data from a UDP client
            # we can firstly/finally set its addr/port in order
            # to send data back to it (see send() function)
            if self.options["udp"]:
                self.remote_addr, self.remote_port = addr
                self.log.debug("Client connected: {}:{}".format(self.remote_addr, self.remote_port))

            # [4/5] Upstream (server or client) is gone. Do we reconnect or quit?
            if not byte:
                self.log.trace("Socket: Empty data received or otherwise caught.")

                if self.role == "server":
                    # Yay, we want to continue and allow new clients
                    if self.__reaccept_from_client():
                        self.log.trace("Server can continue, because of --keep-open")
                        continue
                if self.role == "client":
                    # Yay, we want to continue and our client will re-connect upstream again
                    if self.__reconnect_to_server():
                        self.log.trace("Client can continue, because of --reconn")
                        continue

                self.log.warning("Exit. Upstream connection gone. No --keep-open/--reconn set.")
                ssig.raise_stop()
                return

            # [5/5] We have data to process
            data = self.enc.decode(byte)
            self.log.debug(
                "Received {} bytes from {}:{}".format(len(data), self.remote_addr, self.remote_port)
            )
            self.log.trace("Received: {}".format(repr(data)))

            yield data
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pwncat.AbstractSocket">AbstractSocket</a></li>
          <li><a href="/builtins.object.ext">builtins.object</a></li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="pwncat.AbstractSocket.conn" class="name">var <span class="ident">conn</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.options" class="name">var <span class="ident">options</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.recv_timeout" class="name">var <span class="ident">recv_timeout</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.recv_timeout_retry" class="name">var <span class="ident">recv_timeout_retry</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.remote_addr" class="name">var <span class="ident">remote_addr</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.remote_port" class="name">var <span class="ident">remote_port</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.role" class="name">var <span class="ident">role</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.sock" class="name">var <span class="ident">sock</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractSocket.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, encoder, role, recv_timeout, recv_timeout_retry, options={})</p>
    </div>
    

    
  
    <div class="desc"><p>Constructor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractSocket.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractSocket.__init__" class="source">
    <pre><code>def __init__(self, encoder, role, recv_timeout, recv_timeout_retry, options={}):
    """Constructor."""
    assert type(self) is not AbstractSocket, "AbstractSocket cannot be instantiated directly."
    assert role in ["server", "client"], "The role must be 'server' or 'client'."
    self.log = logging.getLogger(__name__)
    self.enc = encoder
    self.role = role
    self.recv_timeout = recv_timeout
    self.recv_timeout_retry = recv_timeout_retry
    # Ensure to provide all items (be explicit - currently helps to find bugs)
    for index in self.options:
        assert index in options, "Provided options are missing key: {}".format(index)
    # Ensure to only provide option itenms that are defined/exist (helps to find bugs)
    for index in options:
        assert index in self.options, "Provided an invalid option item"
        self.options[index] = options[index]
    # Register destructor
    atexit.register(self.__exit__)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractSocket.accept">
    <p>def <span class="ident">accept</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Accept a connection.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractSocket.accept', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractSocket.accept" class="source">
    <pre><code>def accept(self):
    """Accept a connection."""
    try:
        self.log.debug("Waiting for TCP client")
        self.conn, client = self.sock.accept()
        addr, port = client
        self.remote_addr = addr
        self.remote_port = port
        self.log.info("Client connected from {}:{}".format(addr, port))
    except (socket.gaierror, socket.error) as error:
        self.log.error("Accept failed: {}".format(error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractSocket.bind">
    <p>def <span class="ident">bind</span>(</p><p>self, addr, port)</p>
    </div>
    

    
  
    <div class="desc"><p>Bind the socket to an address.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractSocket.bind', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractSocket.bind" class="source">
    <pre><code>def bind(self, addr, port):
    """Bind the socket to an address."""
    try:
        self.log.debug("Binding socket to {}:{}".format(addr, port))
        self.sock.bind((addr, port))
    except (OverflowError, OSError, socket.error) as error:
        self.log.error("Binding socket to {}:{} failed: {}".format(addr, port, error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractSocket.connect">
    <p>def <span class="ident">connect</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Connect to a remote socket at given address and port (TCP-only).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractSocket.connect', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractSocket.connect" class="source">
    <pre><code>def connect(self):
    """Connect to a remote socket at given address and port (TCP-only)."""
    try:
        self.log.debug("Connecting to {}:{}".format(self.remote_addr, self.remote_port))
        self.sock.connect((self.remote_addr, self.remote_port))
        return True
    except socket.error as error:
        self.log.error(
            "Connecting to {}:{} failed: {}".format(self.remote_addr, self.remote_port, error)
        )
        return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractSocket.create_socket">
    <p>def <span class="ident">create_socket</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Create TCP or UDP socket.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractSocket.create_socket', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractSocket.create_socket" class="source">
    <pre><code>def create_socket(self):
    """Create TCP or UDP socket."""
    try:
        if self.options["udp"]:
            self.log.debug("Creating UDP socket")
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        else:
            self.log.debug("Creating TCP socket")
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    except socket.error as error:
        self.log.error("Failed to create the socket: {}".format(error))
        sys.exit(1)
    # Get around the "[Errno 98] Address already in use" error, if the socket is still in wait
    # we instruct it to reuse the address anyway.
    self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractSocket.gethostbyname">
    <p>def <span class="ident">gethostbyname</span>(</p><p>self, host, port, family)</p>
    </div>
    

    
  
    <div class="desc"><p>Translate hostname into IP address.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractSocket.gethostbyname', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractSocket.gethostbyname" class="source">
    <pre><code>def gethostbyname(self, host, port, family):
    """Translate hostname into IP address."""
    socktype = socket.SOCK_DGRAM if self.options["udp"] else socket.SOCK_STREAM
    flags = 0
    if self.options["nodns"]:
        flags = socket.AI_NUMERICHOST
    try:
        self.log.debug("Resolving hostname: {}".format(host))
        (family, socktype, proto, canonname, sockaddr) = socket.getaddrinfo(
            host, port, socket.AF_INET, socktype, flags
        )[0]
    except socket.gaierror as error:
        self.log.error("Resolve Error: {}".format(error))
        sys.exit(1)
    self.log.debug("Resolved hostname:  {}".format(sockaddr[0]))
    return sockaddr[0]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractSocket.listen">
    <p>def <span class="ident">listen</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Listen for connections made to the socket.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractSocket.listen', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractSocket.listen" class="source">
    <pre><code>def listen(self):
    """Listen for connections made to the socket."""
    try:
        self.log.debug("Listening with backlog={}".format(self.options["backlog"]))
        self.sock.listen(self.options["backlog"])
    except socket.error as error:
        self.log.error("Listening failed: {}".format(error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractSocket.receive">
    <p>def <span class="ident">receive</span>(</p><p>self, ssig)</p>
    </div>
    

    
  
    <div class="desc"><p>Generator function to receive data endlessly by yielding it.</p>
<p>:param function interrupter: A Func that returns True/False to tell us to stop or not.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractSocket.receive', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractSocket.receive" class="source">
    <pre><code>def receive(self, ssig):
    """
    Generator function to receive data endlessly by yielding it.
    :param function interrupter: A Func that returns True/False to tell us to stop or not.
    """
    # Set current receive timeout
    self.conn.settimeout(self.recv_timeout)
    self.log.trace("Socket Timeout: {}".format(self.recv_timeout))
    # Counts how many times we had a ready timeout for later to decide
    # if we exceeded maximum retires
    curr_recv_timeout_retry = 0
    while True:
        # Ensure to signal that we do not stop receiving data
        # if ssig.has_stop():
        #    self.log.debug("Interrupt has been requested for receive()")
        #    return
        if self.conn is None:
            self.log.error("Exit. Socket is gone in receive()")
            ssig.raise_stop()
            return
        # Non-blocking socket with timeout. If the timeout threshold is hit,
        # it will throw an socket.timeout exception. This is required to see if other
        # threads have been terminated already.
        try:
            # https://manpages.debian.org/buster/manpages-dev/recv.2.en.html
            (byte, addr) = self.conn.recvfrom(self.options["bufsize"])
        # [1/5] Finished receiving all data
        # NOTE: This is the place where we can do any checks in between reads as the
        # socket has been changed from blocking to time-out based.
        # NOTE: This is also the place, where we quit in case --wait was specified.
        except socket.timeout:
            # Let's ask the interrupter() function if we should terminate?
            if not ssig.has_stop():
                # No action required, continue the loop and read again.
                continue
            self.log.debug("Interrupt has been requested for receive()")
            # Other threads are done. Let's try to read a few more times before
            # returning and ending this function (might be data left)
            if curr_recv_timeout_retry < self.recv_timeout_retry:
                self.log.trace(
                    "Final socket read: {}/{} before quitting.".format(
                        curr_recv_timeout_retry, self.recv_timeout_retry
                    )
                )
                curr_recv_timeout_retry += 1
                continue
            ssig.raise_stop()
            return
        # [2/5] Connection was forcibly closed
        # [Errno 10054] An existing connection was forcibly closed by the remote host
        # [WinError 10054] An existing connection was forcibly closed by the remote host
        # So we will just warn (instead of error our), ignore (don't return here) and
        # let the bottom of this function decide whether we should just quit or
        # reconnect/bind (if the user specified this.
        except socket.error as error:
            # Also ensure we reset the 'byte' value to none so that the below check can kick in.
            byte = None
            self.log.warning("Socket Receive: {}".format(error))
        # [3/5] TODO: Still need to figure out what this error is and when it is thrown
        except AttributeError as error:
            self.log.error("TODO: What happens here?Attribute Receive Error: {}".format(error))
            ssig.raise_stop()
            return
        # We're receiving data again, so let's reset the retry/terminate counter
        # The counter is incremented in 'except socket.timeout' above.
        curr_recv_timeout_retry = 0
        # If we're receiving data from a UDP client
        # we can firstly/finally set its addr/port in order
        # to send data back to it (see send() function)
        if self.options["udp"]:
            self.remote_addr, self.remote_port = addr
            self.log.debug("Client connected: {}:{}".format(self.remote_addr, self.remote_port))
        # [4/5] Upstream (server or client) is gone. Do we reconnect or quit?
        if not byte:
            self.log.trace("Socket: Empty data received or otherwise caught.")
            if self.role == "server":
                # Yay, we want to continue and allow new clients
                if self.__reaccept_from_client():
                    self.log.trace("Server can continue, because of --keep-open")
                    continue
            if self.role == "client":
                # Yay, we want to continue and our client will re-connect upstream again
                if self.__reconnect_to_server():
                    self.log.trace("Client can continue, because of --reconn")
                    continue
            self.log.warning("Exit. Upstream connection gone. No --keep-open/--reconn set.")
            ssig.raise_stop()
            return
        # [5/5] We have data to process
        data = self.enc.decode(byte)
        self.log.debug(
            "Received {} bytes from {}:{}".format(len(data), self.remote_addr, self.remote_port)
        )
        self.log.trace("Received: {}".format(repr(data)))
        yield data
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractSocket.send">
    <p>def <span class="ident">send</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>Send data.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractSocket.send', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractSocket.send" class="source">
    <pre><code>def send(self, data):
    """Send data."""
    # In case of sending data back to an udp client we need to wait
    # until the client has first connected and told us its addr/port
    if self.options["udp"] and self.remote_addr is None and self.remote_port is None:
        self.log.warning("UDP client has not yet connected. Queueing message")
        while self.remote_addr is None and self.remote_port is None:
            time.sleep(0.1)  # Less wastefull than using 'pass'
    curr = 0  # bytes send during one loop iteration
    send = 0  # total bytes send
    size = len(data)  # bytes of data that needs to be send
    data = self.enc.encode(data)
    assert size == len(data), "Encoding messed up string length, might need to do len() after."
    # Loop until all bytes have been send
    while send < size:
        try:
            self.log.debug(
                "Trying to send {} bytes to {}:{}".format(
                    size - send, self.remote_addr, self.remote_port
                )
            )
            self.log.trace("Trying to send: {}".format(repr(data)))
            if self.options["udp"]:
                curr = self.conn.sendto(data, (self.remote_addr, self.remote_port))
                send += curr
            else:
                curr = self.conn.send(data)
                send += curr
            if curr == 0:
                self.log.error("No bytes send during loop round.")
                return
            # Remove 'curr' many bytes from data for the next round
            data = data[curr:]
            self.log.debug(
                "Sent {} bytes to {}:{} ({} bytes remaining)".format(
                    curr, self.remote_addr, self.remote_port, size - send
                )
            )
        except socket.error as error:
            if error.errno == socket.errno.EPIPE:
                self.log.error("TODO:Add desc. Socket error({}): {}".format(error.errno, error))
                return
            # Most likely nothing to see here??
            # FIXME: TODO: Need to re-accepd new client
            self.log.error("TODO:Add desc. Socket Error: {}".format(error))
            if self.role == "server":
                if self.__reaccept_from_client():
                    continue
            self.log.warning("Shutdown")
            return
        except (OSError) as error:
            self.log.error("Socket OS Error: {}".format(error))
            return
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pwncat.AbstractSocket.enc" class="name">var <span class="ident">enc</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.log" class="name">var <span class="ident">log</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.recv_timeout" class="name">var <span class="ident">recv_timeout</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.recv_timeout_retry" class="name">var <span class="ident">recv_timeout_retry</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.role" class="name">var <span class="ident">role</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="pwncat.NetcatClient" class="name">class <span class="ident">NetcatClient</span></p>
      
  
    <div class="desc"><p>Netcat Client implementation.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatClient', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatClient" class="source">
    <pre><code>class NetcatClient(AbstractSocket):
    """Netcat Client implementation."""

    def __init__(self, encoder, host, port, recv_timeout, recv_timeout_retry, options={}):
        """Construct a connecting clientt."""
        super(NetcatClient, self).__init__(
            encoder, "client", recv_timeout, recv_timeout_retry, options
        )

        # Setup client
        addr = self.gethostbyname(host, port, socket.AF_INET)
        self.create_socket()
        self.conn = self.sock

        self.remote_addr = addr
        self.remote_port = port
        if not self.options["udp"]:
            if self.connect():
                return
            if self._AbstractSocket__reconnect_to_server():
                return
            sys.exit(1)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pwncat.NetcatClient">NetcatClient</a></li>
          <li><a href="#pwncat.AbstractSocket">AbstractSocket</a></li>
          <li><a href="/builtins.object.ext">builtins.object</a></li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="pwncat.NetcatClient.options" class="name">var <span class="ident">options</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatClient.recv_timeout" class="name">var <span class="ident">recv_timeout</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatClient.recv_timeout_retry" class="name">var <span class="ident">recv_timeout_retry</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatClient.role" class="name">var <span class="ident">role</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatClient.sock" class="name">var <span class="ident">sock</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatClient.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, encoder, host, port, recv_timeout, recv_timeout_retry, options={})</p>
    </div>
    

    
  
    <div class="desc"><p>Construct a connecting clientt.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatClient.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatClient.__init__" class="source">
    <pre><code>def __init__(self, encoder, host, port, recv_timeout, recv_timeout_retry, options={}):
    """Construct a connecting clientt."""
    super(NetcatClient, self).__init__(
        encoder, "client", recv_timeout, recv_timeout_retry, options
    )
    # Setup client
    addr = self.gethostbyname(host, port, socket.AF_INET)
    self.create_socket()
    self.conn = self.sock
    self.remote_addr = addr
    self.remote_port = port
    if not self.options["udp"]:
        if self.connect():
            return
        if self._AbstractSocket__reconnect_to_server():
            return
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatClient.accept">
    <p>def <span class="ident">accept</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Accept a connection.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatClient.accept', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatClient.accept" class="source">
    <pre><code>def accept(self):
    """Accept a connection."""
    try:
        self.log.debug("Waiting for TCP client")
        self.conn, client = self.sock.accept()
        addr, port = client
        self.remote_addr = addr
        self.remote_port = port
        self.log.info("Client connected from {}:{}".format(addr, port))
    except (socket.gaierror, socket.error) as error:
        self.log.error("Accept failed: {}".format(error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatClient.bind">
    <p>def <span class="ident">bind</span>(</p><p>self, addr, port)</p>
    </div>
    

    
  
    <div class="desc"><p>Bind the socket to an address.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatClient.bind', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatClient.bind" class="source">
    <pre><code>def bind(self, addr, port):
    """Bind the socket to an address."""
    try:
        self.log.debug("Binding socket to {}:{}".format(addr, port))
        self.sock.bind((addr, port))
    except (OverflowError, OSError, socket.error) as error:
        self.log.error("Binding socket to {}:{} failed: {}".format(addr, port, error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatClient.connect">
    <p>def <span class="ident">connect</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Connect to a remote socket at given address and port (TCP-only).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatClient.connect', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatClient.connect" class="source">
    <pre><code>def connect(self):
    """Connect to a remote socket at given address and port (TCP-only)."""
    try:
        self.log.debug("Connecting to {}:{}".format(self.remote_addr, self.remote_port))
        self.sock.connect((self.remote_addr, self.remote_port))
        return True
    except socket.error as error:
        self.log.error(
            "Connecting to {}:{} failed: {}".format(self.remote_addr, self.remote_port, error)
        )
        return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatClient.create_socket">
    <p>def <span class="ident">create_socket</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Create TCP or UDP socket.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatClient.create_socket', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatClient.create_socket" class="source">
    <pre><code>def create_socket(self):
    """Create TCP or UDP socket."""
    try:
        if self.options["udp"]:
            self.log.debug("Creating UDP socket")
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        else:
            self.log.debug("Creating TCP socket")
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    except socket.error as error:
        self.log.error("Failed to create the socket: {}".format(error))
        sys.exit(1)
    # Get around the "[Errno 98] Address already in use" error, if the socket is still in wait
    # we instruct it to reuse the address anyway.
    self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatClient.gethostbyname">
    <p>def <span class="ident">gethostbyname</span>(</p><p>self, host, port, family)</p>
    </div>
    

    
  
    <div class="desc"><p>Translate hostname into IP address.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatClient.gethostbyname', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatClient.gethostbyname" class="source">
    <pre><code>def gethostbyname(self, host, port, family):
    """Translate hostname into IP address."""
    socktype = socket.SOCK_DGRAM if self.options["udp"] else socket.SOCK_STREAM
    flags = 0
    if self.options["nodns"]:
        flags = socket.AI_NUMERICHOST
    try:
        self.log.debug("Resolving hostname: {}".format(host))
        (family, socktype, proto, canonname, sockaddr) = socket.getaddrinfo(
            host, port, socket.AF_INET, socktype, flags
        )[0]
    except socket.gaierror as error:
        self.log.error("Resolve Error: {}".format(error))
        sys.exit(1)
    self.log.debug("Resolved hostname:  {}".format(sockaddr[0]))
    return sockaddr[0]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatClient.listen">
    <p>def <span class="ident">listen</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Listen for connections made to the socket.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatClient.listen', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatClient.listen" class="source">
    <pre><code>def listen(self):
    """Listen for connections made to the socket."""
    try:
        self.log.debug("Listening with backlog={}".format(self.options["backlog"]))
        self.sock.listen(self.options["backlog"])
    except socket.error as error:
        self.log.error("Listening failed: {}".format(error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatClient.receive">
    <p>def <span class="ident">receive</span>(</p><p>self, ssig)</p>
    </div>
    

    
  
    <div class="desc"><p>Generator function to receive data endlessly by yielding it.</p>
<p>:param function interrupter: A Func that returns True/False to tell us to stop or not.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatClient.receive', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatClient.receive" class="source">
    <pre><code>def receive(self, ssig):
    """
    Generator function to receive data endlessly by yielding it.
    :param function interrupter: A Func that returns True/False to tell us to stop or not.
    """
    # Set current receive timeout
    self.conn.settimeout(self.recv_timeout)
    self.log.trace("Socket Timeout: {}".format(self.recv_timeout))
    # Counts how many times we had a ready timeout for later to decide
    # if we exceeded maximum retires
    curr_recv_timeout_retry = 0
    while True:
        # Ensure to signal that we do not stop receiving data
        # if ssig.has_stop():
        #    self.log.debug("Interrupt has been requested for receive()")
        #    return
        if self.conn is None:
            self.log.error("Exit. Socket is gone in receive()")
            ssig.raise_stop()
            return
        # Non-blocking socket with timeout. If the timeout threshold is hit,
        # it will throw an socket.timeout exception. This is required to see if other
        # threads have been terminated already.
        try:
            # https://manpages.debian.org/buster/manpages-dev/recv.2.en.html
            (byte, addr) = self.conn.recvfrom(self.options["bufsize"])
        # [1/5] Finished receiving all data
        # NOTE: This is the place where we can do any checks in between reads as the
        # socket has been changed from blocking to time-out based.
        # NOTE: This is also the place, where we quit in case --wait was specified.
        except socket.timeout:
            # Let's ask the interrupter() function if we should terminate?
            if not ssig.has_stop():
                # No action required, continue the loop and read again.
                continue
            self.log.debug("Interrupt has been requested for receive()")
            # Other threads are done. Let's try to read a few more times before
            # returning and ending this function (might be data left)
            if curr_recv_timeout_retry < self.recv_timeout_retry:
                self.log.trace(
                    "Final socket read: {}/{} before quitting.".format(
                        curr_recv_timeout_retry, self.recv_timeout_retry
                    )
                )
                curr_recv_timeout_retry += 1
                continue
            ssig.raise_stop()
            return
        # [2/5] Connection was forcibly closed
        # [Errno 10054] An existing connection was forcibly closed by the remote host
        # [WinError 10054] An existing connection was forcibly closed by the remote host
        # So we will just warn (instead of error our), ignore (don't return here) and
        # let the bottom of this function decide whether we should just quit or
        # reconnect/bind (if the user specified this.
        except socket.error as error:
            # Also ensure we reset the 'byte' value to none so that the below check can kick in.
            byte = None
            self.log.warning("Socket Receive: {}".format(error))
        # [3/5] TODO: Still need to figure out what this error is and when it is thrown
        except AttributeError as error:
            self.log.error("TODO: What happens here?Attribute Receive Error: {}".format(error))
            ssig.raise_stop()
            return
        # We're receiving data again, so let's reset the retry/terminate counter
        # The counter is incremented in 'except socket.timeout' above.
        curr_recv_timeout_retry = 0
        # If we're receiving data from a UDP client
        # we can firstly/finally set its addr/port in order
        # to send data back to it (see send() function)
        if self.options["udp"]:
            self.remote_addr, self.remote_port = addr
            self.log.debug("Client connected: {}:{}".format(self.remote_addr, self.remote_port))
        # [4/5] Upstream (server or client) is gone. Do we reconnect or quit?
        if not byte:
            self.log.trace("Socket: Empty data received or otherwise caught.")
            if self.role == "server":
                # Yay, we want to continue and allow new clients
                if self.__reaccept_from_client():
                    self.log.trace("Server can continue, because of --keep-open")
                    continue
            if self.role == "client":
                # Yay, we want to continue and our client will re-connect upstream again
                if self.__reconnect_to_server():
                    self.log.trace("Client can continue, because of --reconn")
                    continue
            self.log.warning("Exit. Upstream connection gone. No --keep-open/--reconn set.")
            ssig.raise_stop()
            return
        # [5/5] We have data to process
        data = self.enc.decode(byte)
        self.log.debug(
            "Received {} bytes from {}:{}".format(len(data), self.remote_addr, self.remote_port)
        )
        self.log.trace("Received: {}".format(repr(data)))
        yield data
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatClient.send">
    <p>def <span class="ident">send</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>Send data.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatClient.send', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatClient.send" class="source">
    <pre><code>def send(self, data):
    """Send data."""
    # In case of sending data back to an udp client we need to wait
    # until the client has first connected and told us its addr/port
    if self.options["udp"] and self.remote_addr is None and self.remote_port is None:
        self.log.warning("UDP client has not yet connected. Queueing message")
        while self.remote_addr is None and self.remote_port is None:
            time.sleep(0.1)  # Less wastefull than using 'pass'
    curr = 0  # bytes send during one loop iteration
    send = 0  # total bytes send
    size = len(data)  # bytes of data that needs to be send
    data = self.enc.encode(data)
    assert size == len(data), "Encoding messed up string length, might need to do len() after."
    # Loop until all bytes have been send
    while send < size:
        try:
            self.log.debug(
                "Trying to send {} bytes to {}:{}".format(
                    size - send, self.remote_addr, self.remote_port
                )
            )
            self.log.trace("Trying to send: {}".format(repr(data)))
            if self.options["udp"]:
                curr = self.conn.sendto(data, (self.remote_addr, self.remote_port))
                send += curr
            else:
                curr = self.conn.send(data)
                send += curr
            if curr == 0:
                self.log.error("No bytes send during loop round.")
                return
            # Remove 'curr' many bytes from data for the next round
            data = data[curr:]
            self.log.debug(
                "Sent {} bytes to {}:{} ({} bytes remaining)".format(
                    curr, self.remote_addr, self.remote_port, size - send
                )
            )
        except socket.error as error:
            if error.errno == socket.errno.EPIPE:
                self.log.error("TODO:Add desc. Socket error({}): {}".format(error.errno, error))
                return
            # Most likely nothing to see here??
            # FIXME: TODO: Need to re-accepd new client
            self.log.error("TODO:Add desc. Socket Error: {}".format(error))
            if self.role == "server":
                if self.__reaccept_from_client():
                    continue
            self.log.warning("Shutdown")
            return
        except (OSError) as error:
            self.log.error("Socket OS Error: {}".format(error))
            return
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pwncat.NetcatClient.conn" class="name">var <span class="ident">conn</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatClient.remote_addr" class="name">var <span class="ident">remote_addr</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatClient.remote_port" class="name">var <span class="ident">remote_port</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="pwncat.NetcatPluginCommand" class="name">class <span class="ident">NetcatPluginCommand</span></p>
      
  
    <div class="desc"><p>Implement command execution functionality.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatPluginCommand', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatPluginCommand" class="source">
    <pre><code>class NetcatPluginCommand(AbstractNetcatPlugin):
    """Implement command execution functionality."""

    executable = None

    # ------------------------------------------------------------------------------
    # Constructor / Destructor
    # ------------------------------------------------------------------------------
    def __init__(self, options={}):
        """Set specific options for this plugin."""
        assert "encoder" in options
        assert "executable" in options

        self.log = logging.getLogger(__name__)
        self.enc = options["encoder"]
        self.executable = options["executable"]
        self.log.debug("Setting '{}' as executable".format(self.executable))

        # Open executable to wait for commands
        env = os.environ.copy()
        try:
            self.p = Popen(
                # TODO: should I also use 'bufsize=1'?
                self.executable,
                stdin=PIPE,
                stdout=PIPE,
                stderr=subprocess.STDOUT,
                shell=False,
                env=env,
            )
        # Python-2 compat (doesn't have FileNotFoundError)
        except OSError:
            self.log.error("Specified executable '{}' not found".format(self.executable))
            sys.exit(1)
        except FileNotFoundError:
            self.log.error("Specified executable '{}' not found".format(self.executable))
            sys.exit(1)

        # Define destructor
        atexit.register(self.__exit__)

    def __exit__(self):
        """Destructor."""
        self.log.trace("Killing executable: {} with pid {}".format(self.executable, self.p.pid))
        self.p.kill()

    def __set_input_timeout(self, timeout=0.1):
        """Throw a TimeOutError Exception for sys.stdin (Linux only)."""
        # select((rlist, wlist, xlist, timeout)
        # rlist: wait until ready for reading
        # wlist: wait until ready for writing
        # xlist: wait for an "exceptional condition"
        i, o, e = select.select([self.p.stdout], [], [], timeout)
        if not i:
            raise BaseException("timed out")

    # ------------------------------------------------------------------------------
    # Public Functions
    # ------------------------------------------------------------------------------
    def interrupt(self):
        """Stop function that can be called externally to close this instance."""
        self.log.trace("[NetcatPluginCommand] subprocess.kill() was raised by input_unterrupter()")
        self.p.kill()

    def producer(self, ssig):
        """Constantly ask for input."""
        while True:
            if ssig.has_stop():
                self.log.trace("Stop signal acknowledged in Command")
                return
            self.log.trace("Reading command output")
            # TODO: non-blocking read does not seem to work or?
            # try:
            # self.__set_input_timeout(timeout=1.5)
            data = self.p.stdout.readline()  # Much better performance than self.p.read(1)
            self.log.trace(data)
            # except BaseException:
            #    if THREAD_TERMINATE:
            #        return
            #    # No input, just check again
            #    #self.p.stdout.flush()
            #    continue
            data = self.enc.decode(data)
            self.log.trace("Command output: {}".format(data))
            if not data:
                self.log.trace("Command output was empty. Exiting loop.")
                break
            yield data

    def consumer(self, data):
        """Send data received to stdin (command input)."""
        data = self.enc.encode(data)
        self.log.trace("Appending to stdin: {}".format(data))
        self.p.stdin.write(data)
        self.p.stdin.flush()
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pwncat.NetcatPluginCommand">NetcatPluginCommand</a></li>
          <li><a href="#pwncat.AbstractNetcatPlugin">AbstractNetcatPlugin</a></li>
          <li><a href="#pwncat.ABC">ABC</a></li>
          <li><a href="/builtins.object.ext">builtins.object</a></li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="pwncat.NetcatPluginCommand.executable" class="name">var <span class="ident">executable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatPluginCommand.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, options={})</p>
    </div>
    

    
  
    <div class="desc"><p>Set specific options for this plugin.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatPluginCommand.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatPluginCommand.__init__" class="source">
    <pre><code>def __init__(self, options={}):
    """Set specific options for this plugin."""
    assert "encoder" in options
    assert "executable" in options
    self.log = logging.getLogger(__name__)
    self.enc = options["encoder"]
    self.executable = options["executable"]
    self.log.debug("Setting '{}' as executable".format(self.executable))
    # Open executable to wait for commands
    env = os.environ.copy()
    try:
        self.p = Popen(
            # TODO: should I also use 'bufsize=1'?
            self.executable,
            stdin=PIPE,
            stdout=PIPE,
            stderr=subprocess.STDOUT,
            shell=False,
            env=env,
        )
    # Python-2 compat (doesn't have FileNotFoundError)
    except OSError:
        self.log.error("Specified executable '{}' not found".format(self.executable))
        sys.exit(1)
    except FileNotFoundError:
        self.log.error("Specified executable '{}' not found".format(self.executable))
        sys.exit(1)
    # Define destructor
    atexit.register(self.__exit__)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatPluginCommand.consumer">
    <p>def <span class="ident">consumer</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>Send data received to stdin (command input).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatPluginCommand.consumer', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatPluginCommand.consumer" class="source">
    <pre><code>def consumer(self, data):
    """Send data received to stdin (command input)."""
    data = self.enc.encode(data)
    self.log.trace("Appending to stdin: {}".format(data))
    self.p.stdin.write(data)
    self.p.stdin.flush()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatPluginCommand.interrupt">
    <p>def <span class="ident">interrupt</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Stop function that can be called externally to close this instance.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatPluginCommand.interrupt', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatPluginCommand.interrupt" class="source">
    <pre><code>def interrupt(self):
    """Stop function that can be called externally to close this instance."""
    self.log.trace("[NetcatPluginCommand] subprocess.kill() was raised by input_unterrupter()")
    self.p.kill()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatPluginCommand.producer">
    <p>def <span class="ident">producer</span>(</p><p>self, ssig)</p>
    </div>
    

    
  
    <div class="desc"><p>Constantly ask for input.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatPluginCommand.producer', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatPluginCommand.producer" class="source">
    <pre><code>def producer(self, ssig):
    """Constantly ask for input."""
    while True:
        if ssig.has_stop():
            self.log.trace("Stop signal acknowledged in Command")
            return
        self.log.trace("Reading command output")
        # TODO: non-blocking read does not seem to work or?
        # try:
        # self.__set_input_timeout(timeout=1.5)
        data = self.p.stdout.readline()  # Much better performance than self.p.read(1)
        self.log.trace(data)
        # except BaseException:
        #    if THREAD_TERMINATE:
        #        return
        #    # No input, just check again
        #    #self.p.stdout.flush()
        #    continue
        data = self.enc.decode(data)
        self.log.trace("Command output: {}".format(data))
        if not data:
            self.log.trace("Command output was empty. Exiting loop.")
            break
        yield data
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pwncat.NetcatPluginCommand.enc" class="name">var <span class="ident">enc</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatPluginCommand.executable" class="name">var <span class="ident">executable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatPluginCommand.log" class="name">var <span class="ident">log</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="pwncat.NetcatPluginOutput" class="name">class <span class="ident">NetcatPluginOutput</span></p>
      
  
    <div class="desc"><p>Implement basic input/output plugin.</p>
<p>This plugin provides a generator which continuously reads from stdin
(non-blocking on POSIX and blocking on windows) as well as a
callback that writes to stdout.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatPluginOutput', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatPluginOutput" class="source">
    <pre><code>class NetcatPluginOutput(AbstractNetcatPlugin):
    """Implement basic input/output plugin.

    This plugin provides a generator which continuously reads from stdin
    (non-blocking on POSIX and blocking on windows) as well as a
    callback that writes to stdout.
    """

    # Replace '\n' linefeeds (if they exist) with CRLF ('\r\n')?
    crlf = False

    # Non-blocking read from stdin achieved via timeout.
    # Specify timeout in seconds.
    input_timeout = None

    # ------------------------------------------------------------------------------
    # Constructor / Destructor
    # ------------------------------------------------------------------------------
    def __init__(self, options={}):
        """Set specific options for this plugin."""
        super(AbstractNetcatPlugin, self).__init__()
        assert "encoder" in options
        assert "input_timeout" in options
        assert "crlf" in options

        self.log = logging.getLogger(__name__)
        self.enc = options["encoder"]
        if "input_timeout" in options:
            self.input_timeout = options["input_timeout"]
        if "crlf" in options:
            self.crlf = options["crlf"]

    # ------------------------------------------------------------------------------
    # Private Functions
    # ------------------------------------------------------------------------------
    def __use_linefeeds(self, data):
        """Ensure the user input has the desired linefeeds --crlf or not."""
        # No replacement requested
        if not self.crlf:
            return data
        # Already have CRLF at the end
        if data.endswith("\r\n"):
            return data
        # Replace current newline character with CRLF
        if data.endswith("\n"):
            self.log.debug("Replacing LF with CRLF")
            return data[:-1] + "\r\n"
        # Otherwise just return as it is
        return data

    def __set_input_timeout(self):
        """Throws a catchable BaseException for sys.stdin after timeout (Linux only)."""
        i, o, e = select.select([sys.stdin], [], [], self.input_timeout)
        if not i:
            raise BaseException("timed out")

    # ------------------------------------------------------------------------------
    # Public Functions
    # ------------------------------------------------------------------------------

    def producer(self, ssig):
        """Constantly ask for user input."""
        # https://stackoverflow.com/questions/1450393/#38670261
        # while True: line = sys.stdin.readline() <- reads a whole line (faster)
        # for line in sys.stdin.readlin():        <- reads one byte at a time
        while True:
            if ssig.has_stop():
                self.log.trace("Stop signal acknowledged for reading STDIN-1")
                return
            try:
                # TODO: select() does not work for windows on stdin/stdout
                if os.name != "nt":
                    self.__set_input_timeout()
                line = sys.stdin.readline()
            except BaseException:
                # When using select() with timeout, we don't have any input
                # at this point and simply continue the loop or quit if
                # a terminate request has been made by other threads.
                if ssig.has_stop():
                    self.log.trace("Stop signal acknowledged for reading STDIN-2")
                    return
                # TODO: Re-enable this for very verbose logging
                # self.log.trace("STDIN: timeout. Waiting for input...")
                continue
            if line:
                self.log.debug("Received {} bytes from STDIN".format(len(line)))
                self.log.trace("Received: {}".format(repr(line)))
                yield self.__use_linefeeds(line)
            # EOF or <Ctrl>+<d>
            else:
                # DO NOT RETURN HERE BLINDLY, THE UPSTREAM CONNECTION MUST GO FIRST!
                if ssig.has_stop():
                    self.log.trace("Stop signal acknowledged for reading STDIN-3")
                    return
                # TODO: Re-enable this for very verbose logging
                # self.log.trace("STDIN: Reached EOF, repeating")

    def consumer(self, data):
        """Print received data to stdout."""
        print(data, end="")
        sys.stdout.flush()  # TODO:Is this required? What does this do? Test this!

    def interrupt(self):
        """Empty interrupt."""
        pass
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pwncat.NetcatPluginOutput">NetcatPluginOutput</a></li>
          <li><a href="#pwncat.AbstractNetcatPlugin">AbstractNetcatPlugin</a></li>
          <li><a href="#pwncat.ABC">ABC</a></li>
          <li><a href="/builtins.object.ext">builtins.object</a></li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="pwncat.NetcatPluginOutput.crlf" class="name">var <span class="ident">crlf</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatPluginOutput.input_timeout" class="name">var <span class="ident">input_timeout</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatPluginOutput.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, options={})</p>
    </div>
    

    
  
    <div class="desc"><p>Set specific options for this plugin.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatPluginOutput.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatPluginOutput.__init__" class="source">
    <pre><code>def __init__(self, options={}):
    """Set specific options for this plugin."""
    super(AbstractNetcatPlugin, self).__init__()
    assert "encoder" in options
    assert "input_timeout" in options
    assert "crlf" in options
    self.log = logging.getLogger(__name__)
    self.enc = options["encoder"]
    if "input_timeout" in options:
        self.input_timeout = options["input_timeout"]
    if "crlf" in options:
        self.crlf = options["crlf"]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatPluginOutput.consumer">
    <p>def <span class="ident">consumer</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>Print received data to stdout.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatPluginOutput.consumer', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatPluginOutput.consumer" class="source">
    <pre><code>def consumer(self, data):
    """Print received data to stdout."""
    print(data, end="")
    sys.stdout.flush()  # TODO:Is this required? What does this do? Test this!
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatPluginOutput.interrupt">
    <p>def <span class="ident">interrupt</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Empty interrupt.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatPluginOutput.interrupt', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatPluginOutput.interrupt" class="source">
    <pre><code>def interrupt(self):
    """Empty interrupt."""
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatPluginOutput.producer">
    <p>def <span class="ident">producer</span>(</p><p>self, ssig)</p>
    </div>
    

    
  
    <div class="desc"><p>Constantly ask for user input.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatPluginOutput.producer', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatPluginOutput.producer" class="source">
    <pre><code>def producer(self, ssig):
    """Constantly ask for user input."""
    # https://stackoverflow.com/questions/1450393/#38670261
    # while True: line = sys.stdin.readline() <- reads a whole line (faster)
    # for line in sys.stdin.readlin():        <- reads one byte at a time
    while True:
        if ssig.has_stop():
            self.log.trace("Stop signal acknowledged for reading STDIN-1")
            return
        try:
            # TODO: select() does not work for windows on stdin/stdout
            if os.name != "nt":
                self.__set_input_timeout()
            line = sys.stdin.readline()
        except BaseException:
            # When using select() with timeout, we don't have any input
            # at this point and simply continue the loop or quit if
            # a terminate request has been made by other threads.
            if ssig.has_stop():
                self.log.trace("Stop signal acknowledged for reading STDIN-2")
                return
            # TODO: Re-enable this for very verbose logging
            # self.log.trace("STDIN: timeout. Waiting for input...")
            continue
        if line:
            self.log.debug("Received {} bytes from STDIN".format(len(line)))
            self.log.trace("Received: {}".format(repr(line)))
            yield self.__use_linefeeds(line)
        # EOF or <Ctrl>+<d>
        else:
            # DO NOT RETURN HERE BLINDLY, THE UPSTREAM CONNECTION MUST GO FIRST!
            if ssig.has_stop():
                self.log.trace("Stop signal acknowledged for reading STDIN-3")
                return
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pwncat.NetcatPluginOutput.enc" class="name">var <span class="ident">enc</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatPluginOutput.log" class="name">var <span class="ident">log</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="pwncat.NetcatServer" class="name">class <span class="ident">NetcatServer</span></p>
      
  
    <div class="desc"><p>Netcat Server implementation.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatServer', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatServer" class="source">
    <pre><code>class NetcatServer(AbstractSocket):
    """Netcat Server implementation."""

    def __init__(self, encoder, host, port, recv_timeout, recv_timeout_retry, options={}):
        """Construct a listening server."""
        super(NetcatServer, self).__init__(
            encoder, "server", recv_timeout, recv_timeout_retry, options
        )

        # Listen on 0.0.0.0 by default
        addr = "0.0.0.0"
        if host is not None:
            addr = self.gethostbyname(host, port, socket.AF_INET)

        # Setup server
        self.create_socket()
        self.bind(addr, port)
        if self.options["udp"]:
            self.conn = self.sock
            self.log.info(
                "Listening on {} (family {}/UDP, port {})".format(addr, socket.AF_INET, port)
            )
        else:
            self.listen()
            self.log.info(
                "Listening on {} (family {}/TCP, port {})".format(addr, socket.AF_INET, port)
            )
            self.accept()
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pwncat.NetcatServer">NetcatServer</a></li>
          <li><a href="#pwncat.AbstractSocket">AbstractSocket</a></li>
          <li><a href="/builtins.object.ext">builtins.object</a></li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="pwncat.NetcatServer.conn" class="name">var <span class="ident">conn</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatServer.options" class="name">var <span class="ident">options</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatServer.recv_timeout" class="name">var <span class="ident">recv_timeout</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatServer.recv_timeout_retry" class="name">var <span class="ident">recv_timeout_retry</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatServer.remote_addr" class="name">var <span class="ident">remote_addr</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatServer.remote_port" class="name">var <span class="ident">remote_port</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatServer.role" class="name">var <span class="ident">role</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatServer.sock" class="name">var <span class="ident">sock</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatServer.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, encoder, host, port, recv_timeout, recv_timeout_retry, options={})</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#pwncat.AbstractSocket">AbstractSocket</a></code>.<code><a href="#pwncat.AbstractSocket.__init__">__init__</a></code>
    </p>

    
  
    <div class="desc"><p>Construct a listening server.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatServer.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatServer.__init__" class="source">
    <pre><code>def __init__(self, encoder, host, port, recv_timeout, recv_timeout_retry, options={}):
    """Construct a listening server."""
    super(NetcatServer, self).__init__(
        encoder, "server", recv_timeout, recv_timeout_retry, options
    )
    # Listen on 0.0.0.0 by default
    addr = "0.0.0.0"
    if host is not None:
        addr = self.gethostbyname(host, port, socket.AF_INET)
    # Setup server
    self.create_socket()
    self.bind(addr, port)
    if self.options["udp"]:
        self.conn = self.sock
        self.log.info(
            "Listening on {} (family {}/UDP, port {})".format(addr, socket.AF_INET, port)
        )
    else:
        self.listen()
        self.log.info(
            "Listening on {} (family {}/TCP, port {})".format(addr, socket.AF_INET, port)
        )
        self.accept()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatServer.accept">
    <p>def <span class="ident">accept</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Accept a connection.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatServer.accept', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatServer.accept" class="source">
    <pre><code>def accept(self):
    """Accept a connection."""
    try:
        self.log.debug("Waiting for TCP client")
        self.conn, client = self.sock.accept()
        addr, port = client
        self.remote_addr = addr
        self.remote_port = port
        self.log.info("Client connected from {}:{}".format(addr, port))
    except (socket.gaierror, socket.error) as error:
        self.log.error("Accept failed: {}".format(error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatServer.bind">
    <p>def <span class="ident">bind</span>(</p><p>self, addr, port)</p>
    </div>
    

    
  
    <div class="desc"><p>Bind the socket to an address.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatServer.bind', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatServer.bind" class="source">
    <pre><code>def bind(self, addr, port):
    """Bind the socket to an address."""
    try:
        self.log.debug("Binding socket to {}:{}".format(addr, port))
        self.sock.bind((addr, port))
    except (OverflowError, OSError, socket.error) as error:
        self.log.error("Binding socket to {}:{} failed: {}".format(addr, port, error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatServer.connect">
    <p>def <span class="ident">connect</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Connect to a remote socket at given address and port (TCP-only).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatServer.connect', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatServer.connect" class="source">
    <pre><code>def connect(self):
    """Connect to a remote socket at given address and port (TCP-only)."""
    try:
        self.log.debug("Connecting to {}:{}".format(self.remote_addr, self.remote_port))
        self.sock.connect((self.remote_addr, self.remote_port))
        return True
    except socket.error as error:
        self.log.error(
            "Connecting to {}:{} failed: {}".format(self.remote_addr, self.remote_port, error)
        )
        return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatServer.create_socket">
    <p>def <span class="ident">create_socket</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Create TCP or UDP socket.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatServer.create_socket', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatServer.create_socket" class="source">
    <pre><code>def create_socket(self):
    """Create TCP or UDP socket."""
    try:
        if self.options["udp"]:
            self.log.debug("Creating UDP socket")
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        else:
            self.log.debug("Creating TCP socket")
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    except socket.error as error:
        self.log.error("Failed to create the socket: {}".format(error))
        sys.exit(1)
    # Get around the "[Errno 98] Address already in use" error, if the socket is still in wait
    # we instruct it to reuse the address anyway.
    self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatServer.gethostbyname">
    <p>def <span class="ident">gethostbyname</span>(</p><p>self, host, port, family)</p>
    </div>
    

    
  
    <div class="desc"><p>Translate hostname into IP address.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatServer.gethostbyname', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatServer.gethostbyname" class="source">
    <pre><code>def gethostbyname(self, host, port, family):
    """Translate hostname into IP address."""
    socktype = socket.SOCK_DGRAM if self.options["udp"] else socket.SOCK_STREAM
    flags = 0
    if self.options["nodns"]:
        flags = socket.AI_NUMERICHOST
    try:
        self.log.debug("Resolving hostname: {}".format(host))
        (family, socktype, proto, canonname, sockaddr) = socket.getaddrinfo(
            host, port, socket.AF_INET, socktype, flags
        )[0]
    except socket.gaierror as error:
        self.log.error("Resolve Error: {}".format(error))
        sys.exit(1)
    self.log.debug("Resolved hostname:  {}".format(sockaddr[0]))
    return sockaddr[0]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatServer.listen">
    <p>def <span class="ident">listen</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Listen for connections made to the socket.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatServer.listen', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatServer.listen" class="source">
    <pre><code>def listen(self):
    """Listen for connections made to the socket."""
    try:
        self.log.debug("Listening with backlog={}".format(self.options["backlog"]))
        self.sock.listen(self.options["backlog"])
    except socket.error as error:
        self.log.error("Listening failed: {}".format(error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatServer.receive">
    <p>def <span class="ident">receive</span>(</p><p>self, ssig)</p>
    </div>
    

    
  
    <div class="desc"><p>Generator function to receive data endlessly by yielding it.</p>
<p>:param function interrupter: A Func that returns True/False to tell us to stop or not.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatServer.receive', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatServer.receive" class="source">
    <pre><code>def receive(self, ssig):
    """
    Generator function to receive data endlessly by yielding it.
    :param function interrupter: A Func that returns True/False to tell us to stop or not.
    """
    # Set current receive timeout
    self.conn.settimeout(self.recv_timeout)
    self.log.trace("Socket Timeout: {}".format(self.recv_timeout))
    # Counts how many times we had a ready timeout for later to decide
    # if we exceeded maximum retires
    curr_recv_timeout_retry = 0
    while True:
        # Ensure to signal that we do not stop receiving data
        # if ssig.has_stop():
        #    self.log.debug("Interrupt has been requested for receive()")
        #    return
        if self.conn is None:
            self.log.error("Exit. Socket is gone in receive()")
            ssig.raise_stop()
            return
        # Non-blocking socket with timeout. If the timeout threshold is hit,
        # it will throw an socket.timeout exception. This is required to see if other
        # threads have been terminated already.
        try:
            # https://manpages.debian.org/buster/manpages-dev/recv.2.en.html
            (byte, addr) = self.conn.recvfrom(self.options["bufsize"])
        # [1/5] Finished receiving all data
        # NOTE: This is the place where we can do any checks in between reads as the
        # socket has been changed from blocking to time-out based.
        # NOTE: This is also the place, where we quit in case --wait was specified.
        except socket.timeout:
            # Let's ask the interrupter() function if we should terminate?
            if not ssig.has_stop():
                # No action required, continue the loop and read again.
                continue
            self.log.debug("Interrupt has been requested for receive()")
            # Other threads are done. Let's try to read a few more times before
            # returning and ending this function (might be data left)
            if curr_recv_timeout_retry < self.recv_timeout_retry:
                self.log.trace(
                    "Final socket read: {}/{} before quitting.".format(
                        curr_recv_timeout_retry, self.recv_timeout_retry
                    )
                )
                curr_recv_timeout_retry += 1
                continue
            ssig.raise_stop()
            return
        # [2/5] Connection was forcibly closed
        # [Errno 10054] An existing connection was forcibly closed by the remote host
        # [WinError 10054] An existing connection was forcibly closed by the remote host
        # So we will just warn (instead of error our), ignore (don't return here) and
        # let the bottom of this function decide whether we should just quit or
        # reconnect/bind (if the user specified this.
        except socket.error as error:
            # Also ensure we reset the 'byte' value to none so that the below check can kick in.
            byte = None
            self.log.warning("Socket Receive: {}".format(error))
        # [3/5] TODO: Still need to figure out what this error is and when it is thrown
        except AttributeError as error:
            self.log.error("TODO: What happens here?Attribute Receive Error: {}".format(error))
            ssig.raise_stop()
            return
        # We're receiving data again, so let's reset the retry/terminate counter
        # The counter is incremented in 'except socket.timeout' above.
        curr_recv_timeout_retry = 0
        # If we're receiving data from a UDP client
        # we can firstly/finally set its addr/port in order
        # to send data back to it (see send() function)
        if self.options["udp"]:
            self.remote_addr, self.remote_port = addr
            self.log.debug("Client connected: {}:{}".format(self.remote_addr, self.remote_port))
        # [4/5] Upstream (server or client) is gone. Do we reconnect or quit?
        if not byte:
            self.log.trace("Socket: Empty data received or otherwise caught.")
            if self.role == "server":
                # Yay, we want to continue and allow new clients
                if self.__reaccept_from_client():
                    self.log.trace("Server can continue, because of --keep-open")
                    continue
            if self.role == "client":
                # Yay, we want to continue and our client will re-connect upstream again
                if self.__reconnect_to_server():
                    self.log.trace("Client can continue, because of --reconn")
                    continue
            self.log.warning("Exit. Upstream connection gone. No --keep-open/--reconn set.")
            ssig.raise_stop()
            return
        # [5/5] We have data to process
        data = self.enc.decode(byte)
        self.log.debug(
            "Received {} bytes from {}:{}".format(len(data), self.remote_addr, self.remote_port)
        )
        self.log.trace("Received: {}".format(repr(data)))
        yield data
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatServer.send">
    <p>def <span class="ident">send</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>Send data.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatServer.send', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatServer.send" class="source">
    <pre><code>def send(self, data):
    """Send data."""
    # In case of sending data back to an udp client we need to wait
    # until the client has first connected and told us its addr/port
    if self.options["udp"] and self.remote_addr is None and self.remote_port is None:
        self.log.warning("UDP client has not yet connected. Queueing message")
        while self.remote_addr is None and self.remote_port is None:
            time.sleep(0.1)  # Less wastefull than using 'pass'
    curr = 0  # bytes send during one loop iteration
    send = 0  # total bytes send
    size = len(data)  # bytes of data that needs to be send
    data = self.enc.encode(data)
    assert size == len(data), "Encoding messed up string length, might need to do len() after."
    # Loop until all bytes have been send
    while send < size:
        try:
            self.log.debug(
                "Trying to send {} bytes to {}:{}".format(
                    size - send, self.remote_addr, self.remote_port
                )
            )
            self.log.trace("Trying to send: {}".format(repr(data)))
            if self.options["udp"]:
                curr = self.conn.sendto(data, (self.remote_addr, self.remote_port))
                send += curr
            else:
                curr = self.conn.send(data)
                send += curr
            if curr == 0:
                self.log.error("No bytes send during loop round.")
                return
            # Remove 'curr' many bytes from data for the next round
            data = data[curr:]
            self.log.debug(
                "Sent {} bytes to {}:{} ({} bytes remaining)".format(
                    curr, self.remote_addr, self.remote_port, size - send
                )
            )
        except socket.error as error:
            if error.errno == socket.errno.EPIPE:
                self.log.error("TODO:Add desc. Socket error({}): {}".format(error.errno, error))
                return
            # Most likely nothing to see here??
            # FIXME: TODO: Need to re-accepd new client
            self.log.error("TODO:Add desc. Socket Error: {}".format(error))
            if self.role == "server":
                if self.__reaccept_from_client():
                    continue
            self.log.warning("Shutdown")
            return
        except (OSError) as error:
            self.log.error("Socket OS Error: {}".format(error))
            return
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="pwncat.Runner" class="name">class <span class="ident">Runner</span></p>
      
  
    <div class="desc"><p>Runner class that takes care about putting everything into threads.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.Runner', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.Runner" class="source">
    <pre><code>class Runner(object):
    """Runner class that takes care about putting everything into threads."""

    # Dict of producer/consumer action to run in a Thread.
    # Each list item will be run in a single thread
    # {
    #   "name": {
    #     {
    #       "producer": "function",     # A func which yields data
    #       "consumer": "function",     # A callback func to process the data
    #       "interrupter": "function",  # A interrupt func to tell the producer to stop
    #   }
    # }
    __actions = {}
    __timers = {}

    # A dict which holds the threads created from actions.
    # The name is based on the __actions name
    # {"name": "<thread>"}
    __threads = {}

    # ------------------------------------------------------------------------------
    # Constructor / Destructor
    # ------------------------------------------------------------------------------
    def __init__(self):
        """Constructor."""
        self.log = logging.getLogger(__name__)

    # ------------------------------------------------------------------------------
    # Public Functions
    # ------------------------------------------------------------------------------
    def add_action(self, action):
        """
        Enables a function to run threaded by the producer/consumer runner.

        :param str      name:        Name for logging output
        :param function producer:    A generator function which yields data
        :param function consumer:    A callback which consumes data from the generator
        :param function interrupter: A func that signals a stop event to the producer
        """
        assert "name" in action
        assert "producer" in action
        assert "consumer" in action
        assert "signal" in action
        assert "interrupt" in action
        self.__actions[action["name"]] = {
            "name": action["name"],
            "producer": action["producer"],
            "consumer": action["consumer"],
            "signal": action["signal"],
            "interrupt": action["interrupt"],
        }

    def add_timer(self, timer):
        self.__timers[timer["name"]] = {
            "action": timer["action"],
            "intvl": timer["intvl"],
            "args": timer["args"] if "args" in timer else None,
            "kwargs": timer["kwargs"] if "kwargs" in timer else {},
            "signal": timer["signal"],
        }

    def run(self):
        """Run threaded NetCat."""

        def run_action(name, producer, consumer, ssig):
            """
            Receive data (network, user-input, shell-output) and process it (send, output).

            :param str        name:        Name for logging output
            :param function   producer:    A generator function which yields data
            :param function   consumer:    A callback which consumes data from the generator
            :param StopSignal ssig:        Providing has_stop() and raise_stop()
            """
            self.log.trace("[{}] Producer Start".format(name))
            for data in producer(ssig):
                self.log.trace("[{}] Producer received: {}".format(name, repr(data)))
                consumer(data)
            self.log.trace("[{}] Producer Stop".format(name))

        def run_timer(name, action, intvl, ssig, *args, **kwargs):
            """Execute periodic tasks by an optional provided time_action."""
            self.log.trace("[{}] Timer Start (exec every {} sec)".format(name, intvl))
            time_last = int(time.time())
            while True:
                if ssig.has_stop():
                    self.log.trace("Stop signal acknowledged for timer {}".format(name))
                    return
                time_now = int(time.time())
                if time_now > time_last + intvl:
                    self.log.debug("[{}] Executing timed function".format(time_now))
                    if args is not None:
                        if kwargs:
                            action(*args, **kwargs)
                        else:
                            action(*args)
                    else:
                        if kwargs:
                            action(**kwargs)
                        else:
                            action()
                    time_last = time_now  # Reset previous time
                time.sleep(1)

        # Start available action in a thread
        for key in self.__actions:
            # Create Thread object
            thread = threading.Thread(
                target=run_action,
                name=key,
                args=(
                    key,
                    self.__actions[key]["producer"],
                    self.__actions[key]["consumer"],
                    self.__actions[key]["signal"],
                ),
            )
            thread.daemon = False
            thread.start()
            self.__threads[key] = thread
        # Start available timers in a thread
        for key in self.__timers:
            # Create Thread object
            thread = threading.Thread(
                target=run_timer,
                name=key,
                args=(
                    key,
                    self.__timers[key]["action"],
                    self.__timers[key]["intvl"],
                    self.__timers[key]["signal"],
                    self.__timers[key]["args"],
                ),
                kwargs=self.__timers[key]["kwargs"],
            )
            thread.daemon = False
            thread.start()

        def stop(force):
            """Stop threads."""
            for key in self.__threads:
                if not self.__threads[key].is_alive() or force:
                    self.log.trace("Raise stop signal for {}".format(self.__threads[key].getName()))
                    self.__actions[key]["signal"].raise_stop()
                    self.log.trace("Call interrupt for {}".format(self.__threads[key].getName()))
                    self.__actions[key]["interrupt"]()
                    self.log.trace("Joining {}".format(self.__threads[key].getName()))
                    self.__threads[key].join(timeout=0.1)
            # If all threads have died, exit
            if not all([self.__threads[key].is_alive() for key in self.__threads]) or force:
                if force:
                    sys.exit(1)
                else:
                    sys.exit(0)

        try:
            while True:
                stop(False)
                # Need a timeout to not skyrocket the CPU
                time.sleep(0.1)
        except KeyboardInterrupt:
            print()
            stop(True)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pwncat.Runner">Runner</a></li>
          <li><a href="/builtins.object.ext">builtins.object</a></li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pwncat.Runner.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Constructor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.Runner.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.Runner.__init__" class="source">
    <pre><code>def __init__(self):
    """Constructor."""
    self.log = logging.getLogger(__name__)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.Runner.add_action">
    <p>def <span class="ident">add_action</span>(</p><p>self, action)</p>
    </div>
    

    
  
    <div class="desc"><p>Enables a function to run threaded by the producer/consumer runner.</p>
<p>:param str      name:        Name for logging output
:param function producer:    A generator function which yields data
:param function consumer:    A callback which consumes data from the generator
:param function interrupter: A func that signals a stop event to the producer</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.Runner.add_action', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.Runner.add_action" class="source">
    <pre><code>def add_action(self, action):
    """
    Enables a function to run threaded by the producer/consumer runner.
    :param str      name:        Name for logging output
    :param function producer:    A generator function which yields data
    :param function consumer:    A callback which consumes data from the generator
    :param function interrupter: A func that signals a stop event to the producer
    """
    assert "name" in action
    assert "producer" in action
    assert "consumer" in action
    assert "signal" in action
    assert "interrupt" in action
    self.__actions[action["name"]] = {
        "name": action["name"],
        "producer": action["producer"],
        "consumer": action["consumer"],
        "signal": action["signal"],
        "interrupt": action["interrupt"],
    }
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.Runner.add_timer">
    <p>def <span class="ident">add_timer</span>(</p><p>self, timer)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.Runner.add_timer', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.Runner.add_timer" class="source">
    <pre><code>def add_timer(self, timer):
    self.__timers[timer["name"]] = {
        "action": timer["action"],
        "intvl": timer["intvl"],
        "args": timer["args"] if "args" in timer else None,
        "kwargs": timer["kwargs"] if "kwargs" in timer else {},
        "signal": timer["signal"],
    }
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.Runner.run">
    <p>def <span class="ident">run</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Run threaded NetCat.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.Runner.run', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.Runner.run" class="source">
    <pre><code>def run(self):
    """Run threaded NetCat."""
    def run_action(name, producer, consumer, ssig):
        """
        Receive data (network, user-input, shell-output) and process it (send, output).
        :param str        name:        Name for logging output
        :param function   producer:    A generator function which yields data
        :param function   consumer:    A callback which consumes data from the generator
        :param StopSignal ssig:        Providing has_stop() and raise_stop()
        """
        self.log.trace("[{}] Producer Start".format(name))
        for data in producer(ssig):
            self.log.trace("[{}] Producer received: {}".format(name, repr(data)))
            consumer(data)
        self.log.trace("[{}] Producer Stop".format(name))
    def run_timer(name, action, intvl, ssig, *args, **kwargs):
        """Execute periodic tasks by an optional provided time_action."""
        self.log.trace("[{}] Timer Start (exec every {} sec)".format(name, intvl))
        time_last = int(time.time())
        while True:
            if ssig.has_stop():
                self.log.trace("Stop signal acknowledged for timer {}".format(name))
                return
            time_now = int(time.time())
            if time_now > time_last + intvl:
                self.log.debug("[{}] Executing timed function".format(time_now))
                if args is not None:
                    if kwargs:
                        action(*args, **kwargs)
                    else:
                        action(*args)
                else:
                    if kwargs:
                        action(**kwargs)
                    else:
                        action()
                time_last = time_now  # Reset previous time
            time.sleep(1)
    # Start available action in a thread
    for key in self.__actions:
        # Create Thread object
        thread = threading.Thread(
            target=run_action,
            name=key,
            args=(
                key,
                self.__actions[key]["producer"],
                self.__actions[key]["consumer"],
                self.__actions[key]["signal"],
            ),
        )
        thread.daemon = False
        thread.start()
        self.__threads[key] = thread
    # Start available timers in a thread
    for key in self.__timers:
        # Create Thread object
        thread = threading.Thread(
            target=run_timer,
            name=key,
            args=(
                key,
                self.__timers[key]["action"],
                self.__timers[key]["intvl"],
                self.__timers[key]["signal"],
                self.__timers[key]["args"],
            ),
            kwargs=self.__timers[key]["kwargs"],
        )
        thread.daemon = False
        thread.start()
    def stop(force):
        """Stop threads."""
        for key in self.__threads:
            if not self.__threads[key].is_alive() or force:
                self.log.trace("Raise stop signal for {}".format(self.__threads[key].getName()))
                self.__actions[key]["signal"].raise_stop()
                self.log.trace("Call interrupt for {}".format(self.__threads[key].getName()))
                self.__actions[key]["interrupt"]()
                self.log.trace("Joining {}".format(self.__threads[key].getName()))
                self.__threads[key].join(timeout=0.1)
        # If all threads have died, exit
        if not all([self.__threads[key].is_alive() for key in self.__threads]) or force:
            if force:
                sys.exit(1)
            else:
                sys.exit(0)
    try:
        while True:
            stop(False)
            # Need a timeout to not skyrocket the CPU
            time.sleep(0.1)
    except KeyboardInterrupt:
        print()
        stop(True)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pwncat.Runner.log" class="name">var <span class="ident">log</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="pwncat.StopSignal" class="name">class <span class="ident">StopSignal</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.StopSignal', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.StopSignal" class="source">
    <pre><code>class StopSignal(object):

    __stop = False

    def has_stop(self):
        return self.__stop

    def raise_stop(self):
        self.__stop = True
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pwncat.StopSignal">StopSignal</a></li>
          <li><a href="/builtins.object.ext">builtins.object</a></li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pwncat.StopSignal.has_stop">
    <p>def <span class="ident">has_stop</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.StopSignal.has_stop', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.StopSignal.has_stop" class="source">
    <pre><code>def has_stop(self):
    return self.__stop
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.StopSignal.raise_stop">
    <p>def <span class="ident">raise_stop</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.StopSignal.raise_stop', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.StopSignal.raise_stop" class="source">
    <pre><code>def raise_stop(self):
    self.__stop = True
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="pwncat.StringEncoder" class="name">class <span class="ident">StringEncoder</span></p>
      
  
    <div class="desc"><p>Takes care about Python 2/3 string encoding/decoding.</p>
<p>This allows to parse all string/byte values internally between all
classes or functions as strings to keep full Python 2/3 compat.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.StringEncoder', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.StringEncoder" class="source">
    <pre><code>class StringEncoder(object):
    """
    Takes care about Python 2/3 string encoding/decoding.

    This allows to parse all string/byte values internally between all
    classes or functions as strings to keep full Python 2/3 compat.
    """

    # https://stackoverflow.com/questions/606191/27527728#27527728
    codec = "cp437"

    def __init__(self):
        self.py3 = sys.version_info >= (3, 0)

    def encode(self, data):
        """Convert string into a byte type for Python3."""
        if self.py3:
            data = data.encode(self.codec)
        return data

    def decode(self, data):
        """Convert bytes into a string type for Python3."""
        if self.py3:
            data = data.decode(self.codec)
        return data
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pwncat.StringEncoder">StringEncoder</a></li>
          <li><a href="/builtins.object.ext">builtins.object</a></li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="pwncat.StringEncoder.codec" class="name">var <span class="ident">codec</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pwncat.StringEncoder.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.StringEncoder.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.StringEncoder.__init__" class="source">
    <pre><code>def __init__(self):
    self.py3 = sys.version_info >= (3, 0)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.StringEncoder.decode">
    <p>def <span class="ident">decode</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>Convert bytes into a string type for Python3.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.StringEncoder.decode', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.StringEncoder.decode" class="source">
    <pre><code>def decode(self, data):
    """Convert bytes into a string type for Python3."""
    if self.py3:
        data = data.decode(self.codec)
    return data
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.StringEncoder.encode">
    <p>def <span class="ident">encode</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>Convert string into a byte type for Python3.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.StringEncoder.encode', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.StringEncoder.encode" class="source">
    <pre><code>def encode(self, data):
    """Convert string into a byte type for Python3."""
    if self.py3:
        data = data.encode(self.codec)
    return data
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pwncat.StringEncoder.py3" class="name">var <span class="ident">py3</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
