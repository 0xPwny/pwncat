<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>pwncat API documentation</title>
    <meta name="description" content="Python netcat implementation." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#pwncat.APPNAME">APPNAME</a></li>
    <li class="mono"><a href="#pwncat.APPREPO">APPREPO</a></li>
    <li class="mono"><a href="#pwncat.LOGLEVEL_TRACE_NUM">LOGLEVEL_TRACE_NUM</a></li>
    <li class="mono"><a href="#pwncat.PIPE">PIPE</a></li>
    <li class="mono"><a href="#pwncat.THREAD_TERMINATE">THREAD_TERMINATE</a></li>
    <li class="mono"><a href="#pwncat.TIMEOUT_READ_STDIN">TIMEOUT_READ_STDIN</a></li>
    <li class="mono"><a href="#pwncat.TIMEOUT_RECV_SOCKET">TIMEOUT_RECV_SOCKET</a></li>
    <li class="mono"><a href="#pwncat.TIMEOUT_RECV_SOCKET_RETRY">TIMEOUT_RECV_SOCKET_RETRY</a></li>
    <li class="mono"><a href="#pwncat.VERSION">VERSION</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#pwncat.get_args">get_args</a></li>
    <li class="mono"><a href="#pwncat.get_version">get_version</a></li>
    <li class="mono"><a href="#pwncat.logtrace">logtrace</a></li>
    <li class="mono"><a href="#pwncat.main">main</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#pwncat.ABC">ABC</a></span>
        
        </li>
        <li class="mono">
        <span class="class_name"><a href="#pwncat.AbstractNetcatPlugin">AbstractNetcatPlugin</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pwncat.AbstractNetcatPlugin.__init__">__init__</a></li>
    <li class="mono"><a href="#pwncat.AbstractNetcatPlugin.input_generator">input_generator</a></li>
    <li class="mono"><a href="#pwncat.AbstractNetcatPlugin.output_callback">output_callback</a></li>
    <li class="mono"><a href="#pwncat.AbstractNetcatPlugin.stop">stop</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pwncat.AbstractSocket">AbstractSocket</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pwncat.AbstractSocket.__init__">__init__</a></li>
    <li class="mono"><a href="#pwncat.AbstractSocket.accept">accept</a></li>
    <li class="mono"><a href="#pwncat.AbstractSocket.bind">bind</a></li>
    <li class="mono"><a href="#pwncat.AbstractSocket.connect">connect</a></li>
    <li class="mono"><a href="#pwncat.AbstractSocket.create_socket">create_socket</a></li>
    <li class="mono"><a href="#pwncat.AbstractSocket.gethostbyname">gethostbyname</a></li>
    <li class="mono"><a href="#pwncat.AbstractSocket.listen">listen</a></li>
    <li class="mono"><a href="#pwncat.AbstractSocket.receive">receive</a></li>
    <li class="mono"><a href="#pwncat.AbstractSocket.send">send</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pwncat.NetcatClient">NetcatClient</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pwncat.NetcatClient.__init__">__init__</a></li>
    <li class="mono"><a href="#pwncat.NetcatClient.accept">accept</a></li>
    <li class="mono"><a href="#pwncat.NetcatClient.bind">bind</a></li>
    <li class="mono"><a href="#pwncat.NetcatClient.connect">connect</a></li>
    <li class="mono"><a href="#pwncat.NetcatClient.create_socket">create_socket</a></li>
    <li class="mono"><a href="#pwncat.NetcatClient.gethostbyname">gethostbyname</a></li>
    <li class="mono"><a href="#pwncat.NetcatClient.listen">listen</a></li>
    <li class="mono"><a href="#pwncat.NetcatClient.receive">receive</a></li>
    <li class="mono"><a href="#pwncat.NetcatClient.send">send</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pwncat.NetcatPluginCommand">NetcatPluginCommand</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pwncat.NetcatPluginCommand.__init__">__init__</a></li>
    <li class="mono"><a href="#pwncat.NetcatPluginCommand.input_generator">input_generator</a></li>
    <li class="mono"><a href="#pwncat.NetcatPluginCommand.output_callback">output_callback</a></li>
    <li class="mono"><a href="#pwncat.NetcatPluginCommand.stop">stop</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pwncat.NetcatPluginOutput">NetcatPluginOutput</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pwncat.NetcatPluginOutput.__init__">__init__</a></li>
    <li class="mono"><a href="#pwncat.NetcatPluginOutput.input_generator">input_generator</a></li>
    <li class="mono"><a href="#pwncat.NetcatPluginOutput.output_callback">output_callback</a></li>
    <li class="mono"><a href="#pwncat.NetcatPluginOutput.stop">stop</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pwncat.NetcatServer">NetcatServer</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pwncat.NetcatServer.__init__">__init__</a></li>
    <li class="mono"><a href="#pwncat.NetcatServer.accept">accept</a></li>
    <li class="mono"><a href="#pwncat.NetcatServer.bind">bind</a></li>
    <li class="mono"><a href="#pwncat.NetcatServer.connect">connect</a></li>
    <li class="mono"><a href="#pwncat.NetcatServer.create_socket">create_socket</a></li>
    <li class="mono"><a href="#pwncat.NetcatServer.gethostbyname">gethostbyname</a></li>
    <li class="mono"><a href="#pwncat.NetcatServer.listen">listen</a></li>
    <li class="mono"><a href="#pwncat.NetcatServer.receive">receive</a></li>
    <li class="mono"><a href="#pwncat.NetcatServer.send">send</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pwncat.Runner">Runner</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pwncat.Runner.__init__">__init__</a></li>
    <li class="mono"><a href="#pwncat.Runner.run">run</a></li>
    <li class="mono"><a href="#pwncat.Runner.set_input_generator">set_input_generator</a></li>
    <li class="mono"><a href="#pwncat.Runner.set_input_generator_stop_function">set_input_generator_stop_function</a></li>
    <li class="mono"><a href="#pwncat.Runner.set_output_callback">set_output_callback</a></li>
    <li class="mono"><a href="#pwncat.Runner.set_recv_generator">set_recv_generator</a></li>
    <li class="mono"><a href="#pwncat.Runner.set_revc_generator_stop_function">set_revc_generator_stop_function</a></li>
    <li class="mono"><a href="#pwncat.Runner.set_send_callback">set_send_callback</a></li>
    <li class="mono"><a href="#pwncat.Runner.set_timed_action">set_timed_action</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pwncat.StringEncoder">StringEncoder</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pwncat.StringEncoder.__init__">__init__</a></li>
    <li class="mono"><a href="#pwncat.StringEncoder.decode">decode</a></li>
    <li class="mono"><a href="#pwncat.StringEncoder.encode">encode</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">pwncat</span> module</h1>
  <p>Python netcat implementation.</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat', this);">Show source &equiv;</a></p>
  <div id="source-pwncat" class="source">
    <pre><code>#!/usr/bin/env python3
"""Python netcat implementation."""

#
# TODO: where to use sys.stdout.flush ??
#
# Behaviour Server
# 1. (tty and non-tty mode) TCP Server should always quit if client disconnects
# 2. (tty and non-tty mode) TCP Server should always quit if connection is gone/broken
# 3. (tty and non-tty mode) UDP Will always stay open (can't determine if connection is gone)
#
#
# Behaviour Client
# 1. (tty and non-tty mode) Client will always stay open until manually quit
##

from __future__ import print_function
from abc import ABCMeta, abstractmethod
from subprocess import Popen, PIPE
import argparse
import atexit
import logging
import os
import re
import socket
import subprocess
import sys
import threading
import time

# Python 2 + Python 3 support
ABC = ABCMeta("ABC", (object,), {"__slots__": ()})

# TODO: Find windows import
if os.name != "nt":
    import select

# -------------------------------------------------------------------------------------------------
# GLOBALS
# -------------------------------------------------------------------------------------------------

APPNAME = "pwncat"
APPREPO = "https://github.com/cytopia/pwncat"
VERSION = "0.0.5-alpha"

# Global variable to be used within threads to determine
# if they should exit or not.
# TODO: check if this is best-practice
THREAD_TERMINATE = False

# Custom loglevel numer for TRACE
LOGLEVEL_TRACE_NUM = 9

# Default timeout for timeout-based sys.stdin and socket.recv
TIMEOUT_READ_STDIN = 0.3
TIMEOUT_RECV_SOCKET = 0.3
TIMEOUT_RECV_SOCKET_RETRY = 1


# -------------------------------------------------------------------------------------------------
# ABSTRACT CLASS: AbstractNetcatPlugin
# -------------------------------------------------------------------------------------------------
class AbstractNetcatPlugin(ABC):
    """
    Abstract class to for netcat plugins.

    This is a skeleton that defines how the plugins for Netcat should look like.

    The "input_generator" should constantly yield data received from sort sort of input
    which could be user input, output from a shell command data from a socket.

    The "data_callback" will apply some sort of action on the data received from a data_generator
    which could be output to stdout, send it to the shell or to a socket.
    """

    __metaclass__ = ABCMeta

    @abstractmethod
    def __init__(self, encoder, options={}):
        """Set specific options for this plugin.
        Args:
            encoder (object): An instance which provides "encode" and "decode" for string/bytes.
            options (dict):   Custom dictionary of options.
        """
        pass

    @abstractmethod
    def input_generator(self):
        """Implement a generator function which constantly yields data from some input."""
        while False:
            yield None

    @abstractmethod
    def output_callback(self, data):
        """Implement a callback which processes the input into some output."""
        print(data)

    @abstractmethod
    def stop(self):
        """Implement a stop method, which exits the instance."""


# -------------------------------------------------------------------------------------------------
# ABSTRCT CLASS: AbstractSocket
# -------------------------------------------------------------------------------------------------
class AbstractSocket(object):
    """Abstract class which provides TCP, UDP and IPv4, IPv6 Socket funcionality."""

    sock = None  # server binding socket (until accept())
    conn = None  # client/server communication socket

    # The instance role must be 'server' or 'client' and
    # is used to determine how to reconnect broken connections.
    # Either listen again (tcp-only) or re-connect to upstream.
    role = None  # Must be 'server' or 'client'

    # Specify a float of seconds for the socket timeout.
    # A default of None means it is blocking.
    recv_timeout = None

    # If no data is received, the socket will timeout and counts subsequent timeouts
    # with no data received. If 'recv_timeout_retry' many timeouts occured, the socket
    # will stop reading data.
    # The internal counter is reset as soon as data is received again.
    recv_timeout_retry = 0

    options = {
        "bufsize": 1024,  # Receive buffer size
        "backlog": 0,  # Listen backlog
        "nodns": False,  # Do not resolve hostname
        "udp": False,  # Is TCP or UDP?
        "http": False,  # Use HTTP instead
        "https": False,  # Use HTTPS instead
        "keep_open": False,  # Keep server open for new connections
        "rebind": False,  # False (never), True (indefinite) or int for how many times to rebind
        "reconn": False,  # False (never), True (indefinite) or int for how many times to reconnect
        "rebind_wait": 0,  # Time in seconds between re-binds
        "reconn_wait": 0,  # Time in seconds between reconnects
        "rebind_robin": [],  # Ports to round-robind for bindings
        "reconn_robin": [],  # Ports to round-robin for reconnects
        "wait": False,  # Close client if it is idle for x many seconds
        "udp_ping_init": False,  # Send initial UDP ping packet
        "udp_ping_intvl": False,  # Interval in sec for UDP client to ping server
        "udp_ping_word": "\0",  # The char/string to send as UDP ping probe
        "udp_ping_robing": [],  # Ports to round-robing during UDP ping probes
        "safe_word": False,  # Once this is received, the application quits
    }

    # In case the server is running in UDP mode,
    # it must wait for the client to connect in order
    # to retrieve its addr and port in order to be able
    # to send data back to it.
    udp_client_addr = None
    udp_client_port = None

    # For client role only
    # Store the address and port of the remote server to connect to.
    # This is required for self.connect()
    remote_addr = None
    remote_addr = None

    # ------------------------------------------------------------------------------
    # Constructor / Destructor
    # ------------------------------------------------------------------------------
    def __init__(self, encoder, role, recv_timeout, recv_timeout_retry, options={}):
        """Constructor."""
        assert type(self) is not AbstractSocket, "AbstractSocket cannot be instantiated directly."
        assert role in ["server", "client"], "The role must be 'server' or 'client'."

        self.log = logging.getLogger(__name__)
        self.enc = encoder
        self.role = role

        self.recv_timeout = recv_timeout
        self.recv_timeout_retry = recv_timeout_retry

        # Ensure to provide all items (be explicit - currently helps to find bugs)
        for index in self.options:
            assert index in options, "Provided options are missing key: {}".format(index)
        # Ensure to only provide option itenms that are defined/exist (helps to find bugs)
        for index in options:
            assert index in self.options, "Provided an invalid option item"
            self.options[index] = options[index]

        # Register destructor
        atexit.register(self.__exit__)

    def __exit__(self):
        """Destructor."""

        self.log.trace("Closing 'sock' socket")
        self.__close_socket(self.sock)
        self.sock = None
        self.log.trace("Closing 'conn' socket")
        self.__close_socket(self.conn)
        self.conn = None

    # ------------------------------------------------------------------------------
    # Private Functions
    # ------------------------------------------------------------------------------
    def __close_socket(self, sock):
        """Close a socket."""
        try:
            # (SHUT_RD)   0 = Done receiving (disallows receiving)
            # (SHUT_WR)   1 = Done sending (disallows sending)
            # (SHUT_RDWR) 2 = Both
            sock.shutdown(socket.SHUT_RDWR)
        except (AttributeError, OSError, socket.error):
            self.log.trace("Could not shutdown socket")
            pass
        try:
            sock.close()
        except (AttributeError, OSError, socket.error):
            self.log.trace("Could not shutdown socket")

    def __reconnect(self):
        """Reconnect to a server if upstream has gone."""
        self.__close_socket(self.conn)
        self.__close_socket(self.sock)
        self.create_socket()
        self.conn = self.sock
        if not self.connect():
            self.__reconnect_to_server()

    def __reaccept_from_client(self):
        """Ensure the server is able to accept clients again, after current client has left."""
        # Only for server
        assert self.role == "server", "Only the role 'server' can accept connections."
        # Do not re-accept for UDP
        assert not self.options["udp"], "This should have been caught during arg check."

        # [NO] Never re-accept
        if type(self.options["reconn"]) is bool and not self.options["reconn"]:
            self.log.info("No automatic re-accept specified. Shutting down.")
            return False
        # [YES] Always re-accept indefinitely
        if type(self.options["reconn"]) is bool and self.options["reconn"]:
            self.log.info(
                "Re-accepting in {} sec (indefinitely)".format(self.options["reconn_wait"])
            )
            time.sleep(self.options["reconn_wait"])
            self.__close_socket(self.conn)
            self.accept()
            return True
        # [YES] Re-accept x many times
        if self.options["reconn"] > 0:
            self.log.info(
                "Re-accepting in {} sec ({} more times left)".format(
                    self.options["reconn_wait"], self.options["reconn"]
                )
            )
            self.options["reconn"] -= 1
            time.sleep(self.options["reconn_wait"])
            self.__close_socket(self.conn)
            self.accept()
            return True
        # [NO] Re-accept count is used up
        self.log.info("Re-accept count is used up. Shutting down.")
        return False

    def __reconnect_to_server(self):
        """Ensure the client re-connects to the remote server, if the remote server hang up."""
        # Only for Clients
        assert self.role == "client", "Only the role 'client' can re-connect."
        # Do not re-connect with UDP
        assert not self.options["udp"], "This should have been caught during arg check."

        # [NO] Never re-connect
        if type(self.options["reconn"]) is bool and not self.options["reconn"]:
            self.log.info("No automatic reconnect specified. Shutting down.")
            return False
        # [YES] Always re-connect indefinitely
        if type(self.options["reconn"]) is bool and self.options["reconn"]:
            self.log.info(
                "Reconnecting in {} sec (indefinitely)".format(self.options["reconn_wait"])
            )
            time.sleep(self.options["reconn_wait"])
            self.__reconnect()
            return True
        # [YES] Re-connect x many times
        if self.options["reconn"] > 0:
            self.log.info(
                "Reconnecting in {} sec ({} more times left)".format(
                    self.options["reconn_wait"], self.options["reconn"]
                )
            )
            self.options["reconn"] -= 1
            time.sleep(self.options["reconn_wait"])
            self.__reconnect()
            return True
        # [NO] Re-connect count is used up
        self.log.info("Reconnect count is used up. Shutting down.")
        return False

    # ------------------------------------------------------------------------------
    # Helper Functions
    # ------------------------------------------------------------------------------
    def gethostbyname(self, host):
        """Translate hostname into IP address."""
        if self.options["nodns"]:
            return host
        try:
            self.log.debug("Resolving hostname: {}".format(host))
            addr = socket.gethostbyname(host)
            self.log.debug("Resolved hostname:  {}".format(addr))
            return addr
        except socket.gaierror as error:
            self.log.error("Resolve Error: {}".format(error))
            sys.exit(1)

    def create_socket(self):
        """Create TCP or UDP socket."""
        try:
            if self.options["udp"]:
                self.log.debug("Creating UDP socket")
                self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            else:
                self.log.debug("Creating TCP socket")
                self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        except socket.error as error:
            self.log.error("Failed to create the socket: {}".format(error))
            sys.exit(1)
        # Get around the "[Errno 98] Address already in use" error, if the socket is still in wait
        # we instruct it to reuse the address anyway.
        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        # TODO: Not sure if SO_REUSEPORT is also required
        # try:
        #     self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)
        # except AttributeError:
        #     # Not available on Windows (and maybe others)
        #     self.log.debug("socket.SO_REUSEPORT is not available on your platform")

    def bind(self, addr, port):
        """Bind the socket to an address."""
        try:
            self.log.debug("Binding socket to {}:{}".format(addr, port))
            self.sock.bind((addr, port))
        except (OverflowError, OSError, socket.error) as error:
            self.log.error("Binding socket to {}:{} failed: {}".format(addr, port, error))
            sys.exit(1)

    def listen(self):
        """Listen for connections made to the socket."""
        try:
            self.log.debug("Listening with backlog={}".format(self.options["backlog"]))
            self.sock.listen(self.options["backlog"])
        except socket.error as error:
            self.log.error("Listening failed: {}".format(error))
            sys.exit(1)

    def accept(self):
        """Accept a connection."""
        try:
            self.log.debug("Waiting for TCP client")
            self.conn, client = self.sock.accept()
            addr, port = client
            self.log.info("Client connected from {}:{}".format(addr, port))
        except (socket.gaierror, socket.error) as error:
            self.log.error("Accept failed: {}".format(error))
            sys.exit(1)

    def connect(self):
        """Connect to a remote socket at given address and port (TCP-only)."""
        try:
            self.log.debug("Connecting to {}:{}".format(self.remote_addr, self.remote_port))
            self.sock.connect((self.remote_addr, self.remote_port))
            return True
        except socket.error as error:
            self.log.error(
                "Connecting to {}:{} failed: {}".format(self.remote_addr, self.remote_port, error)
            )
            return False

    # ------------------------------------------------------------------------------
    # Send / Receive Functions
    # ------------------------------------------------------------------------------
    def send(self, data):
        """Send data."""
        # In case of sending data back to an udp client we need to wait
        # until the client has first connected and told us its addr/port
        if self.options["udp"] and self.udp_client_addr is None and self.udp_client_port is None:
            self.log.info("Waiting for UDP client to connect")
            while self.udp_client_addr is None and self.udp_client_port is None:
                time.sleep(0.2)  # Less wastefull than using 'pass'

        curr = 0  # bytes send during one loop iteration
        send = 0  # total bytes send
        size = len(data)  # bytes of data that needs to be send
        data = self.enc.encode(data)
        assert size == len(data), "Encoding messed up string length, might need to do len() after."

        # Loop until all bytes have been send
        while send < size:
            try:
                self.log.trace("Trying to send {} bytes".format(size - send))
                if self.options["udp"]:
                    curr = self.conn.sendto(data, (self.udp_client_addr, self.udp_client_port))
                    send += curr
                else:
                    curr = self.conn.send(data)
                    send += curr
                if curr == 0:
                    self.log.error("No bytes send during loop round.")
                    return
                # Remove 'curr' many bytes from data for the next round
                data = data[curr:]
                self.log.trace("Send {} bytes ({} bytes remaining)".format(curr, size - send))
            except socket.error as error:
                if error.errno == socket.errno.EPIPE:
                    self.log.error("TODO:Add desc. Socket error({}): {}".format(error.errno, error))
                    return
                # Most likely nothing to see here??
                # FIXME: TODO: Need to re-accepd new client
                self.log.error("TODO:Add desc. Socket Error: {}".format(error))
                if self.role == "server":
                    if self.__reaccept_from_client():
                        continue
                self.log.warning("Shutdown")
                return
            except (OSError) as error:
                self.log.error("Socket OS Error: {}".format(error))
                return

    def receive(self):
        """Generator function to receive data endlessly by yielding it."""
        # Set current receive timeout
        self.conn.settimeout(self.recv_timeout)
        self.log.trace("Socket Timeout: {}".format(self.recv_timeout_retry))
        # Counts how many times we had a ready timeout for later to decide
        # if we exceeded maximum retires
        curr_recv_timeout_retry = 0
        while True:

            if self.conn is None:
                self.log.error("Socket is gone")
                return

            # Non-blocking socket with timeout. If the timeout threshold is hit,
            # it will throw an socket.timeout exception. This is required to see if other
            # threads have been terminated already.
            try:
                # https://manpages.debian.org/buster/manpages-dev/recv.2.en.html
                (byte, addr) = self.conn.recvfrom(self.options["bufsize"])
            except socket.timeout:
                # No other thread has terminated yet, and thus not asked us to quit.
                # so we can continue waiting for input on the socket
                if not THREAD_TERMINATE:
                    # TODO: Re-enable this for very verbose logging
                    # self.log.trace("SOCKET RECV: timeout. Waiting for input...")
                    continue
                # Other threads are done. Let's try to read a few more times before
                # returning and ending this function (might be data left)
                if curr_recv_timeout_retry < self.recv_timeout_retry:
                    self.log.trace("RECV EOF TIMEOUT: AND THREAD_TERMINATE REQUESTED")
                    curr_recv_timeout_retry += 1
                    continue
                return
            except socket.error as error:
                self.log.error("TODO: What happens here? Socket Receive Error: {}".format(error))
                return
            except AttributeError as error:
                self.log.error("TODO: What happens here?Attribute Receive Error: {}".format(error))
                return

            # We're receiving data again, so let's reset the retry/terminate counter
            curr_recv_timeout_retry = 0

            data = byte
            if not data:
                # Upstream (server or client) is gone. Do we reconnect or quit?
                self.log.warning("Upstream connection is gone")
                if self.role == "server":
                    if not self.__reaccept_from_client():
                        self.log.warning("Shutdown-1")
                        return
                if self.role == "client":
                    if not self.__reconnect_to_server():
                        self.log.warning("Shutdown-2")
                        return

            data = self.enc.decode(byte)
            self.log.trace("Received: {}".format(repr(data)))

            # If we're receiving data from a UDP client
            # we can firstly/finally set its addr/port in order
            # to send data back to it (see send() function)
            if self.options["udp"]:
                self.udp_client_addr, self.udp_client_port = addr
                # Avoid the noise on UDP connections to spam on every send
                if self.udp_client_addr is None or self.udp_client_port is None:
                    self.log.info(
                        "Client connected: {}:{}".format(self.udp_client_addr, self.udp_client_port)
                    )
                # Find for debug
                else:
                    self.log.debug(
                        "Client connected: {}:{}".format(self.udp_client_addr, self.udp_client_port)
                    )

            yield data


# -------------------------------------------------------------------------------------------------
# CLASS: StringEncoder
# -------------------------------------------------------------------------------------------------
class StringEncoder(object):
    """
    Takes care about Python 2/3 string encoding/decoding.

    This allows to parse all string/byte values internally between all
    classes or functions as strings to keep full Python 2/3 compat.
    """

    # https://stackoverflow.com/questions/606191/27527728#27527728
    codec = "cp437"

    def __init__(self):
        self.py3 = sys.version_info >= (3, 0)

    def encode(self, data):
        """Convert string into a byte type for Python3."""
        if self.py3:
            data = data.encode("cp437")
        return data

    def decode(self, data):
        """Convert bytes into a string type for Python3."""
        if self.py3:
            data = data.decode("cp437")
        return data


# -------------------------------------------------------------------------------------------------
# CLASS: Runner
# -------------------------------------------------------------------------------------------------
class Runner(object):
    """Runner class that takes care about putting everything into threads."""

    # ------------------------------------------------------------------------------
    # Constructor / Destructor
    # ------------------------------------------------------------------------------
    def __init__(self):
        """Constructor."""
        self.log = logging.getLogger(__name__)

    # Generator
    [
        {
            "name": "",
            "input_generator": {"fnc": "", "args": "", "kwargs": ""},
            "input_interrupter": {"fnc": "", "args": "", "kwargs": ""},
            "input_callback": {"fnc": "", "args": "", "kwargs": ""},
        }
    ]
    # Timebased

    # ------------------------------------------------------------------------------
    # Public Functions
    # ------------------------------------------------------------------------------
    def set_recv_generator(self, func):
        """Set generator func which constantly receives network data."""
        self.recv_generator = func

    def set_input_generator(self, func):
        """Set generator func which constantly receives input (shell output/user input)."""
        self.input_generator = func

    def set_send_callback(self, func):
        """Set the callback for sending data to a socket."""
        self.send_callback = func

    def set_output_callback(self, func):
        """Set the callback for outputting data to stdin/stdout."""
        self.output_callback = func

    def set_revc_generator_stop_function(self, func):
        self.recv_generator_stop_fn = func

    def set_input_generator_stop_function(self, func):
        self.input_generator_stop_fn = func

    def set_timed_action(self, intvl, func, *args, **kwargs):
        """Set a function that should be called periodically."""
        self.timed_action_intvl = intvl
        self.timed_action_func = func
        self.timed_action_args = args
        self.timed_action_kwargs = kwargs

    def run(self):
        """Run threaded NetCat."""
        global THREAD_TERMINATE

        assert hasattr(self, "recv_generator"), "Error, recv_generator not set"
        assert hasattr(self, "input_generator"), "Error, input_generator not set"
        assert hasattr(self, "send_callback"), "Error, send_callback not set"
        assert hasattr(self, "output_callback"), "Error, output_callback not set"

        def receiver():
            """Receive data from a socket and process it with a callback.

            receive: Must be a generator function to receive network data.
            callback: Must be a callback to process received data, e.g.: print to stdin/stdout.
            """
            self.log.trace("[Thread-Recv] START")
            for data in self.recv_generator():
                self.log.trace("[Thread-Recv] recv_generator() received: {}".format(repr(data)))
                self.output_callback(data)
            self.log.trace("[Thread-Recv] STOP")

        def sender():
            """Receive data from user-input/command-output and process it with a callback.

            receive: Must be a generator function to receive user-input or command output.
            callback: Must be a callback to send this data to a socket.
            """
            self.log.trace("[Thread-Send] START")
            for data in self.input_generator():
                self.log.trace("[Thread-Send] received via input_generator(): {}".format(data))
                self.send_callback(data)
            self.log.trace("[Thread-Send] STOP")

        def timer():
            """Execute periodic tasks by an optional provided time_action."""
            self.log.trace("[Thread-Time] START")
            self.log.debug(
                "Ready for timed action every {} seconds".format(self.timed_action_intvl)
            )
            time_last = int(time.time())
            while True:
                time_now = int(time.time())
                if time_now > time_last + self.timed_action_intvl:
                    self.log.debug("[{}] Executing timed function".format(time_now))
                    self.timed_action_func(*self.timed_action_args, **self.timed_action_kwargs)
                    time_last = time_now  # Reset previous time
                time.sleep(1)

        # Start sending and receiving threads
        self.tr = threading.Thread(target=receiver, name="Thread-Recv")
        self.ts = threading.Thread(target=sender, name="Thread-Send")
        # If the main thread kills, this thread will be killed too.
        self.tr.daemon = False  # No daemon, wait for each other (e.g.: data received
        self.ts.daemon = False  # should also be outputted)
        # Start threads
        self.tr.start()
        # time.sleep(0.1)
        self.ts.start()

        if hasattr(self, "timed_action_intvl"):
            self.tt = threading.Thread(target=timer, name="Thread-Time")
            self.tt.daemon = True
            self.tt.start()

        # Cleanup the main program
        while True:
            # TODO: is this required? (check if need to press Ctrl+c twice)
            # if not THREAD_TERMINATE:
            #     self.input_generator_stop_fn()
            #     self.recv_generator_stop_fn()
            if not self.tr.is_alive():
                self.log.trace("Setting THREAD_TERMINATE=True from Thread-Recv death")
                self.log.trace("Waiting for Thread-Send to finish")
                # time.sleep(0.1)
                THREAD_TERMINATE = True
                self.input_generator_stop_fn()
                self.ts.join()
                sys.exit(0)
            if not self.ts.is_alive():
                self.log.trace("Setting THREAD_TERMINATE=True from Thread-Send death")
                self.log.trace("Waiting for Thread-Recv to finish")
                # time.sleep(0.1)
                THREAD_TERMINATE = True
                self.recv_generator_stop_fn()
                self.tr.join()
                sys.exit(0)
            # TODO: Yes, also implement the timed function
            # if hasattr(self, "tt"):
            #     if not self.tt.is_alive():
            #         sys.exit(0)
            # time.sleep(0.1)


# -------------------------------------------------------------------------------------------------
# CLASS: NetcatPluginOutput (Module for: user-input -> send -> receive -> output)
# -------------------------------------------------------------------------------------------------
class NetcatPluginOutput(AbstractNetcatPlugin):
    """Implement basic input/output plugin.

    This plugin provides a generator which continuously reads from stdin
    (non-blocking on POSIX and blocking on windows) as well as a
    callback that writes to stdout.
    """

    # Line feeds to use for user input
    linefeed = "\n"

    # Non-blocking read from stdin achieved via timeout.
    # Specify timeout in seconds.
    input_timeout = None

    # ------------------------------------------------------------------------------
    # Constructor / Destructor
    # ------------------------------------------------------------------------------
    def __init__(self, encoder, options={}):
        """Set specific options for this plugin."""
        self.log = logging.getLogger(__name__)
        self.enc = encoder

        assert "input_timeout" in options, "Error, 'input_timeout' must be set."
        if "input_timeout" in options:
            self.input_timeout = options["input_timeout"]
        if "linefeed" in options:
            self.linefeed = options["linefeed"]

    # ------------------------------------------------------------------------------
    # Private Functions
    # ------------------------------------------------------------------------------
    def __use_linefeeds(self, data):
        """Ensure the user input has the desired linefeeds --crlf or not."""
        if data.endswith("\r\n"):
            data = data[:-2]
        elif data.endswith("\n") or data.endswith("\r"):
            data = data[:-1]
        data += self.linefeed
        return data

    def __set_input_timeout(self):
        """Throws a catchable BaseException for sys.stdin after timeout (Linux only)."""
        i, o, e = select.select([sys.stdin], [], [], self.input_timeout)
        if not i:
            raise BaseException("timed out")

    # ------------------------------------------------------------------------------
    # Public Functions
    # ------------------------------------------------------------------------------
    def stop(self):
        global THREAD_TERMINATE
        """Stop function that can be called externally to close this instance."""
        self.log.trace("[NetcatOutputCommand] pass was raised by stop() function")
        THREAD_TERMINATE = True

    def input_generator(self):
        """Constantly ask for user input."""
        # https://stackoverflow.com/questions/1450393/#38670261
        # while True: line = sys.stdin.readline() <- reads a whole line (faster)
        # for line in sys.stdin.readlin():        <- reads one byte at a time
        while True:
            if THREAD_TERMINATE:
                return
            try:
                # TODO: select() does not work for windows on stdin/stdout
                if os.name != "nt":
                    self.__set_input_timeout()
                line = sys.stdin.readline()
            except BaseException:
                # When using select() with timeout, we don't have any input
                # at this point and simply continue the loop or quit if
                # a terminate request has been made by other threads.
                if THREAD_TERMINATE:
                    self.log.trace("STDIN: terminate")
                    return
                # TODO: Re-enable this for very verbose logging
                # self.log.trace("STDIN: timeout. Waiting for input...")
                continue
            if line:
                self.log.trace("Yielding stdin")
                yield self.__use_linefeeds(line)
            # EOF or <Ctrl>+<d>
            else:
                # DO NOT RETURN HERE BLINDLY, THE UPSTREAM CONNECTION MUST GO FIRST!
                if THREAD_TERMINATE:
                    self.log.trace("No more input generated, quitting.")
                    return
                # TODO: Re-enable this for very verbose logging
                # self.log.trace("STDIN: Reached EOF, repeating")

    def output_callback(self, data):
        """Print received data to stdout."""
        print(data, end="")
        sys.stdout.flush()  # TODO:Is this required? What does this do? Test this!


# -------------------------------------------------------------------------------------------------
# CLASS: NetcatPluginCommand (Module for user-input -> send -> execute -> send-back -> output)
# -------------------------------------------------------------------------------------------------
class NetcatPluginCommand(AbstractNetcatPlugin):
    """Implement command execution functionality."""

    executable = None

    # ------------------------------------------------------------------------------
    # Constructor / Destructor
    # ------------------------------------------------------------------------------
    def __init__(self, encoder, options={}):
        """Set specific options for this plugin."""
        self.log = logging.getLogger(__name__)
        self.enc = encoder
        assert "executable" in options
        self.log.debug("Setting '{}' as executable".format(options["executable"]))
        self.executable = options["executable"]

        # Open executable to wait for commands
        env = os.environ.copy()
        try:
            self.p = Popen(
                # TODO: should I also use 'bufsize=1'?
                self.executable,
                stdin=PIPE,
                stdout=PIPE,
                stderr=subprocess.STDOUT,
                shell=False,
                env=env,
            )
        except FileNotFoundError:
            self.log.error("Specified executable '{}' not found".format(self.executable))
            sys.exit(1)

        # Define destructor
        atexit.register(self.__exit__)

    def __exit__(self):
        """Destructor."""
        self.log.trace("Killing executable: {} with pid {}".format(self.executable, self.p.pid))
        self.p.kill()

    # ------------------------------------------------------------------------------
    # Public Functions
    # ------------------------------------------------------------------------------
    def stop(self):
        """Stop function that can be called externally to close this instance."""
        global THREAD_TERMINATE
        THREAD_TERMINATE = True
        self.log.trace("[NetcatPluginCommand] subprocess.kill() was raised by stop() function")
        self.p.kill()

    def __set_input_timeout(self, timeout=0.1):
        """Throw a TimeOutError Exception for sys.stdin (Linux only)."""
        # select((rlist, wlist, xlist, timeout)
        # rlist: wait until ready for reading
        # wlist: wait until ready for writing
        # xlist: wait for an "exceptional condition"
        i, o, e = select.select([self.p.stdout], [], [], timeout)
        if not i:
            raise BaseException("timed out")

    def input_generator(self):
        """Constantly ask for input."""
        while True:
            self.log.trace("Reading command output")
            # TODO: non-blocking read does not seem to work or?
            # try:
            # self.__set_input_timeout(timeout=1.5)
            data = self.p.stdout.readline()  # Much better performance than self.p.read(1)
            self.log.trace(data)
            # except BaseException:
            #    if THREAD_TERMINATE:
            #        return
            #    # No input, just check again
            #    #self.p.stdout.flush()
            #    continue
            data = self.enc.decode(data)
            self.log.trace("Command output: {}".format(data))
            if not data:
                self.log.trace("Command output was empty. Exiting loop.")
                break
            yield data

    def output_callback(self, data):
        """Send data received to stdin (command input)."""
        data = self.enc.encode(data)
        self.log.trace("Appending to stdin: {}".format(data))
        self.p.stdin.write(data)
        self.p.stdin.flush()


# -------------------------------------------------------------------------------------------------
# CLASS: NetcatServer
# -------------------------------------------------------------------------------------------------
class NetcatServer(AbstractSocket):
    """Netcat Server implementation."""

    def __init__(self, encoder, host, port, recv_timeout, recv_timeout_retry, options={}):
        """Construct a listening server."""
        super(NetcatServer, self).__init__(
            encoder, "server", recv_timeout, recv_timeout_retry, options
        )

        # Setup server
        addr = self.gethostbyname(host)
        self.create_socket()
        self.bind(addr, port)
        if self.options["udp"]:
            self.conn = self.sock
            self.log.info("Waiting on {}:{} (UDP)".format(addr, port))
        else:
            self.listen()
            self.log.info("Listening on {}:{} (TCP)".format(addr, port))
            self.accept()


# -------------------------------------------------------------------------------------------------
# CLASS: NetcatClient
# -------------------------------------------------------------------------------------------------
class NetcatClient(AbstractSocket):
    """Netcat Client implementation."""

    def __init__(self, encoder, host, port, recv_timeout, recv_timeout_retry, options={}):
        """Construct a connecting clientt."""
        super(NetcatClient, self).__init__(
            encoder, "client", recv_timeout, recv_timeout_retry, options
        )

        # Setup client
        addr = self.gethostbyname(host)
        self.create_socket()
        self.conn = self.sock
        if self.options["udp"]:
            self.udp_client_addr = addr
            self.udp_client_port = port
        else:
            self.remote_addr = addr
            self.remote_port = port
            if not self.connect():
                sys.exit(1)


# -------------------------------------------------------------------------------------------------
# COMMAND LINE ARGUMENTS
# -------------------------------------------------------------------------------------------------
def get_version():
    """Return version information."""
    return """%(prog)s: Version %(version)s (%(url)s) by %(author)s""" % (
        {"prog": APPNAME, "version": VERSION, "url": APPREPO, "author": "cytopia"}
    )


def _args_check_port(value):
    """Check arguments for invalid port number."""
    min_port = 1
    max_port = 65535
    intvalue = int(value)

    if intvalue < min_port or intvalue > max_port:
        raise argparse.ArgumentTypeError("%s is an invalid port number" % value)
    return intvalue


def _args_check_forwards(value):
    """Check forward argument (-L/-R) for correct pattern."""
    match = re.search(r"(.+):(.+)", value)
    if match is None or len(match.groups()) != 2:
        raise argparse.ArgumentTypeError("%s is not a valid 'addr:port' format." % value)
    _args_check_port(match.group(2))
    return value


def _args_check_rebind(value):
    """Check rebind argument for correct value."""
    intvalue = int(value)
    if intvalue < 0:
        raise argparse.ArgumentTypeError("must be equal or greater than 0." % value)
    return intvalue


def _args_check_reconn(value):
    """Check reconn argument for correct value."""
    intvalue = int(value)
    if intvalue < 0:
        raise argparse.ArgumentTypeError("must be equal or greater than 0." % value)
    return intvalue


def _args_check_robin_ports(value):
    """Check round-robin argument for comma separated string or range."""
    mcomma = re.search(r"^[0-9]+(,([0-9]+))*$", value)
    mrange = re.search(r"^[0-9]+\-[0-9]+$", value)

    if mcomma is None:
        if mrange is None:
            raise argparse.ArgumentTypeError("%s is not a valid port specifier" % value)

    if mcomma:
        ports = mcomma.group(0).split(",")
        for port in ports:
            _args_check_port(port)
        return ports

    if mrange:
        ranges = mrange.group(0).split("-")
        if int(ranges[0]) >= (int(ranges[1]) + 1):
            raise argparse.ArgumentTypeError(
                "Left side of range must be smaller or equal than right side."
            )
        ports = []
        for port in range(int(ranges[0]), int(ranges[1]) + 1):
            _args_check_port(port)
            ports.append(port)
        return ports


def _args_check_mutually_exclusive(parser, args):
    """Check mutually exclusive arguments."""

    # This is connect mode
    connect_mode = not args.listen and not args.zero and not args.local

    # [MODE] --listen
    if args.listen and (args.zero or args.local):
        parser.print_usage()
        print(
            "%s: error: -l/--listen mutually exclusive with -z/-zero or -L/--local" % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # [MODE] --zero
    if args.zero and (args.listen or args.local):
        parser.print_usage()
        print(
            "%s: error: -z/--zero mutually exclusive with -l/--listen or -L/--local" % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # [MODE --local
    if args.local and (args.listen or args.zero):
        parser.print_usage()
        print(
            "%s: error: -L/--local mutually exclusive with -l/--listen or -z/--zero" % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # [MODULE] --exec
    if args.cmd and (args.local or args.zero):
        parser.print_usage()
        print(
            "%s: error: -e/--exec mutually exclusive with -L/--local or -z/--zero" % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # [OPTIONS] --udp
    if args.udp and args.zero:
        parser.print_usage()
        print(
            "%s: error: -u/--udp mutually exclusive with -z/--zero" % (APPNAME), file=sys.stderr,
        )
        sys.exit(1)

    # [ADVANCED] --http
    if args.http and (args.https or args.udp or args.zero):
        parser.print_usage()
        print(
            "%s: error: --http mutually exclusive with --https, -u/--udp or -z/--zero" % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # [ADVANCED] --https
    if args.https and (args.http or args.udp or args.zero):
        parser.print_usage()
        print(
            "%s: error: --https mutually exclusive with --http, -z/--udp or -z/--zero" % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # [ADVANCED] --keep-open
    if args.keep_open and (args.udp):
        parser.print_usage()
        print(
            "%s: error: --keep-open mutually exclusive with -u/--udp" % (APPNAME), file=sys.stderr,
        )
        sys.exit(1)
    if args.keep_open and not args.listen:
        parser.print_usage()
        print(
            "%s: error: --keep-open only works with -l/--listen" % (APPNAME), file=sys.stderr,
        )
        sys.exit(1)

    # [ADVANCED] --rebind
    if args.rebind is not False and not args.listen:
        parser.print_usage()
        print(
            "%s: error: --rebind only works with -l/--listen" % (APPNAME), file=sys.stderr,
        )
        sys.exit(1)

    # [ADVANCED] --reconn
    if args.reconn is not False and (args.udp):
        parser.print_usage()
        print(
            "%s: error: --reconn mutually excl. with -u/--udp" % (APPNAME), file=sys.stderr,
        )
        sys.exit(1)
    if args.reconn is not False and not (connect_mode or args.zero):
        parser.print_usage()
        print(
            "%s: error: --reconn only works with connect mode or -z/--zero" % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # [ADVANCED] --wait
    if args.wait is not False and (args.udp):
        parser.print_usage()
        print(
            "%s: error: -w/--wait mutually excl. with -u/--udp" % (APPNAME), file=sys.stderr,
        )
        sys.exit(1)
    if args.wait is not False and not (connect_mode):
        parser.print_usage()
        print(
            "%s: error: -w/--wait only works with connect mode" % (APPNAME), file=sys.stderr,
        )
        sys.exit(1)

    # [ADVANCED] --udp-ping-init
    if args.udp_ping_init is not False and (args.listen or args.local):
        parser.print_usage()
        print(
            "%s: error: --udp-ping-init mutually excl. with -l/--listen or -L/--local" % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)
    if args.udp_ping_init is not False and not (args.udp):
        parser.print_usage()
        print(
            "%s: error: --udp-ping-init only works with -u/--udp" % (APPNAME), file=sys.stderr,
        )
        sys.exit(1)


def get_args():
    """Retrieve command line arguments."""
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawTextHelpFormatter,
        add_help=False,
        usage="""%(prog)s [-Cnuv] [-e cmd] hostname port
       %(prog)s [-Cnuv] [-e cmd] -l [hostname] port
       %(prog)s [-Cnuv] -z hostname port
       %(prog)s [-Cnuv] -L addr:port [hostname] port
       %(prog)s -V, --version
       %(prog)s -h, --help
       """
        % ({"prog": APPNAME}),
        description="""
Enhanced and comptaible Netcat implementation written in Python (2 and 3) with
connect, zero-i/o, listen and forward modes and techniques to detect and evade
firewalls and intrusion detection/prevention systems.

If no mode arguments are specified, pwncat will run in connect mode and act as
a client to connect to a remote endpoint. If the connection to the remote
endoint is lost, pwncat will quit. See advanced options for how to automatically
reconnect.""",
    )

    positional = parser.add_argument_group("positional arguments")
    mode = parser.add_argument_group("mode arguments")
    optional = parser.add_argument_group("optional arguments")
    advanced = parser.add_argument_group("advanced arguments")
    misc = parser.add_argument_group("misc arguments")

    positional.add_argument(
        "hostname", nargs="?", type=str, help="Address to listen, forward or connect to"
    )
    positional.add_argument(
        "port", type=_args_check_port, help="Port to listen, forward or connect to"
    )

    mode.add_argument(
        "-l",
        "--listen",
        action="store_true",
        default=False,
        help="""[Listen mode]:
Start a server and listen for incoming connections.
If using TCP and a connected client disconnects or the
connection is interrupted otherwise, the server will
quit. See -k/--keep-open to change this behaviour.

""",
    )
    mode.add_argument(
        "-z",
        "--zero",
        action="store_true",
        default=False,
        help="""[Zero-I/0 mode]:
Connect to a remote endpoint and report status only.
Used for port scanning.

""",
    )
    mode.add_argument(
        "-L",
        "--local",
        metavar="addr:port",
        default=False,
        type=_args_check_forwards,
        help="""[Local forward mode]:
This mode will start a server and a client internally.
The internal server will listen locally on specified
hostname/port (positional arguments). Same as with -l.
The server will then forward traffic to the internal
client which connects to another server specified by
address given via -L/--local addr:port.
(I.e.: proxies a remote service to a local address)
"""
        % ({"prog": APPNAME}),
    )
    optional.add_argument(
        "-e",
        "--exec",
        metavar="cmd",
        dest="cmd",
        default=False,
        type=str,
        help="Execute shell command. Only for connect or listen mode.",
    )
    optional.add_argument(
        "-C",
        "--crlf",
        action="store_true",
        default=False,
        help="Send CRLF line-endings in connect mode (default: LF)",
    )
    optional.add_argument(
        "-n", "--nodns", action="store_true", default=False, help="Do not resolve DNS.",
    )
    optional.add_argument(
        "-u",
        "--udp",
        action="store_true",
        default=False,
        help="Use UDP for the connection instead of TCP.",
    )
    optional.add_argument(
        "-v",
        "--verbose",
        action="count",
        default=0,
        help="""Be verbose and print info to stderr. Use -v, -vv, -vvv
or -vvvv for more verbosity. The server performance will
decrease drastically if you use more than three times.""",
    )

    advanced.add_argument(
        "--http",
        action="store_true",
        default=False,
        help="""Connect / Listen / Local forward mode (TCP only):
Hide traffic in http packets to fool Firewalls/IDS/IPS.

""",
    )
    advanced.add_argument(
        "--https",
        action="store_true",
        default=False,
        help="""Connect / Listen / Local forward mode (TCP only):
Hide traffic in https packets to fool Firewalls/IDS/IPS.

""",
    )
    advanced.add_argument(
        "-k",
        "--keep-open",
        action="store_true",
        default=False,
        help="""Listen mode (TCP only):
Re-accept new clients in listen mode after a client has
disconnected or the connection is unterrupted otherwise.
(default: server will quit after connection is gone)

""",
    )
    advanced.add_argument(
        "--rebind",
        metavar="x",
        default=False,
        type=_args_check_rebind,
        help="""Listen mode (TCP and UDP):
If the server is unable to bind or accept clients, it
will re-initialize itself x many times before giving up.
Use 0 to re-initialize endlessly. (default: fail after
first unsuccessful try).

""",
    )
    advanced.add_argument(
        "--rebind-wait",
        metavar="s",
        default=1,
        type=int,
        help="""Listen mode (TCP and UDP):
Wait x seconds between re-initialization. (default: 1)

""",
    )
    advanced.add_argument(
        "--rebind-robin",
        metavar="port",
        default=[],
        type=_args_check_robin_ports,
        help="""Listen mode (TCP and UDP):
If the server is unable to initialize (e.g: cannot bind
and --rebind is specified, it it will shuffle ports in
round-robin mode to bind to. Use comma separated string
such as '80,81,82' or a range of ports '80-100'.
Set --rebind to at least the number of ports to probe +1
This option requires --rebind to be specified.

""",
    )
    advanced.add_argument(
        "--reconn",
        metavar="x",
        default=False,
        type=_args_check_reconn,
        help="""Connect mode / Zero-I/O mode (TCP only):
If the remote server is not reachable or the connection
is interrupted, the client will connect again x many
times before giving up. Use 0 to retry endlessly.
(default: quit if the remote is not available or the
connection was interrupted)
This might be handy for stable TCP reverse shells ;-)

""",
    )
    advanced.add_argument(
        "--reconn-wait",
        metavar="s",
        default=1,
        type=int,
        help="""Connect mode / Zero-I/O mode (TCP only):
Wait x seconds between re-connects. (default: 1)

""",
    )
    advanced.add_argument(
        "--reconn-robin",
        metavar="port",
        default=[],
        type=_args_check_robin_ports,
        help="""Connect mode / Zero-I/O mode (TCP only):
If the remote server is not reachable or the connection
is interrupted and --reconn is specified, the client
will shuffle ports in round-robin mode to connect to.
Use comma separated string such as '80,81,82' or a range
of ports '80-100'.
Set --reconn to at least the number of ports to probe +1
This helps reverse shell to evade intrusiona prevention
systems that will cut your connection and block the
outbound port.
This is also useful in Connect or Zero-I/O mode to
figure out what outbound ports are allowed.

""",
    )
    advanced.add_argument(
        "-w",
        "--wait",
        metavar="s",
        default=False,
        type=int,
        help="""Connect mode (TCP only):
If a connection and stdin are idle for more than s sec,
then the connection is silently closed and the client
will exit. (default: wait forever).
Note: if --reconn is specified, the connection will be
re-opened.

""",
    )
    advanced.add_argument(
        "--udp-ping-init",
        action="store_true",
        default=False,
        help="""Connect mode / Zero-I/O mode (UDP only):
UDP is a stateless protocol unlike TCP, so no hand-
shake communication takes place and the client just
sends data to a server without being "accepted" by
the server first.
This means a server waiting for an UDP client to
connect to, is unable to send any data to the client,
before the client hasn't send data first. The server
simply doesn't know the IP address before an initial
connect.
The --udp-ping-init option instructs the client to send
one single initial ping packet to the server, so that it
is able to talk to the client.
This is the only way to make a UDP reverse shell work.
See --udp-ping-word for what char/string to send as
initial ping packet (default: '\\0')

""",
    )
    advanced.add_argument(
        "--udp-ping-intvl",
        metavar="s",
        default=False,
        type=int,
        help="""Connect mode / Zero-I/O mode (UDP only):
Instruct the UDP client to send ping intervalls every
s seconds. This allows you to restart your UDP server
and just wait for the client to report back in.
This might be handy for stable UDP reverse shells ;-)
See --udp-ping-word for what char/string to send as
initial ping packet (default: '\\0')

""",
    )
    advanced.add_argument(
        "--udp-ping-word",
        metavar="str",
        default="\0",
        type=str,
        help="""Connect mode / Zero-I/O mode (UDP only):
Change the default character '\\0' to use for upd ping.
Single character or strings are supported.

""",
    )
    advanced.add_argument(
        "--udp-ping-robin",
        metavar="port",
        default=[],
        type=_args_check_robin_ports,
        help="""Zero-I/O mode (UDP only):
Instruct the UDP client to shuffle the specified ports
in round-robin mode for a remote server to ping.
This might be handy to scan outbound allowed ports.
Use --udp-ping-intvl 0 to be faster.

""",
    )
    advanced.add_argument(
        "--safe-word",
        metavar="str",
        default=False,
        type=str,
        help="""All modes:
If %(prog)s is started with this argument, it will shut
down as soon as it receives the specified string.
The --rebind or --reconn options will not start it up
again. Use a very unique string to not have it shut down
accidentally by other input.
"""
        % ({"prog": APPNAME}),
    )
    misc.add_argument("-h", "--help", action="help", help="Show this help message and exit")
    misc.add_argument(
        "-V",
        "--version",
        action="version",
        version=get_version(),
        help="Show version information and exit",
    )

    # Retrieve arguments
    args = parser.parse_args()

    # Check mutually exclive arguments
    _args_check_mutually_exclusive(parser, args)

    # Connect mode and Zero-I/O mode require hostname and port to be set
    connect_mode = not (args.listen or args.zero or args.local)
    if (connect_mode or args.zero) and not (args.hostname):
        parser.print_usage()
        print(
            "%s: error: the following arguments are required: hostname" % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # TODO: deny unimplemented modes

    return args


# -------------------------------------------------------------------------------------------------
# CUSTOM FUNCTIONS
# -------------------------------------------------------------------------------------------------
def logtrace(self, message, *args, **kws):
    """Set custom log level for TRACE."""
    if self.isEnabledFor(LOGLEVEL_TRACE_NUM):
        self._log(LOGLEVEL_TRACE_NUM, message, args, **kws)


# -------------------------------------------------------------------------------------------------
# MAIN ENTRYPOINT
# -------------------------------------------------------------------------------------------------
def main():
    """Run the program."""
    args = get_args()
    host = args.hostname if args.hostname is not None else "0.0.0.0"
    port = args.port

    # Set netcat options
    net_opts = {
        "bufsize": 1024,
        "backlog": 0,
        "nodns": args.nodns,
        "udp": args.udp,
        "http": args.http,
        "https": args.https,
        "keep_open": args.keep_open,
        "rebind": True if (type(args.rebind) is int and args.rebind == 0) else args.rebind,
        "reconn": True if (type(args.reconn) is int and args.reconn == 0) else args.reconn,
        "rebind_wait": args.rebind_wait,
        "reconn_wait": args.reconn_wait,
        "rebind_robin": args.rebind_robin,
        "reconn_robin": args.reconn_robin,
        "wait": args.wait,
        "udp_ping_init": args.udp_ping_init,
        "udp_ping_intvl": args.udp_ping_intvl,
        "udp_ping_word": args.udp_ping_word,
        "udp_ping_robing": args.udp_ping_robin,
        "safe_word": args.safe_word,
    }

    # Initialize logger
    if args.verbose == 0:
        loglevel = logging.ERROR
    elif args.verbose == 1:
        loglevel = logging.WARNING
    elif args.verbose == 2:
        loglevel = logging.INFO
    elif args.verbose == 3:
        loglevel = logging.DEBUG
    else:
        loglevel = LOGLEVEL_TRACE_NUM

    logging.addLevelName(LOGLEVEL_TRACE_NUM, "TRACE")
    logging.Logger.trace = logtrace
    logformat = "%(levelname)s:%(message)s"
    if args.verbose > 3:
        logformat = "%(levelname)s [%(threadName)s] %(funcName)s():%(message)s"
    logging.basicConfig(format=logformat, level=loglevel)

    # Initialize encoder
    encoder = StringEncoder()
    # Use command modulde
    if args.cmd:
        module_opts = {"executable": args.cmd}
        mod = NetcatPluginCommand(encoder, module_opts)
    # Use output module
    else:
        module_opts = {}
        module_opts["linefeed"] = "\r\n" if args.crlf else "\n"
        module_opts["input_timeout"] = TIMEOUT_READ_STDIN
        mod = NetcatPluginOutput(encoder, module_opts)

    # Run local port-forward
    # -> listen locally and forward traffic to remote (connect)
    if args.local:
        # TODO: Make the listen address optional!
        # Create listen and client instances
        # FIXME: As there is only one THREAD_TERMINATE, both instances will use it.
        #       this should go into the runner or so.
        srv_opts = net_opts.copy()
        srv_opts["reconn"] = True
        srv_opts["reconn_wait"] = 0
        lhost = args.local.split(":")[0]
        lport = int(args.local.split(":")[1])
        net_srv = NetcatServer(
            encoder, lhost, lport, TIMEOUT_RECV_SOCKET, TIMEOUT_RECV_SOCKET_RETRY, srv_opts
        )
        net_cli = NetcatClient(
            encoder, host, port, TIMEOUT_RECV_SOCKET, TIMEOUT_RECV_SOCKET_RETRY, net_opts
        )

        # Create Runner (the set_* funcs below are brainfuck and took me 1 hour to figure it out)
        run = Runner()

        # [srv] User-Client connects here, sends data and the Server takes it as input
        run.set_recv_generator(net_srv.receive)
        # [cli] Runner parses data from Server on to Proxy-Client, which sends/connect it further
        run.set_output_callback(net_cli.send)
        # [cli] Proxy-Client waits for response and receives data back
        run.set_input_generator(net_cli.receive)
        # [srv] Runner parses data from Proxy-Client onto Server, which sends/back to User-Client
        run.set_send_callback(net_srv.send)

        run.set_revc_generator_stop_function(object)
        run.set_input_generator_stop_function(object)
        # And finally run
        run.run()
    # Run server
    if args.listen:
        net = NetcatServer(
            encoder, host, port, TIMEOUT_RECV_SOCKET, TIMEOUT_RECV_SOCKET_RETRY, net_opts
        )
        run = Runner()
        run.set_recv_generator(net.receive)
        run.set_input_generator(mod.input_generator)
        run.set_send_callback(net.send)
        run.set_output_callback(mod.output_callback)

        run.set_revc_generator_stop_function(object)
        run.set_input_generator_stop_function(mod.stop)
        run.run()
    # Run client
    else:
        net = NetcatClient(
            encoder, host, port, TIMEOUT_RECV_SOCKET, TIMEOUT_RECV_SOCKET_RETRY, net_opts
        )
        run = Runner()
        run.set_recv_generator(net.receive)
        run.set_input_generator(mod.input_generator)
        run.set_send_callback(net.send)
        run.set_output_callback(mod.output_callback)
        if type(args.udp_ping_intvl) is int and args.udp_ping_intvl > 0:
            run.set_timed_action(args.udp_ping_intvl, net.send, "\x00")
        run.set_revc_generator_stop_function(object)
        run.set_input_generator_stop_function(object)
        run.run()


if __name__ == "__main__":
    # Catch Ctrl+c and exit without error message
    try:
        main()
    except KeyboardInterrupt:
        THREAD_TERMINATE = True
        print()
        sys.exit(1)
</code></pre>
  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="pwncat.APPNAME" class="name">var <span class="ident">APPNAME</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pwncat.APPREPO" class="name">var <span class="ident">APPREPO</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pwncat.LOGLEVEL_TRACE_NUM" class="name">var <span class="ident">LOGLEVEL_TRACE_NUM</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pwncat.PIPE" class="name">var <span class="ident">PIPE</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pwncat.THREAD_TERMINATE" class="name">var <span class="ident">THREAD_TERMINATE</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pwncat.TIMEOUT_READ_STDIN" class="name">var <span class="ident">TIMEOUT_READ_STDIN</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pwncat.TIMEOUT_RECV_SOCKET" class="name">var <span class="ident">TIMEOUT_RECV_SOCKET</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pwncat.TIMEOUT_RECV_SOCKET_RETRY" class="name">var <span class="ident">TIMEOUT_RECV_SOCKET_RETRY</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pwncat.VERSION" class="name">var <span class="ident">VERSION</span></p>
      
  
  <div class="source_cont">
</div>

      </div>

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="pwncat.get_args">
    <p>def <span class="ident">get_args</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>Retrieve command line arguments.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.get_args', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.get_args" class="source">
    <pre><code>def get_args():
    """Retrieve command line arguments."""
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawTextHelpFormatter,
        add_help=False,
        usage="""%(prog)s [-Cnuv] [-e cmd] hostname port
       %(prog)s [-Cnuv] [-e cmd] -l [hostname] port
       %(prog)s [-Cnuv] -z hostname port
       %(prog)s [-Cnuv] -L addr:port [hostname] port
       %(prog)s -V, --version
       %(prog)s -h, --help
       """
        % ({"prog": APPNAME}),
        description="""
Enhanced and comptaible Netcat implementation written in Python (2 and 3) with
connect, zero-i/o, listen and forward modes and techniques to detect and evade
firewalls and intrusion detection/prevention systems.

If no mode arguments are specified, pwncat will run in connect mode and act as
a client to connect to a remote endpoint. If the connection to the remote
endoint is lost, pwncat will quit. See advanced options for how to automatically
reconnect.""",
    )

    positional = parser.add_argument_group("positional arguments")
    mode = parser.add_argument_group("mode arguments")
    optional = parser.add_argument_group("optional arguments")
    advanced = parser.add_argument_group("advanced arguments")
    misc = parser.add_argument_group("misc arguments")

    positional.add_argument(
        "hostname", nargs="?", type=str, help="Address to listen, forward or connect to"
    )
    positional.add_argument(
        "port", type=_args_check_port, help="Port to listen, forward or connect to"
    )

    mode.add_argument(
        "-l",
        "--listen",
        action="store_true",
        default=False,
        help="""[Listen mode]:
Start a server and listen for incoming connections.
If using TCP and a connected client disconnects or the
connection is interrupted otherwise, the server will
quit. See -k/--keep-open to change this behaviour.

""",
    )
    mode.add_argument(
        "-z",
        "--zero",
        action="store_true",
        default=False,
        help="""[Zero-I/0 mode]:
Connect to a remote endpoint and report status only.
Used for port scanning.

""",
    )
    mode.add_argument(
        "-L",
        "--local",
        metavar="addr:port",
        default=False,
        type=_args_check_forwards,
        help="""[Local forward mode]:
This mode will start a server and a client internally.
The internal server will listen locally on specified
hostname/port (positional arguments). Same as with -l.
The server will then forward traffic to the internal
client which connects to another server specified by
address given via -L/--local addr:port.
(I.e.: proxies a remote service to a local address)
"""
        % ({"prog": APPNAME}),
    )
    optional.add_argument(
        "-e",
        "--exec",
        metavar="cmd",
        dest="cmd",
        default=False,
        type=str,
        help="Execute shell command. Only for connect or listen mode.",
    )
    optional.add_argument(
        "-C",
        "--crlf",
        action="store_true",
        default=False,
        help="Send CRLF line-endings in connect mode (default: LF)",
    )
    optional.add_argument(
        "-n", "--nodns", action="store_true", default=False, help="Do not resolve DNS.",
    )
    optional.add_argument(
        "-u",
        "--udp",
        action="store_true",
        default=False,
        help="Use UDP for the connection instead of TCP.",
    )
    optional.add_argument(
        "-v",
        "--verbose",
        action="count",
        default=0,
        help="""Be verbose and print info to stderr. Use -v, -vv, -vvv
or -vvvv for more verbosity. The server performance will
decrease drastically if you use more than three times.""",
    )

    advanced.add_argument(
        "--http",
        action="store_true",
        default=False,
        help="""Connect / Listen / Local forward mode (TCP only):
Hide traffic in http packets to fool Firewalls/IDS/IPS.

""",
    )
    advanced.add_argument(
        "--https",
        action="store_true",
        default=False,
        help="""Connect / Listen / Local forward mode (TCP only):
Hide traffic in https packets to fool Firewalls/IDS/IPS.

""",
    )
    advanced.add_argument(
        "-k",
        "--keep-open",
        action="store_true",
        default=False,
        help="""Listen mode (TCP only):
Re-accept new clients in listen mode after a client has
disconnected or the connection is unterrupted otherwise.
(default: server will quit after connection is gone)

""",
    )
    advanced.add_argument(
        "--rebind",
        metavar="x",
        default=False,
        type=_args_check_rebind,
        help="""Listen mode (TCP and UDP):
If the server is unable to bind or accept clients, it
will re-initialize itself x many times before giving up.
Use 0 to re-initialize endlessly. (default: fail after
first unsuccessful try).

""",
    )
    advanced.add_argument(
        "--rebind-wait",
        metavar="s",
        default=1,
        type=int,
        help="""Listen mode (TCP and UDP):
Wait x seconds between re-initialization. (default: 1)

""",
    )
    advanced.add_argument(
        "--rebind-robin",
        metavar="port",
        default=[],
        type=_args_check_robin_ports,
        help="""Listen mode (TCP and UDP):
If the server is unable to initialize (e.g: cannot bind
and --rebind is specified, it it will shuffle ports in
round-robin mode to bind to. Use comma separated string
such as '80,81,82' or a range of ports '80-100'.
Set --rebind to at least the number of ports to probe +1
This option requires --rebind to be specified.

""",
    )
    advanced.add_argument(
        "--reconn",
        metavar="x",
        default=False,
        type=_args_check_reconn,
        help="""Connect mode / Zero-I/O mode (TCP only):
If the remote server is not reachable or the connection
is interrupted, the client will connect again x many
times before giving up. Use 0 to retry endlessly.
(default: quit if the remote is not available or the
connection was interrupted)
This might be handy for stable TCP reverse shells ;-)

""",
    )
    advanced.add_argument(
        "--reconn-wait",
        metavar="s",
        default=1,
        type=int,
        help="""Connect mode / Zero-I/O mode (TCP only):
Wait x seconds between re-connects. (default: 1)

""",
    )
    advanced.add_argument(
        "--reconn-robin",
        metavar="port",
        default=[],
        type=_args_check_robin_ports,
        help="""Connect mode / Zero-I/O mode (TCP only):
If the remote server is not reachable or the connection
is interrupted and --reconn is specified, the client
will shuffle ports in round-robin mode to connect to.
Use comma separated string such as '80,81,82' or a range
of ports '80-100'.
Set --reconn to at least the number of ports to probe +1
This helps reverse shell to evade intrusiona prevention
systems that will cut your connection and block the
outbound port.
This is also useful in Connect or Zero-I/O mode to
figure out what outbound ports are allowed.

""",
    )
    advanced.add_argument(
        "-w",
        "--wait",
        metavar="s",
        default=False,
        type=int,
        help="""Connect mode (TCP only):
If a connection and stdin are idle for more than s sec,
then the connection is silently closed and the client
will exit. (default: wait forever).
Note: if --reconn is specified, the connection will be
re-opened.

""",
    )
    advanced.add_argument(
        "--udp-ping-init",
        action="store_true",
        default=False,
        help="""Connect mode / Zero-I/O mode (UDP only):
UDP is a stateless protocol unlike TCP, so no hand-
shake communication takes place and the client just
sends data to a server without being "accepted" by
the server first.
This means a server waiting for an UDP client to
connect to, is unable to send any data to the client,
before the client hasn't send data first. The server
simply doesn't know the IP address before an initial
connect.
The --udp-ping-init option instructs the client to send
one single initial ping packet to the server, so that it
is able to talk to the client.
This is the only way to make a UDP reverse shell work.
See --udp-ping-word for what char/string to send as
initial ping packet (default: '\\0')

""",
    )
    advanced.add_argument(
        "--udp-ping-intvl",
        metavar="s",
        default=False,
        type=int,
        help="""Connect mode / Zero-I/O mode (UDP only):
Instruct the UDP client to send ping intervalls every
s seconds. This allows you to restart your UDP server
and just wait for the client to report back in.
This might be handy for stable UDP reverse shells ;-)
See --udp-ping-word for what char/string to send as
initial ping packet (default: '\\0')

""",
    )
    advanced.add_argument(
        "--udp-ping-word",
        metavar="str",
        default="\0",
        type=str,
        help="""Connect mode / Zero-I/O mode (UDP only):
Change the default character '\\0' to use for upd ping.
Single character or strings are supported.

""",
    )
    advanced.add_argument(
        "--udp-ping-robin",
        metavar="port",
        default=[],
        type=_args_check_robin_ports,
        help="""Zero-I/O mode (UDP only):
Instruct the UDP client to shuffle the specified ports
in round-robin mode for a remote server to ping.
This might be handy to scan outbound allowed ports.
Use --udp-ping-intvl 0 to be faster.

""",
    )
    advanced.add_argument(
        "--safe-word",
        metavar="str",
        default=False,
        type=str,
        help="""All modes:
If %(prog)s is started with this argument, it will shut
down as soon as it receives the specified string.
The --rebind or --reconn options will not start it up
again. Use a very unique string to not have it shut down
accidentally by other input.
"""
        % ({"prog": APPNAME}),
    )
    misc.add_argument("-h", "--help", action="help", help="Show this help message and exit")
    misc.add_argument(
        "-V",
        "--version",
        action="version",
        version=get_version(),
        help="Show version information and exit",
    )

    # Retrieve arguments
    args = parser.parse_args()

    # Check mutually exclive arguments
    _args_check_mutually_exclusive(parser, args)

    # Connect mode and Zero-I/O mode require hostname and port to be set
    connect_mode = not (args.listen or args.zero or args.local)
    if (connect_mode or args.zero) and not (args.hostname):
        parser.print_usage()
        print(
            "%s: error: the following arguments are required: hostname" % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # TODO: deny unimplemented modes

    return args
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pwncat.get_version">
    <p>def <span class="ident">get_version</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>Return version information.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.get_version', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.get_version" class="source">
    <pre><code>def get_version():
    """Return version information."""
    return """%(prog)s: Version %(version)s (%(url)s) by %(author)s""" % (
        {"prog": APPNAME, "version": VERSION, "url": APPREPO, "author": "cytopia"}
    )
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pwncat.logtrace">
    <p>def <span class="ident">logtrace</span>(</p><p>self, message, *args, **kws)</p>
    </div>
    

    
  
    <div class="desc"><p>Set custom log level for TRACE.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.logtrace', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.logtrace" class="source">
    <pre><code>def logtrace(self, message, *args, **kws):
    """Set custom log level for TRACE."""
    if self.isEnabledFor(LOGLEVEL_TRACE_NUM):
        self._log(LOGLEVEL_TRACE_NUM, message, args, **kws)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pwncat.main">
    <p>def <span class="ident">main</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>Run the program.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.main', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.main" class="source">
    <pre><code>def main():
    """Run the program."""
    args = get_args()
    host = args.hostname if args.hostname is not None else "0.0.0.0"
    port = args.port

    # Set netcat options
    net_opts = {
        "bufsize": 1024,
        "backlog": 0,
        "nodns": args.nodns,
        "udp": args.udp,
        "http": args.http,
        "https": args.https,
        "keep_open": args.keep_open,
        "rebind": True if (type(args.rebind) is int and args.rebind == 0) else args.rebind,
        "reconn": True if (type(args.reconn) is int and args.reconn == 0) else args.reconn,
        "rebind_wait": args.rebind_wait,
        "reconn_wait": args.reconn_wait,
        "rebind_robin": args.rebind_robin,
        "reconn_robin": args.reconn_robin,
        "wait": args.wait,
        "udp_ping_init": args.udp_ping_init,
        "udp_ping_intvl": args.udp_ping_intvl,
        "udp_ping_word": args.udp_ping_word,
        "udp_ping_robing": args.udp_ping_robin,
        "safe_word": args.safe_word,
    }

    # Initialize logger
    if args.verbose == 0:
        loglevel = logging.ERROR
    elif args.verbose == 1:
        loglevel = logging.WARNING
    elif args.verbose == 2:
        loglevel = logging.INFO
    elif args.verbose == 3:
        loglevel = logging.DEBUG
    else:
        loglevel = LOGLEVEL_TRACE_NUM

    logging.addLevelName(LOGLEVEL_TRACE_NUM, "TRACE")
    logging.Logger.trace = logtrace
    logformat = "%(levelname)s:%(message)s"
    if args.verbose > 3:
        logformat = "%(levelname)s [%(threadName)s] %(funcName)s():%(message)s"
    logging.basicConfig(format=logformat, level=loglevel)

    # Initialize encoder
    encoder = StringEncoder()
    # Use command modulde
    if args.cmd:
        module_opts = {"executable": args.cmd}
        mod = NetcatPluginCommand(encoder, module_opts)
    # Use output module
    else:
        module_opts = {}
        module_opts["linefeed"] = "\r\n" if args.crlf else "\n"
        module_opts["input_timeout"] = TIMEOUT_READ_STDIN
        mod = NetcatPluginOutput(encoder, module_opts)

    # Run local port-forward
    # -> listen locally and forward traffic to remote (connect)
    if args.local:
        # TODO: Make the listen address optional!
        # Create listen and client instances
        # FIXME: As there is only one THREAD_TERMINATE, both instances will use it.
        #       this should go into the runner or so.
        srv_opts = net_opts.copy()
        srv_opts["reconn"] = True
        srv_opts["reconn_wait"] = 0
        lhost = args.local.split(":")[0]
        lport = int(args.local.split(":")[1])
        net_srv = NetcatServer(
            encoder, lhost, lport, TIMEOUT_RECV_SOCKET, TIMEOUT_RECV_SOCKET_RETRY, srv_opts
        )
        net_cli = NetcatClient(
            encoder, host, port, TIMEOUT_RECV_SOCKET, TIMEOUT_RECV_SOCKET_RETRY, net_opts
        )

        # Create Runner (the set_* funcs below are brainfuck and took me 1 hour to figure it out)
        run = Runner()

        # [srv] User-Client connects here, sends data and the Server takes it as input
        run.set_recv_generator(net_srv.receive)
        # [cli] Runner parses data from Server on to Proxy-Client, which sends/connect it further
        run.set_output_callback(net_cli.send)
        # [cli] Proxy-Client waits for response and receives data back
        run.set_input_generator(net_cli.receive)
        # [srv] Runner parses data from Proxy-Client onto Server, which sends/back to User-Client
        run.set_send_callback(net_srv.send)

        run.set_revc_generator_stop_function(object)
        run.set_input_generator_stop_function(object)
        # And finally run
        run.run()
    # Run server
    if args.listen:
        net = NetcatServer(
            encoder, host, port, TIMEOUT_RECV_SOCKET, TIMEOUT_RECV_SOCKET_RETRY, net_opts
        )
        run = Runner()
        run.set_recv_generator(net.receive)
        run.set_input_generator(mod.input_generator)
        run.set_send_callback(net.send)
        run.set_output_callback(mod.output_callback)

        run.set_revc_generator_stop_function(object)
        run.set_input_generator_stop_function(mod.stop)
        run.run()
    # Run client
    else:
        net = NetcatClient(
            encoder, host, port, TIMEOUT_RECV_SOCKET, TIMEOUT_RECV_SOCKET_RETRY, net_opts
        )
        run = Runner()
        run.set_recv_generator(net.receive)
        run.set_input_generator(mod.input_generator)
        run.set_send_callback(net.send)
        run.set_output_callback(mod.output_callback)
        if type(args.udp_ping_intvl) is int and args.udp_ping_intvl > 0:
            run.set_timed_action(args.udp_ping_intvl, net.send, "\x00")
        run.set_revc_generator_stop_function(object)
        run.set_input_generator_stop_function(object)
        run.run()
</code></pre>
  </div>
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="pwncat.ABC" class="name">class <span class="ident">ABC</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.ABC', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.ABC" class="source">
    <pre><code>class ABC(metaclass=ABCMeta):
    """Helper class that provides a standard way to create an ABC using
    inheritance.
    """
    __slots__ = ()
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pwncat.ABC">ABC</a></li>
          <li><a href="/builtins.object.ext">builtins.object</a></li>
          </ul>
      </div>
      </div>
      
      <div class="item">
      <p id="pwncat.AbstractNetcatPlugin" class="name">class <span class="ident">AbstractNetcatPlugin</span></p>
      
  
    <div class="desc"><p>Abstract class to for netcat plugins.</p>
<p>This is a skeleton that defines how the plugins for Netcat should look like.</p>
<p>The "input_generator" should constantly yield data received from sort sort of input
which could be user input, output from a shell command data from a socket.</p>
<p>The "data_callback" will apply some sort of action on the data received from a data_generator
which could be output to stdout, send it to the shell or to a socket.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractNetcatPlugin', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractNetcatPlugin" class="source">
    <pre><code>class AbstractNetcatPlugin(ABC):
    """
    Abstract class to for netcat plugins.

    This is a skeleton that defines how the plugins for Netcat should look like.

    The "input_generator" should constantly yield data received from sort sort of input
    which could be user input, output from a shell command data from a socket.

    The "data_callback" will apply some sort of action on the data received from a data_generator
    which could be output to stdout, send it to the shell or to a socket.
    """

    __metaclass__ = ABCMeta

    @abstractmethod
    def __init__(self, encoder, options={}):
        """Set specific options for this plugin.
        Args:
            encoder (object): An instance which provides "encode" and "decode" for string/bytes.
            options (dict):   Custom dictionary of options.
        """
        pass

    @abstractmethod
    def input_generator(self):
        """Implement a generator function which constantly yields data from some input."""
        while False:
            yield None

    @abstractmethod
    def output_callback(self, data):
        """Implement a callback which processes the input into some output."""
        print(data)

    @abstractmethod
    def stop(self):
        """Implement a stop method, which exits the instance."""
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pwncat.AbstractNetcatPlugin">AbstractNetcatPlugin</a></li>
          <li><a href="#pwncat.ABC">ABC</a></li>
          <li><a href="/builtins.object.ext">builtins.object</a></li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractNetcatPlugin.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, encoder, options={})</p>
    </div>
    

    
  
    <div class="desc"><p>Set specific options for this plugin.
Args:
    encoder (object): An instance which provides "encode" and "decode" for string/bytes.
    options (dict):   Custom dictionary of options.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractNetcatPlugin.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractNetcatPlugin.__init__" class="source">
    <pre><code>@abstractmethod
def __init__(self, encoder, options={}):
    """Set specific options for this plugin.
    Args:
        encoder (object): An instance which provides "encode" and "decode" for string/bytes.
        options (dict):   Custom dictionary of options.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractNetcatPlugin.input_generator">
    <p>def <span class="ident">input_generator</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Implement a generator function which constantly yields data from some input.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractNetcatPlugin.input_generator', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractNetcatPlugin.input_generator" class="source">
    <pre><code>@abstractmethod
def input_generator(self):
    """Implement a generator function which constantly yields data from some input."""
    while False:
        yield None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractNetcatPlugin.output_callback">
    <p>def <span class="ident">output_callback</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>Implement a callback which processes the input into some output.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractNetcatPlugin.output_callback', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractNetcatPlugin.output_callback" class="source">
    <pre><code>@abstractmethod
def output_callback(self, data):
    """Implement a callback which processes the input into some output."""
    print(data)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractNetcatPlugin.stop">
    <p>def <span class="ident">stop</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Implement a stop method, which exits the instance.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractNetcatPlugin.stop', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractNetcatPlugin.stop" class="source">
    <pre><code>@abstractmethod
def stop(self):
    """Implement a stop method, which exits the instance."""
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="pwncat.AbstractSocket" class="name">class <span class="ident">AbstractSocket</span></p>
      
  
    <div class="desc"><p>Abstract class which provides TCP, UDP and IPv4, IPv6 Socket funcionality.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractSocket', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractSocket" class="source">
    <pre><code>class AbstractSocket(object):
    """Abstract class which provides TCP, UDP and IPv4, IPv6 Socket funcionality."""

    sock = None  # server binding socket (until accept())
    conn = None  # client/server communication socket

    # The instance role must be 'server' or 'client' and
    # is used to determine how to reconnect broken connections.
    # Either listen again (tcp-only) or re-connect to upstream.
    role = None  # Must be 'server' or 'client'

    # Specify a float of seconds for the socket timeout.
    # A default of None means it is blocking.
    recv_timeout = None

    # If no data is received, the socket will timeout and counts subsequent timeouts
    # with no data received. If 'recv_timeout_retry' many timeouts occured, the socket
    # will stop reading data.
    # The internal counter is reset as soon as data is received again.
    recv_timeout_retry = 0

    options = {
        "bufsize": 1024,  # Receive buffer size
        "backlog": 0,  # Listen backlog
        "nodns": False,  # Do not resolve hostname
        "udp": False,  # Is TCP or UDP?
        "http": False,  # Use HTTP instead
        "https": False,  # Use HTTPS instead
        "keep_open": False,  # Keep server open for new connections
        "rebind": False,  # False (never), True (indefinite) or int for how many times to rebind
        "reconn": False,  # False (never), True (indefinite) or int for how many times to reconnect
        "rebind_wait": 0,  # Time in seconds between re-binds
        "reconn_wait": 0,  # Time in seconds between reconnects
        "rebind_robin": [],  # Ports to round-robind for bindings
        "reconn_robin": [],  # Ports to round-robin for reconnects
        "wait": False,  # Close client if it is idle for x many seconds
        "udp_ping_init": False,  # Send initial UDP ping packet
        "udp_ping_intvl": False,  # Interval in sec for UDP client to ping server
        "udp_ping_word": "\0",  # The char/string to send as UDP ping probe
        "udp_ping_robing": [],  # Ports to round-robing during UDP ping probes
        "safe_word": False,  # Once this is received, the application quits
    }

    # In case the server is running in UDP mode,
    # it must wait for the client to connect in order
    # to retrieve its addr and port in order to be able
    # to send data back to it.
    udp_client_addr = None
    udp_client_port = None

    # For client role only
    # Store the address and port of the remote server to connect to.
    # This is required for self.connect()
    remote_addr = None
    remote_addr = None

    # ------------------------------------------------------------------------------
    # Constructor / Destructor
    # ------------------------------------------------------------------------------
    def __init__(self, encoder, role, recv_timeout, recv_timeout_retry, options={}):
        """Constructor."""
        assert type(self) is not AbstractSocket, "AbstractSocket cannot be instantiated directly."
        assert role in ["server", "client"], "The role must be 'server' or 'client'."

        self.log = logging.getLogger(__name__)
        self.enc = encoder
        self.role = role

        self.recv_timeout = recv_timeout
        self.recv_timeout_retry = recv_timeout_retry

        # Ensure to provide all items (be explicit - currently helps to find bugs)
        for index in self.options:
            assert index in options, "Provided options are missing key: {}".format(index)
        # Ensure to only provide option itenms that are defined/exist (helps to find bugs)
        for index in options:
            assert index in self.options, "Provided an invalid option item"
            self.options[index] = options[index]

        # Register destructor
        atexit.register(self.__exit__)

    def __exit__(self):
        """Destructor."""

        self.log.trace("Closing 'sock' socket")
        self.__close_socket(self.sock)
        self.sock = None
        self.log.trace("Closing 'conn' socket")
        self.__close_socket(self.conn)
        self.conn = None

    # ------------------------------------------------------------------------------
    # Private Functions
    # ------------------------------------------------------------------------------
    def __close_socket(self, sock):
        """Close a socket."""
        try:
            # (SHUT_RD)   0 = Done receiving (disallows receiving)
            # (SHUT_WR)   1 = Done sending (disallows sending)
            # (SHUT_RDWR) 2 = Both
            sock.shutdown(socket.SHUT_RDWR)
        except (AttributeError, OSError, socket.error):
            self.log.trace("Could not shutdown socket")
            pass
        try:
            sock.close()
        except (AttributeError, OSError, socket.error):
            self.log.trace("Could not shutdown socket")

    def __reconnect(self):
        """Reconnect to a server if upstream has gone."""
        self.__close_socket(self.conn)
        self.__close_socket(self.sock)
        self.create_socket()
        self.conn = self.sock
        if not self.connect():
            self.__reconnect_to_server()

    def __reaccept_from_client(self):
        """Ensure the server is able to accept clients again, after current client has left."""
        # Only for server
        assert self.role == "server", "Only the role 'server' can accept connections."
        # Do not re-accept for UDP
        assert not self.options["udp"], "This should have been caught during arg check."

        # [NO] Never re-accept
        if type(self.options["reconn"]) is bool and not self.options["reconn"]:
            self.log.info("No automatic re-accept specified. Shutting down.")
            return False
        # [YES] Always re-accept indefinitely
        if type(self.options["reconn"]) is bool and self.options["reconn"]:
            self.log.info(
                "Re-accepting in {} sec (indefinitely)".format(self.options["reconn_wait"])
            )
            time.sleep(self.options["reconn_wait"])
            self.__close_socket(self.conn)
            self.accept()
            return True
        # [YES] Re-accept x many times
        if self.options["reconn"] > 0:
            self.log.info(
                "Re-accepting in {} sec ({} more times left)".format(
                    self.options["reconn_wait"], self.options["reconn"]
                )
            )
            self.options["reconn"] -= 1
            time.sleep(self.options["reconn_wait"])
            self.__close_socket(self.conn)
            self.accept()
            return True
        # [NO] Re-accept count is used up
        self.log.info("Re-accept count is used up. Shutting down.")
        return False

    def __reconnect_to_server(self):
        """Ensure the client re-connects to the remote server, if the remote server hang up."""
        # Only for Clients
        assert self.role == "client", "Only the role 'client' can re-connect."
        # Do not re-connect with UDP
        assert not self.options["udp"], "This should have been caught during arg check."

        # [NO] Never re-connect
        if type(self.options["reconn"]) is bool and not self.options["reconn"]:
            self.log.info("No automatic reconnect specified. Shutting down.")
            return False
        # [YES] Always re-connect indefinitely
        if type(self.options["reconn"]) is bool and self.options["reconn"]:
            self.log.info(
                "Reconnecting in {} sec (indefinitely)".format(self.options["reconn_wait"])
            )
            time.sleep(self.options["reconn_wait"])
            self.__reconnect()
            return True
        # [YES] Re-connect x many times
        if self.options["reconn"] > 0:
            self.log.info(
                "Reconnecting in {} sec ({} more times left)".format(
                    self.options["reconn_wait"], self.options["reconn"]
                )
            )
            self.options["reconn"] -= 1
            time.sleep(self.options["reconn_wait"])
            self.__reconnect()
            return True
        # [NO] Re-connect count is used up
        self.log.info("Reconnect count is used up. Shutting down.")
        return False

    # ------------------------------------------------------------------------------
    # Helper Functions
    # ------------------------------------------------------------------------------
    def gethostbyname(self, host):
        """Translate hostname into IP address."""
        if self.options["nodns"]:
            return host
        try:
            self.log.debug("Resolving hostname: {}".format(host))
            addr = socket.gethostbyname(host)
            self.log.debug("Resolved hostname:  {}".format(addr))
            return addr
        except socket.gaierror as error:
            self.log.error("Resolve Error: {}".format(error))
            sys.exit(1)

    def create_socket(self):
        """Create TCP or UDP socket."""
        try:
            if self.options["udp"]:
                self.log.debug("Creating UDP socket")
                self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            else:
                self.log.debug("Creating TCP socket")
                self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        except socket.error as error:
            self.log.error("Failed to create the socket: {}".format(error))
            sys.exit(1)
        # Get around the "[Errno 98] Address already in use" error, if the socket is still in wait
        # we instruct it to reuse the address anyway.
        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        # TODO: Not sure if SO_REUSEPORT is also required
        # try:
        #     self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)
        # except AttributeError:
        #     # Not available on Windows (and maybe others)
        #     self.log.debug("socket.SO_REUSEPORT is not available on your platform")

    def bind(self, addr, port):
        """Bind the socket to an address."""
        try:
            self.log.debug("Binding socket to {}:{}".format(addr, port))
            self.sock.bind((addr, port))
        except (OverflowError, OSError, socket.error) as error:
            self.log.error("Binding socket to {}:{} failed: {}".format(addr, port, error))
            sys.exit(1)

    def listen(self):
        """Listen for connections made to the socket."""
        try:
            self.log.debug("Listening with backlog={}".format(self.options["backlog"]))
            self.sock.listen(self.options["backlog"])
        except socket.error as error:
            self.log.error("Listening failed: {}".format(error))
            sys.exit(1)

    def accept(self):
        """Accept a connection."""
        try:
            self.log.debug("Waiting for TCP client")
            self.conn, client = self.sock.accept()
            addr, port = client
            self.log.info("Client connected from {}:{}".format(addr, port))
        except (socket.gaierror, socket.error) as error:
            self.log.error("Accept failed: {}".format(error))
            sys.exit(1)

    def connect(self):
        """Connect to a remote socket at given address and port (TCP-only)."""
        try:
            self.log.debug("Connecting to {}:{}".format(self.remote_addr, self.remote_port))
            self.sock.connect((self.remote_addr, self.remote_port))
            return True
        except socket.error as error:
            self.log.error(
                "Connecting to {}:{} failed: {}".format(self.remote_addr, self.remote_port, error)
            )
            return False

    # ------------------------------------------------------------------------------
    # Send / Receive Functions
    # ------------------------------------------------------------------------------
    def send(self, data):
        """Send data."""
        # In case of sending data back to an udp client we need to wait
        # until the client has first connected and told us its addr/port
        if self.options["udp"] and self.udp_client_addr is None and self.udp_client_port is None:
            self.log.info("Waiting for UDP client to connect")
            while self.udp_client_addr is None and self.udp_client_port is None:
                time.sleep(0.2)  # Less wastefull than using 'pass'

        curr = 0  # bytes send during one loop iteration
        send = 0  # total bytes send
        size = len(data)  # bytes of data that needs to be send
        data = self.enc.encode(data)
        assert size == len(data), "Encoding messed up string length, might need to do len() after."

        # Loop until all bytes have been send
        while send < size:
            try:
                self.log.trace("Trying to send {} bytes".format(size - send))
                if self.options["udp"]:
                    curr = self.conn.sendto(data, (self.udp_client_addr, self.udp_client_port))
                    send += curr
                else:
                    curr = self.conn.send(data)
                    send += curr
                if curr == 0:
                    self.log.error("No bytes send during loop round.")
                    return
                # Remove 'curr' many bytes from data for the next round
                data = data[curr:]
                self.log.trace("Send {} bytes ({} bytes remaining)".format(curr, size - send))
            except socket.error as error:
                if error.errno == socket.errno.EPIPE:
                    self.log.error("TODO:Add desc. Socket error({}): {}".format(error.errno, error))
                    return
                # Most likely nothing to see here??
                # FIXME: TODO: Need to re-accepd new client
                self.log.error("TODO:Add desc. Socket Error: {}".format(error))
                if self.role == "server":
                    if self.__reaccept_from_client():
                        continue
                self.log.warning("Shutdown")
                return
            except (OSError) as error:
                self.log.error("Socket OS Error: {}".format(error))
                return

    def receive(self):
        """Generator function to receive data endlessly by yielding it."""
        # Set current receive timeout
        self.conn.settimeout(self.recv_timeout)
        self.log.trace("Socket Timeout: {}".format(self.recv_timeout_retry))
        # Counts how many times we had a ready timeout for later to decide
        # if we exceeded maximum retires
        curr_recv_timeout_retry = 0
        while True:

            if self.conn is None:
                self.log.error("Socket is gone")
                return

            # Non-blocking socket with timeout. If the timeout threshold is hit,
            # it will throw an socket.timeout exception. This is required to see if other
            # threads have been terminated already.
            try:
                # https://manpages.debian.org/buster/manpages-dev/recv.2.en.html
                (byte, addr) = self.conn.recvfrom(self.options["bufsize"])
            except socket.timeout:
                # No other thread has terminated yet, and thus not asked us to quit.
                # so we can continue waiting for input on the socket
                if not THREAD_TERMINATE:
                    # TODO: Re-enable this for very verbose logging
                    # self.log.trace("SOCKET RECV: timeout. Waiting for input...")
                    continue
                # Other threads are done. Let's try to read a few more times before
                # returning and ending this function (might be data left)
                if curr_recv_timeout_retry < self.recv_timeout_retry:
                    self.log.trace("RECV EOF TIMEOUT: AND THREAD_TERMINATE REQUESTED")
                    curr_recv_timeout_retry += 1
                    continue
                return
            except socket.error as error:
                self.log.error("TODO: What happens here? Socket Receive Error: {}".format(error))
                return
            except AttributeError as error:
                self.log.error("TODO: What happens here?Attribute Receive Error: {}".format(error))
                return

            # We're receiving data again, so let's reset the retry/terminate counter
            curr_recv_timeout_retry = 0

            data = byte
            if not data:
                # Upstream (server or client) is gone. Do we reconnect or quit?
                self.log.warning("Upstream connection is gone")
                if self.role == "server":
                    if not self.__reaccept_from_client():
                        self.log.warning("Shutdown-1")
                        return
                if self.role == "client":
                    if not self.__reconnect_to_server():
                        self.log.warning("Shutdown-2")
                        return

            data = self.enc.decode(byte)
            self.log.trace("Received: {}".format(repr(data)))

            # If we're receiving data from a UDP client
            # we can firstly/finally set its addr/port in order
            # to send data back to it (see send() function)
            if self.options["udp"]:
                self.udp_client_addr, self.udp_client_port = addr
                # Avoid the noise on UDP connections to spam on every send
                if self.udp_client_addr is None or self.udp_client_port is None:
                    self.log.info(
                        "Client connected: {}:{}".format(self.udp_client_addr, self.udp_client_port)
                    )
                # Find for debug
                else:
                    self.log.debug(
                        "Client connected: {}:{}".format(self.udp_client_addr, self.udp_client_port)
                    )

            yield data
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pwncat.AbstractSocket">AbstractSocket</a></li>
          <li><a href="/builtins.object.ext">builtins.object</a></li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="pwncat.AbstractSocket.conn" class="name">var <span class="ident">conn</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.options" class="name">var <span class="ident">options</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.recv_timeout" class="name">var <span class="ident">recv_timeout</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.recv_timeout_retry" class="name">var <span class="ident">recv_timeout_retry</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.remote_addr" class="name">var <span class="ident">remote_addr</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.role" class="name">var <span class="ident">role</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.sock" class="name">var <span class="ident">sock</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.udp_client_addr" class="name">var <span class="ident">udp_client_addr</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.udp_client_port" class="name">var <span class="ident">udp_client_port</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractSocket.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, encoder, role, recv_timeout, recv_timeout_retry, options={})</p>
    </div>
    

    
  
    <div class="desc"><p>Constructor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractSocket.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractSocket.__init__" class="source">
    <pre><code>def __init__(self, encoder, role, recv_timeout, recv_timeout_retry, options={}):
    """Constructor."""
    assert type(self) is not AbstractSocket, "AbstractSocket cannot be instantiated directly."
    assert role in ["server", "client"], "The role must be 'server' or 'client'."
    self.log = logging.getLogger(__name__)
    self.enc = encoder
    self.role = role
    self.recv_timeout = recv_timeout
    self.recv_timeout_retry = recv_timeout_retry
    # Ensure to provide all items (be explicit - currently helps to find bugs)
    for index in self.options:
        assert index in options, "Provided options are missing key: {}".format(index)
    # Ensure to only provide option itenms that are defined/exist (helps to find bugs)
    for index in options:
        assert index in self.options, "Provided an invalid option item"
        self.options[index] = options[index]
    # Register destructor
    atexit.register(self.__exit__)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractSocket.accept">
    <p>def <span class="ident">accept</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Accept a connection.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractSocket.accept', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractSocket.accept" class="source">
    <pre><code>def accept(self):
    """Accept a connection."""
    try:
        self.log.debug("Waiting for TCP client")
        self.conn, client = self.sock.accept()
        addr, port = client
        self.log.info("Client connected from {}:{}".format(addr, port))
    except (socket.gaierror, socket.error) as error:
        self.log.error("Accept failed: {}".format(error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractSocket.bind">
    <p>def <span class="ident">bind</span>(</p><p>self, addr, port)</p>
    </div>
    

    
  
    <div class="desc"><p>Bind the socket to an address.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractSocket.bind', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractSocket.bind" class="source">
    <pre><code>def bind(self, addr, port):
    """Bind the socket to an address."""
    try:
        self.log.debug("Binding socket to {}:{}".format(addr, port))
        self.sock.bind((addr, port))
    except (OverflowError, OSError, socket.error) as error:
        self.log.error("Binding socket to {}:{} failed: {}".format(addr, port, error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractSocket.connect">
    <p>def <span class="ident">connect</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Connect to a remote socket at given address and port (TCP-only).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractSocket.connect', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractSocket.connect" class="source">
    <pre><code>def connect(self):
    """Connect to a remote socket at given address and port (TCP-only)."""
    try:
        self.log.debug("Connecting to {}:{}".format(self.remote_addr, self.remote_port))
        self.sock.connect((self.remote_addr, self.remote_port))
        return True
    except socket.error as error:
        self.log.error(
            "Connecting to {}:{} failed: {}".format(self.remote_addr, self.remote_port, error)
        )
        return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractSocket.create_socket">
    <p>def <span class="ident">create_socket</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Create TCP or UDP socket.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractSocket.create_socket', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractSocket.create_socket" class="source">
    <pre><code>def create_socket(self):
    """Create TCP or UDP socket."""
    try:
        if self.options["udp"]:
            self.log.debug("Creating UDP socket")
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        else:
            self.log.debug("Creating TCP socket")
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    except socket.error as error:
        self.log.error("Failed to create the socket: {}".format(error))
        sys.exit(1)
    # Get around the "[Errno 98] Address already in use" error, if the socket is still in wait
    # we instruct it to reuse the address anyway.
    self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractSocket.gethostbyname">
    <p>def <span class="ident">gethostbyname</span>(</p><p>self, host)</p>
    </div>
    

    
  
    <div class="desc"><p>Translate hostname into IP address.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractSocket.gethostbyname', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractSocket.gethostbyname" class="source">
    <pre><code>def gethostbyname(self, host):
    """Translate hostname into IP address."""
    if self.options["nodns"]:
        return host
    try:
        self.log.debug("Resolving hostname: {}".format(host))
        addr = socket.gethostbyname(host)
        self.log.debug("Resolved hostname:  {}".format(addr))
        return addr
    except socket.gaierror as error:
        self.log.error("Resolve Error: {}".format(error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractSocket.listen">
    <p>def <span class="ident">listen</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Listen for connections made to the socket.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractSocket.listen', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractSocket.listen" class="source">
    <pre><code>def listen(self):
    """Listen for connections made to the socket."""
    try:
        self.log.debug("Listening with backlog={}".format(self.options["backlog"]))
        self.sock.listen(self.options["backlog"])
    except socket.error as error:
        self.log.error("Listening failed: {}".format(error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractSocket.receive">
    <p>def <span class="ident">receive</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Generator function to receive data endlessly by yielding it.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractSocket.receive', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractSocket.receive" class="source">
    <pre><code>def receive(self):
    """Generator function to receive data endlessly by yielding it."""
    # Set current receive timeout
    self.conn.settimeout(self.recv_timeout)
    self.log.trace("Socket Timeout: {}".format(self.recv_timeout_retry))
    # Counts how many times we had a ready timeout for later to decide
    # if we exceeded maximum retires
    curr_recv_timeout_retry = 0
    while True:
        if self.conn is None:
            self.log.error("Socket is gone")
            return
        # Non-blocking socket with timeout. If the timeout threshold is hit,
        # it will throw an socket.timeout exception. This is required to see if other
        # threads have been terminated already.
        try:
            # https://manpages.debian.org/buster/manpages-dev/recv.2.en.html
            (byte, addr) = self.conn.recvfrom(self.options["bufsize"])
        except socket.timeout:
            # No other thread has terminated yet, and thus not asked us to quit.
            # so we can continue waiting for input on the socket
            if not THREAD_TERMINATE:
                # TODO: Re-enable this for very verbose logging
                # self.log.trace("SOCKET RECV: timeout. Waiting for input...")
                continue
            # Other threads are done. Let's try to read a few more times before
            # returning and ending this function (might be data left)
            if curr_recv_timeout_retry < self.recv_timeout_retry:
                self.log.trace("RECV EOF TIMEOUT: AND THREAD_TERMINATE REQUESTED")
                curr_recv_timeout_retry += 1
                continue
            return
        except socket.error as error:
            self.log.error("TODO: What happens here? Socket Receive Error: {}".format(error))
            return
        except AttributeError as error:
            self.log.error("TODO: What happens here?Attribute Receive Error: {}".format(error))
            return
        # We're receiving data again, so let's reset the retry/terminate counter
        curr_recv_timeout_retry = 0
        data = byte
        if not data:
            # Upstream (server or client) is gone. Do we reconnect or quit?
            self.log.warning("Upstream connection is gone")
            if self.role == "server":
                if not self.__reaccept_from_client():
                    self.log.warning("Shutdown-1")
                    return
            if self.role == "client":
                if not self.__reconnect_to_server():
                    self.log.warning("Shutdown-2")
                    return
        data = self.enc.decode(byte)
        self.log.trace("Received: {}".format(repr(data)))
        # If we're receiving data from a UDP client
        # we can firstly/finally set its addr/port in order
        # to send data back to it (see send() function)
        if self.options["udp"]:
            self.udp_client_addr, self.udp_client_port = addr
            # Avoid the noise on UDP connections to spam on every send
            if self.udp_client_addr is None or self.udp_client_port is None:
                self.log.info(
                    "Client connected: {}:{}".format(self.udp_client_addr, self.udp_client_port)
                )
            # Find for debug
            else:
                self.log.debug(
                    "Client connected: {}:{}".format(self.udp_client_addr, self.udp_client_port)
                )
        yield data
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractSocket.send">
    <p>def <span class="ident">send</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>Send data.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractSocket.send', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractSocket.send" class="source">
    <pre><code>def send(self, data):
    """Send data."""
    # In case of sending data back to an udp client we need to wait
    # until the client has first connected and told us its addr/port
    if self.options["udp"] and self.udp_client_addr is None and self.udp_client_port is None:
        self.log.info("Waiting for UDP client to connect")
        while self.udp_client_addr is None and self.udp_client_port is None:
            time.sleep(0.2)  # Less wastefull than using 'pass'
    curr = 0  # bytes send during one loop iteration
    send = 0  # total bytes send
    size = len(data)  # bytes of data that needs to be send
    data = self.enc.encode(data)
    assert size == len(data), "Encoding messed up string length, might need to do len() after."
    # Loop until all bytes have been send
    while send < size:
        try:
            self.log.trace("Trying to send {} bytes".format(size - send))
            if self.options["udp"]:
                curr = self.conn.sendto(data, (self.udp_client_addr, self.udp_client_port))
                send += curr
            else:
                curr = self.conn.send(data)
                send += curr
            if curr == 0:
                self.log.error("No bytes send during loop round.")
                return
            # Remove 'curr' many bytes from data for the next round
            data = data[curr:]
            self.log.trace("Send {} bytes ({} bytes remaining)".format(curr, size - send))
        except socket.error as error:
            if error.errno == socket.errno.EPIPE:
                self.log.error("TODO:Add desc. Socket error({}): {}".format(error.errno, error))
                return
            # Most likely nothing to see here??
            # FIXME: TODO: Need to re-accepd new client
            self.log.error("TODO:Add desc. Socket Error: {}".format(error))
            if self.role == "server":
                if self.__reaccept_from_client():
                    continue
            self.log.warning("Shutdown")
            return
        except (OSError) as error:
            self.log.error("Socket OS Error: {}".format(error))
            return
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pwncat.AbstractSocket.enc" class="name">var <span class="ident">enc</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.log" class="name">var <span class="ident">log</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.recv_timeout" class="name">var <span class="ident">recv_timeout</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.recv_timeout_retry" class="name">var <span class="ident">recv_timeout_retry</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.role" class="name">var <span class="ident">role</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="pwncat.NetcatClient" class="name">class <span class="ident">NetcatClient</span></p>
      
  
    <div class="desc"><p>Netcat Client implementation.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatClient', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatClient" class="source">
    <pre><code>class NetcatClient(AbstractSocket):
    """Netcat Client implementation."""

    def __init__(self, encoder, host, port, recv_timeout, recv_timeout_retry, options={}):
        """Construct a connecting clientt."""
        super(NetcatClient, self).__init__(
            encoder, "client", recv_timeout, recv_timeout_retry, options
        )

        # Setup client
        addr = self.gethostbyname(host)
        self.create_socket()
        self.conn = self.sock
        if self.options["udp"]:
            self.udp_client_addr = addr
            self.udp_client_port = port
        else:
            self.remote_addr = addr
            self.remote_port = port
            if not self.connect():
                sys.exit(1)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pwncat.NetcatClient">NetcatClient</a></li>
          <li><a href="#pwncat.AbstractSocket">AbstractSocket</a></li>
          <li><a href="/builtins.object.ext">builtins.object</a></li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="pwncat.NetcatClient.options" class="name">var <span class="ident">options</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatClient.recv_timeout" class="name">var <span class="ident">recv_timeout</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatClient.recv_timeout_retry" class="name">var <span class="ident">recv_timeout_retry</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatClient.remote_addr" class="name">var <span class="ident">remote_addr</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatClient.role" class="name">var <span class="ident">role</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatClient.sock" class="name">var <span class="ident">sock</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatClient.udp_client_addr" class="name">var <span class="ident">udp_client_addr</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatClient.udp_client_port" class="name">var <span class="ident">udp_client_port</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatClient.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, encoder, host, port, recv_timeout, recv_timeout_retry, options={})</p>
    </div>
    

    
  
    <div class="desc"><p>Construct a connecting clientt.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatClient.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatClient.__init__" class="source">
    <pre><code>def __init__(self, encoder, host, port, recv_timeout, recv_timeout_retry, options={}):
    """Construct a connecting clientt."""
    super(NetcatClient, self).__init__(
        encoder, "client", recv_timeout, recv_timeout_retry, options
    )
    # Setup client
    addr = self.gethostbyname(host)
    self.create_socket()
    self.conn = self.sock
    if self.options["udp"]:
        self.udp_client_addr = addr
        self.udp_client_port = port
    else:
        self.remote_addr = addr
        self.remote_port = port
        if not self.connect():
            sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatClient.accept">
    <p>def <span class="ident">accept</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Accept a connection.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatClient.accept', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatClient.accept" class="source">
    <pre><code>def accept(self):
    """Accept a connection."""
    try:
        self.log.debug("Waiting for TCP client")
        self.conn, client = self.sock.accept()
        addr, port = client
        self.log.info("Client connected from {}:{}".format(addr, port))
    except (socket.gaierror, socket.error) as error:
        self.log.error("Accept failed: {}".format(error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatClient.bind">
    <p>def <span class="ident">bind</span>(</p><p>self, addr, port)</p>
    </div>
    

    
  
    <div class="desc"><p>Bind the socket to an address.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatClient.bind', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatClient.bind" class="source">
    <pre><code>def bind(self, addr, port):
    """Bind the socket to an address."""
    try:
        self.log.debug("Binding socket to {}:{}".format(addr, port))
        self.sock.bind((addr, port))
    except (OverflowError, OSError, socket.error) as error:
        self.log.error("Binding socket to {}:{} failed: {}".format(addr, port, error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatClient.connect">
    <p>def <span class="ident">connect</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Connect to a remote socket at given address and port (TCP-only).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatClient.connect', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatClient.connect" class="source">
    <pre><code>def connect(self):
    """Connect to a remote socket at given address and port (TCP-only)."""
    try:
        self.log.debug("Connecting to {}:{}".format(self.remote_addr, self.remote_port))
        self.sock.connect((self.remote_addr, self.remote_port))
        return True
    except socket.error as error:
        self.log.error(
            "Connecting to {}:{} failed: {}".format(self.remote_addr, self.remote_port, error)
        )
        return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatClient.create_socket">
    <p>def <span class="ident">create_socket</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Create TCP or UDP socket.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatClient.create_socket', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatClient.create_socket" class="source">
    <pre><code>def create_socket(self):
    """Create TCP or UDP socket."""
    try:
        if self.options["udp"]:
            self.log.debug("Creating UDP socket")
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        else:
            self.log.debug("Creating TCP socket")
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    except socket.error as error:
        self.log.error("Failed to create the socket: {}".format(error))
        sys.exit(1)
    # Get around the "[Errno 98] Address already in use" error, if the socket is still in wait
    # we instruct it to reuse the address anyway.
    self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatClient.gethostbyname">
    <p>def <span class="ident">gethostbyname</span>(</p><p>self, host)</p>
    </div>
    

    
  
    <div class="desc"><p>Translate hostname into IP address.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatClient.gethostbyname', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatClient.gethostbyname" class="source">
    <pre><code>def gethostbyname(self, host):
    """Translate hostname into IP address."""
    if self.options["nodns"]:
        return host
    try:
        self.log.debug("Resolving hostname: {}".format(host))
        addr = socket.gethostbyname(host)
        self.log.debug("Resolved hostname:  {}".format(addr))
        return addr
    except socket.gaierror as error:
        self.log.error("Resolve Error: {}".format(error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatClient.listen">
    <p>def <span class="ident">listen</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Listen for connections made to the socket.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatClient.listen', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatClient.listen" class="source">
    <pre><code>def listen(self):
    """Listen for connections made to the socket."""
    try:
        self.log.debug("Listening with backlog={}".format(self.options["backlog"]))
        self.sock.listen(self.options["backlog"])
    except socket.error as error:
        self.log.error("Listening failed: {}".format(error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatClient.receive">
    <p>def <span class="ident">receive</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Generator function to receive data endlessly by yielding it.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatClient.receive', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatClient.receive" class="source">
    <pre><code>def receive(self):
    """Generator function to receive data endlessly by yielding it."""
    # Set current receive timeout
    self.conn.settimeout(self.recv_timeout)
    self.log.trace("Socket Timeout: {}".format(self.recv_timeout_retry))
    # Counts how many times we had a ready timeout for later to decide
    # if we exceeded maximum retires
    curr_recv_timeout_retry = 0
    while True:
        if self.conn is None:
            self.log.error("Socket is gone")
            return
        # Non-blocking socket with timeout. If the timeout threshold is hit,
        # it will throw an socket.timeout exception. This is required to see if other
        # threads have been terminated already.
        try:
            # https://manpages.debian.org/buster/manpages-dev/recv.2.en.html
            (byte, addr) = self.conn.recvfrom(self.options["bufsize"])
        except socket.timeout:
            # No other thread has terminated yet, and thus not asked us to quit.
            # so we can continue waiting for input on the socket
            if not THREAD_TERMINATE:
                # TODO: Re-enable this for very verbose logging
                # self.log.trace("SOCKET RECV: timeout. Waiting for input...")
                continue
            # Other threads are done. Let's try to read a few more times before
            # returning and ending this function (might be data left)
            if curr_recv_timeout_retry < self.recv_timeout_retry:
                self.log.trace("RECV EOF TIMEOUT: AND THREAD_TERMINATE REQUESTED")
                curr_recv_timeout_retry += 1
                continue
            return
        except socket.error as error:
            self.log.error("TODO: What happens here? Socket Receive Error: {}".format(error))
            return
        except AttributeError as error:
            self.log.error("TODO: What happens here?Attribute Receive Error: {}".format(error))
            return
        # We're receiving data again, so let's reset the retry/terminate counter
        curr_recv_timeout_retry = 0
        data = byte
        if not data:
            # Upstream (server or client) is gone. Do we reconnect or quit?
            self.log.warning("Upstream connection is gone")
            if self.role == "server":
                if not self.__reaccept_from_client():
                    self.log.warning("Shutdown-1")
                    return
            if self.role == "client":
                if not self.__reconnect_to_server():
                    self.log.warning("Shutdown-2")
                    return
        data = self.enc.decode(byte)
        self.log.trace("Received: {}".format(repr(data)))
        # If we're receiving data from a UDP client
        # we can firstly/finally set its addr/port in order
        # to send data back to it (see send() function)
        if self.options["udp"]:
            self.udp_client_addr, self.udp_client_port = addr
            # Avoid the noise on UDP connections to spam on every send
            if self.udp_client_addr is None or self.udp_client_port is None:
                self.log.info(
                    "Client connected: {}:{}".format(self.udp_client_addr, self.udp_client_port)
                )
            # Find for debug
            else:
                self.log.debug(
                    "Client connected: {}:{}".format(self.udp_client_addr, self.udp_client_port)
                )
        yield data
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatClient.send">
    <p>def <span class="ident">send</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>Send data.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatClient.send', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatClient.send" class="source">
    <pre><code>def send(self, data):
    """Send data."""
    # In case of sending data back to an udp client we need to wait
    # until the client has first connected and told us its addr/port
    if self.options["udp"] and self.udp_client_addr is None and self.udp_client_port is None:
        self.log.info("Waiting for UDP client to connect")
        while self.udp_client_addr is None and self.udp_client_port is None:
            time.sleep(0.2)  # Less wastefull than using 'pass'
    curr = 0  # bytes send during one loop iteration
    send = 0  # total bytes send
    size = len(data)  # bytes of data that needs to be send
    data = self.enc.encode(data)
    assert size == len(data), "Encoding messed up string length, might need to do len() after."
    # Loop until all bytes have been send
    while send < size:
        try:
            self.log.trace("Trying to send {} bytes".format(size - send))
            if self.options["udp"]:
                curr = self.conn.sendto(data, (self.udp_client_addr, self.udp_client_port))
                send += curr
            else:
                curr = self.conn.send(data)
                send += curr
            if curr == 0:
                self.log.error("No bytes send during loop round.")
                return
            # Remove 'curr' many bytes from data for the next round
            data = data[curr:]
            self.log.trace("Send {} bytes ({} bytes remaining)".format(curr, size - send))
        except socket.error as error:
            if error.errno == socket.errno.EPIPE:
                self.log.error("TODO:Add desc. Socket error({}): {}".format(error.errno, error))
                return
            # Most likely nothing to see here??
            # FIXME: TODO: Need to re-accepd new client
            self.log.error("TODO:Add desc. Socket Error: {}".format(error))
            if self.role == "server":
                if self.__reaccept_from_client():
                    continue
            self.log.warning("Shutdown")
            return
        except (OSError) as error:
            self.log.error("Socket OS Error: {}".format(error))
            return
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pwncat.NetcatClient.conn" class="name">var <span class="ident">conn</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="pwncat.NetcatPluginCommand" class="name">class <span class="ident">NetcatPluginCommand</span></p>
      
  
    <div class="desc"><p>Implement command execution functionality.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatPluginCommand', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatPluginCommand" class="source">
    <pre><code>class NetcatPluginCommand(AbstractNetcatPlugin):
    """Implement command execution functionality."""

    executable = None

    # ------------------------------------------------------------------------------
    # Constructor / Destructor
    # ------------------------------------------------------------------------------
    def __init__(self, encoder, options={}):
        """Set specific options for this plugin."""
        self.log = logging.getLogger(__name__)
        self.enc = encoder
        assert "executable" in options
        self.log.debug("Setting '{}' as executable".format(options["executable"]))
        self.executable = options["executable"]

        # Open executable to wait for commands
        env = os.environ.copy()
        try:
            self.p = Popen(
                # TODO: should I also use 'bufsize=1'?
                self.executable,
                stdin=PIPE,
                stdout=PIPE,
                stderr=subprocess.STDOUT,
                shell=False,
                env=env,
            )
        except FileNotFoundError:
            self.log.error("Specified executable '{}' not found".format(self.executable))
            sys.exit(1)

        # Define destructor
        atexit.register(self.__exit__)

    def __exit__(self):
        """Destructor."""
        self.log.trace("Killing executable: {} with pid {}".format(self.executable, self.p.pid))
        self.p.kill()

    # ------------------------------------------------------------------------------
    # Public Functions
    # ------------------------------------------------------------------------------
    def stop(self):
        """Stop function that can be called externally to close this instance."""
        global THREAD_TERMINATE
        THREAD_TERMINATE = True
        self.log.trace("[NetcatPluginCommand] subprocess.kill() was raised by stop() function")
        self.p.kill()

    def __set_input_timeout(self, timeout=0.1):
        """Throw a TimeOutError Exception for sys.stdin (Linux only)."""
        # select((rlist, wlist, xlist, timeout)
        # rlist: wait until ready for reading
        # wlist: wait until ready for writing
        # xlist: wait for an "exceptional condition"
        i, o, e = select.select([self.p.stdout], [], [], timeout)
        if not i:
            raise BaseException("timed out")

    def input_generator(self):
        """Constantly ask for input."""
        while True:
            self.log.trace("Reading command output")
            # TODO: non-blocking read does not seem to work or?
            # try:
            # self.__set_input_timeout(timeout=1.5)
            data = self.p.stdout.readline()  # Much better performance than self.p.read(1)
            self.log.trace(data)
            # except BaseException:
            #    if THREAD_TERMINATE:
            #        return
            #    # No input, just check again
            #    #self.p.stdout.flush()
            #    continue
            data = self.enc.decode(data)
            self.log.trace("Command output: {}".format(data))
            if not data:
                self.log.trace("Command output was empty. Exiting loop.")
                break
            yield data

    def output_callback(self, data):
        """Send data received to stdin (command input)."""
        data = self.enc.encode(data)
        self.log.trace("Appending to stdin: {}".format(data))
        self.p.stdin.write(data)
        self.p.stdin.flush()
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pwncat.NetcatPluginCommand">NetcatPluginCommand</a></li>
          <li><a href="#pwncat.AbstractNetcatPlugin">AbstractNetcatPlugin</a></li>
          <li><a href="#pwncat.ABC">ABC</a></li>
          <li><a href="/builtins.object.ext">builtins.object</a></li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="pwncat.NetcatPluginCommand.executable" class="name">var <span class="ident">executable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatPluginCommand.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, encoder, options={})</p>
    </div>
    

    
  
    <div class="desc"><p>Set specific options for this plugin.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatPluginCommand.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatPluginCommand.__init__" class="source">
    <pre><code>def __init__(self, encoder, options={}):
    """Set specific options for this plugin."""
    self.log = logging.getLogger(__name__)
    self.enc = encoder
    assert "executable" in options
    self.log.debug("Setting '{}' as executable".format(options["executable"]))
    self.executable = options["executable"]
    # Open executable to wait for commands
    env = os.environ.copy()
    try:
        self.p = Popen(
            # TODO: should I also use 'bufsize=1'?
            self.executable,
            stdin=PIPE,
            stdout=PIPE,
            stderr=subprocess.STDOUT,
            shell=False,
            env=env,
        )
    except FileNotFoundError:
        self.log.error("Specified executable '{}' not found".format(self.executable))
        sys.exit(1)
    # Define destructor
    atexit.register(self.__exit__)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatPluginCommand.input_generator">
    <p>def <span class="ident">input_generator</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Constantly ask for input.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatPluginCommand.input_generator', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatPluginCommand.input_generator" class="source">
    <pre><code>def input_generator(self):
    """Constantly ask for input."""
    while True:
        self.log.trace("Reading command output")
        # TODO: non-blocking read does not seem to work or?
        # try:
        # self.__set_input_timeout(timeout=1.5)
        data = self.p.stdout.readline()  # Much better performance than self.p.read(1)
        self.log.trace(data)
        # except BaseException:
        #    if THREAD_TERMINATE:
        #        return
        #    # No input, just check again
        #    #self.p.stdout.flush()
        #    continue
        data = self.enc.decode(data)
        self.log.trace("Command output: {}".format(data))
        if not data:
            self.log.trace("Command output was empty. Exiting loop.")
            break
        yield data
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatPluginCommand.output_callback">
    <p>def <span class="ident">output_callback</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>Send data received to stdin (command input).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatPluginCommand.output_callback', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatPluginCommand.output_callback" class="source">
    <pre><code>def output_callback(self, data):
    """Send data received to stdin (command input)."""
    data = self.enc.encode(data)
    self.log.trace("Appending to stdin: {}".format(data))
    self.p.stdin.write(data)
    self.p.stdin.flush()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatPluginCommand.stop">
    <p>def <span class="ident">stop</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Stop function that can be called externally to close this instance.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatPluginCommand.stop', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatPluginCommand.stop" class="source">
    <pre><code>def stop(self):
    """Stop function that can be called externally to close this instance."""
    global THREAD_TERMINATE
    THREAD_TERMINATE = True
    self.log.trace("[NetcatPluginCommand] subprocess.kill() was raised by stop() function")
    self.p.kill()
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pwncat.NetcatPluginCommand.enc" class="name">var <span class="ident">enc</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatPluginCommand.executable" class="name">var <span class="ident">executable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatPluginCommand.log" class="name">var <span class="ident">log</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="pwncat.NetcatPluginOutput" class="name">class <span class="ident">NetcatPluginOutput</span></p>
      
  
    <div class="desc"><p>Implement basic input/output plugin.</p>
<p>This plugin provides a generator which continuously reads from stdin
(non-blocking on POSIX and blocking on windows) as well as a
callback that writes to stdout.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatPluginOutput', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatPluginOutput" class="source">
    <pre><code>class NetcatPluginOutput(AbstractNetcatPlugin):
    """Implement basic input/output plugin.

    This plugin provides a generator which continuously reads from stdin
    (non-blocking on POSIX and blocking on windows) as well as a
    callback that writes to stdout.
    """

    # Line feeds to use for user input
    linefeed = "\n"

    # Non-blocking read from stdin achieved via timeout.
    # Specify timeout in seconds.
    input_timeout = None

    # ------------------------------------------------------------------------------
    # Constructor / Destructor
    # ------------------------------------------------------------------------------
    def __init__(self, encoder, options={}):
        """Set specific options for this plugin."""
        self.log = logging.getLogger(__name__)
        self.enc = encoder

        assert "input_timeout" in options, "Error, 'input_timeout' must be set."
        if "input_timeout" in options:
            self.input_timeout = options["input_timeout"]
        if "linefeed" in options:
            self.linefeed = options["linefeed"]

    # ------------------------------------------------------------------------------
    # Private Functions
    # ------------------------------------------------------------------------------
    def __use_linefeeds(self, data):
        """Ensure the user input has the desired linefeeds --crlf or not."""
        if data.endswith("\r\n"):
            data = data[:-2]
        elif data.endswith("\n") or data.endswith("\r"):
            data = data[:-1]
        data += self.linefeed
        return data

    def __set_input_timeout(self):
        """Throws a catchable BaseException for sys.stdin after timeout (Linux only)."""
        i, o, e = select.select([sys.stdin], [], [], self.input_timeout)
        if not i:
            raise BaseException("timed out")

    # ------------------------------------------------------------------------------
    # Public Functions
    # ------------------------------------------------------------------------------
    def stop(self):
        global THREAD_TERMINATE
        """Stop function that can be called externally to close this instance."""
        self.log.trace("[NetcatOutputCommand] pass was raised by stop() function")
        THREAD_TERMINATE = True

    def input_generator(self):
        """Constantly ask for user input."""
        # https://stackoverflow.com/questions/1450393/#38670261
        # while True: line = sys.stdin.readline() <- reads a whole line (faster)
        # for line in sys.stdin.readlin():        <- reads one byte at a time
        while True:
            if THREAD_TERMINATE:
                return
            try:
                # TODO: select() does not work for windows on stdin/stdout
                if os.name != "nt":
                    self.__set_input_timeout()
                line = sys.stdin.readline()
            except BaseException:
                # When using select() with timeout, we don't have any input
                # at this point and simply continue the loop or quit if
                # a terminate request has been made by other threads.
                if THREAD_TERMINATE:
                    self.log.trace("STDIN: terminate")
                    return
                # TODO: Re-enable this for very verbose logging
                # self.log.trace("STDIN: timeout. Waiting for input...")
                continue
            if line:
                self.log.trace("Yielding stdin")
                yield self.__use_linefeeds(line)
            # EOF or <Ctrl>+<d>
            else:
                # DO NOT RETURN HERE BLINDLY, THE UPSTREAM CONNECTION MUST GO FIRST!
                if THREAD_TERMINATE:
                    self.log.trace("No more input generated, quitting.")
                    return
                # TODO: Re-enable this for very verbose logging
                # self.log.trace("STDIN: Reached EOF, repeating")

    def output_callback(self, data):
        """Print received data to stdout."""
        print(data, end="")
        sys.stdout.flush()  # TODO:Is this required? What does this do? Test this!
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pwncat.NetcatPluginOutput">NetcatPluginOutput</a></li>
          <li><a href="#pwncat.AbstractNetcatPlugin">AbstractNetcatPlugin</a></li>
          <li><a href="#pwncat.ABC">ABC</a></li>
          <li><a href="/builtins.object.ext">builtins.object</a></li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="pwncat.NetcatPluginOutput.input_timeout" class="name">var <span class="ident">input_timeout</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatPluginOutput.linefeed" class="name">var <span class="ident">linefeed</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatPluginOutput.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, encoder, options={})</p>
    </div>
    

    
  
    <div class="desc"><p>Set specific options for this plugin.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatPluginOutput.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatPluginOutput.__init__" class="source">
    <pre><code>def __init__(self, encoder, options={}):
    """Set specific options for this plugin."""
    self.log = logging.getLogger(__name__)
    self.enc = encoder
    assert "input_timeout" in options, "Error, 'input_timeout' must be set."
    if "input_timeout" in options:
        self.input_timeout = options["input_timeout"]
    if "linefeed" in options:
        self.linefeed = options["linefeed"]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatPluginOutput.input_generator">
    <p>def <span class="ident">input_generator</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Constantly ask for user input.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatPluginOutput.input_generator', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatPluginOutput.input_generator" class="source">
    <pre><code>def input_generator(self):
    """Constantly ask for user input."""
    # https://stackoverflow.com/questions/1450393/#38670261
    # while True: line = sys.stdin.readline() <- reads a whole line (faster)
    # for line in sys.stdin.readlin():        <- reads one byte at a time
    while True:
        if THREAD_TERMINATE:
            return
        try:
            # TODO: select() does not work for windows on stdin/stdout
            if os.name != "nt":
                self.__set_input_timeout()
            line = sys.stdin.readline()
        except BaseException:
            # When using select() with timeout, we don't have any input
            # at this point and simply continue the loop or quit if
            # a terminate request has been made by other threads.
            if THREAD_TERMINATE:
                self.log.trace("STDIN: terminate")
                return
            # TODO: Re-enable this for very verbose logging
            # self.log.trace("STDIN: timeout. Waiting for input...")
            continue
        if line:
            self.log.trace("Yielding stdin")
            yield self.__use_linefeeds(line)
        # EOF or <Ctrl>+<d>
        else:
            # DO NOT RETURN HERE BLINDLY, THE UPSTREAM CONNECTION MUST GO FIRST!
            if THREAD_TERMINATE:
                self.log.trace("No more input generated, quitting.")
                return
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatPluginOutput.output_callback">
    <p>def <span class="ident">output_callback</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>Print received data to stdout.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatPluginOutput.output_callback', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatPluginOutput.output_callback" class="source">
    <pre><code>def output_callback(self, data):
    """Print received data to stdout."""
    print(data, end="")
    sys.stdout.flush()  # TODO:Is this required? What does this do? Test this!
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatPluginOutput.stop">
    <p>def <span class="ident">stop</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Implement a stop method, which exits the instance.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatPluginOutput.stop', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatPluginOutput.stop" class="source">
    <pre><code>def stop(self):
    global THREAD_TERMINATE
    """Stop function that can be called externally to close this instance."""
    self.log.trace("[NetcatOutputCommand] pass was raised by stop() function")
    THREAD_TERMINATE = True
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pwncat.NetcatPluginOutput.enc" class="name">var <span class="ident">enc</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatPluginOutput.log" class="name">var <span class="ident">log</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="pwncat.NetcatServer" class="name">class <span class="ident">NetcatServer</span></p>
      
  
    <div class="desc"><p>Netcat Server implementation.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatServer', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatServer" class="source">
    <pre><code>class NetcatServer(AbstractSocket):
    """Netcat Server implementation."""

    def __init__(self, encoder, host, port, recv_timeout, recv_timeout_retry, options={}):
        """Construct a listening server."""
        super(NetcatServer, self).__init__(
            encoder, "server", recv_timeout, recv_timeout_retry, options
        )

        # Setup server
        addr = self.gethostbyname(host)
        self.create_socket()
        self.bind(addr, port)
        if self.options["udp"]:
            self.conn = self.sock
            self.log.info("Waiting on {}:{} (UDP)".format(addr, port))
        else:
            self.listen()
            self.log.info("Listening on {}:{} (TCP)".format(addr, port))
            self.accept()
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pwncat.NetcatServer">NetcatServer</a></li>
          <li><a href="#pwncat.AbstractSocket">AbstractSocket</a></li>
          <li><a href="/builtins.object.ext">builtins.object</a></li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="pwncat.NetcatServer.conn" class="name">var <span class="ident">conn</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatServer.options" class="name">var <span class="ident">options</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatServer.recv_timeout" class="name">var <span class="ident">recv_timeout</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatServer.recv_timeout_retry" class="name">var <span class="ident">recv_timeout_retry</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatServer.remote_addr" class="name">var <span class="ident">remote_addr</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatServer.role" class="name">var <span class="ident">role</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatServer.sock" class="name">var <span class="ident">sock</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatServer.udp_client_addr" class="name">var <span class="ident">udp_client_addr</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatServer.udp_client_port" class="name">var <span class="ident">udp_client_port</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatServer.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, encoder, host, port, recv_timeout, recv_timeout_retry, options={})</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#pwncat.AbstractSocket">AbstractSocket</a></code>.<code><a href="#pwncat.AbstractSocket.__init__">__init__</a></code>
    </p>

    
  
    <div class="desc"><p>Construct a listening server.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatServer.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatServer.__init__" class="source">
    <pre><code>def __init__(self, encoder, host, port, recv_timeout, recv_timeout_retry, options={}):
    """Construct a listening server."""
    super(NetcatServer, self).__init__(
        encoder, "server", recv_timeout, recv_timeout_retry, options
    )
    # Setup server
    addr = self.gethostbyname(host)
    self.create_socket()
    self.bind(addr, port)
    if self.options["udp"]:
        self.conn = self.sock
        self.log.info("Waiting on {}:{} (UDP)".format(addr, port))
    else:
        self.listen()
        self.log.info("Listening on {}:{} (TCP)".format(addr, port))
        self.accept()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatServer.accept">
    <p>def <span class="ident">accept</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Accept a connection.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatServer.accept', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatServer.accept" class="source">
    <pre><code>def accept(self):
    """Accept a connection."""
    try:
        self.log.debug("Waiting for TCP client")
        self.conn, client = self.sock.accept()
        addr, port = client
        self.log.info("Client connected from {}:{}".format(addr, port))
    except (socket.gaierror, socket.error) as error:
        self.log.error("Accept failed: {}".format(error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatServer.bind">
    <p>def <span class="ident">bind</span>(</p><p>self, addr, port)</p>
    </div>
    

    
  
    <div class="desc"><p>Bind the socket to an address.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatServer.bind', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatServer.bind" class="source">
    <pre><code>def bind(self, addr, port):
    """Bind the socket to an address."""
    try:
        self.log.debug("Binding socket to {}:{}".format(addr, port))
        self.sock.bind((addr, port))
    except (OverflowError, OSError, socket.error) as error:
        self.log.error("Binding socket to {}:{} failed: {}".format(addr, port, error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatServer.connect">
    <p>def <span class="ident">connect</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Connect to a remote socket at given address and port (TCP-only).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatServer.connect', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatServer.connect" class="source">
    <pre><code>def connect(self):
    """Connect to a remote socket at given address and port (TCP-only)."""
    try:
        self.log.debug("Connecting to {}:{}".format(self.remote_addr, self.remote_port))
        self.sock.connect((self.remote_addr, self.remote_port))
        return True
    except socket.error as error:
        self.log.error(
            "Connecting to {}:{} failed: {}".format(self.remote_addr, self.remote_port, error)
        )
        return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatServer.create_socket">
    <p>def <span class="ident">create_socket</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Create TCP or UDP socket.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatServer.create_socket', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatServer.create_socket" class="source">
    <pre><code>def create_socket(self):
    """Create TCP or UDP socket."""
    try:
        if self.options["udp"]:
            self.log.debug("Creating UDP socket")
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        else:
            self.log.debug("Creating TCP socket")
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    except socket.error as error:
        self.log.error("Failed to create the socket: {}".format(error))
        sys.exit(1)
    # Get around the "[Errno 98] Address already in use" error, if the socket is still in wait
    # we instruct it to reuse the address anyway.
    self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatServer.gethostbyname">
    <p>def <span class="ident">gethostbyname</span>(</p><p>self, host)</p>
    </div>
    

    
  
    <div class="desc"><p>Translate hostname into IP address.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatServer.gethostbyname', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatServer.gethostbyname" class="source">
    <pre><code>def gethostbyname(self, host):
    """Translate hostname into IP address."""
    if self.options["nodns"]:
        return host
    try:
        self.log.debug("Resolving hostname: {}".format(host))
        addr = socket.gethostbyname(host)
        self.log.debug("Resolved hostname:  {}".format(addr))
        return addr
    except socket.gaierror as error:
        self.log.error("Resolve Error: {}".format(error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatServer.listen">
    <p>def <span class="ident">listen</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Listen for connections made to the socket.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatServer.listen', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatServer.listen" class="source">
    <pre><code>def listen(self):
    """Listen for connections made to the socket."""
    try:
        self.log.debug("Listening with backlog={}".format(self.options["backlog"]))
        self.sock.listen(self.options["backlog"])
    except socket.error as error:
        self.log.error("Listening failed: {}".format(error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatServer.receive">
    <p>def <span class="ident">receive</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Generator function to receive data endlessly by yielding it.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatServer.receive', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatServer.receive" class="source">
    <pre><code>def receive(self):
    """Generator function to receive data endlessly by yielding it."""
    # Set current receive timeout
    self.conn.settimeout(self.recv_timeout)
    self.log.trace("Socket Timeout: {}".format(self.recv_timeout_retry))
    # Counts how many times we had a ready timeout for later to decide
    # if we exceeded maximum retires
    curr_recv_timeout_retry = 0
    while True:
        if self.conn is None:
            self.log.error("Socket is gone")
            return
        # Non-blocking socket with timeout. If the timeout threshold is hit,
        # it will throw an socket.timeout exception. This is required to see if other
        # threads have been terminated already.
        try:
            # https://manpages.debian.org/buster/manpages-dev/recv.2.en.html
            (byte, addr) = self.conn.recvfrom(self.options["bufsize"])
        except socket.timeout:
            # No other thread has terminated yet, and thus not asked us to quit.
            # so we can continue waiting for input on the socket
            if not THREAD_TERMINATE:
                # TODO: Re-enable this for very verbose logging
                # self.log.trace("SOCKET RECV: timeout. Waiting for input...")
                continue
            # Other threads are done. Let's try to read a few more times before
            # returning and ending this function (might be data left)
            if curr_recv_timeout_retry < self.recv_timeout_retry:
                self.log.trace("RECV EOF TIMEOUT: AND THREAD_TERMINATE REQUESTED")
                curr_recv_timeout_retry += 1
                continue
            return
        except socket.error as error:
            self.log.error("TODO: What happens here? Socket Receive Error: {}".format(error))
            return
        except AttributeError as error:
            self.log.error("TODO: What happens here?Attribute Receive Error: {}".format(error))
            return
        # We're receiving data again, so let's reset the retry/terminate counter
        curr_recv_timeout_retry = 0
        data = byte
        if not data:
            # Upstream (server or client) is gone. Do we reconnect or quit?
            self.log.warning("Upstream connection is gone")
            if self.role == "server":
                if not self.__reaccept_from_client():
                    self.log.warning("Shutdown-1")
                    return
            if self.role == "client":
                if not self.__reconnect_to_server():
                    self.log.warning("Shutdown-2")
                    return
        data = self.enc.decode(byte)
        self.log.trace("Received: {}".format(repr(data)))
        # If we're receiving data from a UDP client
        # we can firstly/finally set its addr/port in order
        # to send data back to it (see send() function)
        if self.options["udp"]:
            self.udp_client_addr, self.udp_client_port = addr
            # Avoid the noise on UDP connections to spam on every send
            if self.udp_client_addr is None or self.udp_client_port is None:
                self.log.info(
                    "Client connected: {}:{}".format(self.udp_client_addr, self.udp_client_port)
                )
            # Find for debug
            else:
                self.log.debug(
                    "Client connected: {}:{}".format(self.udp_client_addr, self.udp_client_port)
                )
        yield data
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatServer.send">
    <p>def <span class="ident">send</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>Send data.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatServer.send', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatServer.send" class="source">
    <pre><code>def send(self, data):
    """Send data."""
    # In case of sending data back to an udp client we need to wait
    # until the client has first connected and told us its addr/port
    if self.options["udp"] and self.udp_client_addr is None and self.udp_client_port is None:
        self.log.info("Waiting for UDP client to connect")
        while self.udp_client_addr is None and self.udp_client_port is None:
            time.sleep(0.2)  # Less wastefull than using 'pass'
    curr = 0  # bytes send during one loop iteration
    send = 0  # total bytes send
    size = len(data)  # bytes of data that needs to be send
    data = self.enc.encode(data)
    assert size == len(data), "Encoding messed up string length, might need to do len() after."
    # Loop until all bytes have been send
    while send < size:
        try:
            self.log.trace("Trying to send {} bytes".format(size - send))
            if self.options["udp"]:
                curr = self.conn.sendto(data, (self.udp_client_addr, self.udp_client_port))
                send += curr
            else:
                curr = self.conn.send(data)
                send += curr
            if curr == 0:
                self.log.error("No bytes send during loop round.")
                return
            # Remove 'curr' many bytes from data for the next round
            data = data[curr:]
            self.log.trace("Send {} bytes ({} bytes remaining)".format(curr, size - send))
        except socket.error as error:
            if error.errno == socket.errno.EPIPE:
                self.log.error("TODO:Add desc. Socket error({}): {}".format(error.errno, error))
                return
            # Most likely nothing to see here??
            # FIXME: TODO: Need to re-accepd new client
            self.log.error("TODO:Add desc. Socket Error: {}".format(error))
            if self.role == "server":
                if self.__reaccept_from_client():
                    continue
            self.log.warning("Shutdown")
            return
        except (OSError) as error:
            self.log.error("Socket OS Error: {}".format(error))
            return
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="pwncat.Runner" class="name">class <span class="ident">Runner</span></p>
      
  
    <div class="desc"><p>Runner class that takes care about putting everything into threads.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.Runner', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.Runner" class="source">
    <pre><code>class Runner(object):
    """Runner class that takes care about putting everything into threads."""

    # ------------------------------------------------------------------------------
    # Constructor / Destructor
    # ------------------------------------------------------------------------------
    def __init__(self):
        """Constructor."""
        self.log = logging.getLogger(__name__)

    # Generator
    [
        {
            "name": "",
            "input_generator": {"fnc": "", "args": "", "kwargs": ""},
            "input_interrupter": {"fnc": "", "args": "", "kwargs": ""},
            "input_callback": {"fnc": "", "args": "", "kwargs": ""},
        }
    ]
    # Timebased

    # ------------------------------------------------------------------------------
    # Public Functions
    # ------------------------------------------------------------------------------
    def set_recv_generator(self, func):
        """Set generator func which constantly receives network data."""
        self.recv_generator = func

    def set_input_generator(self, func):
        """Set generator func which constantly receives input (shell output/user input)."""
        self.input_generator = func

    def set_send_callback(self, func):
        """Set the callback for sending data to a socket."""
        self.send_callback = func

    def set_output_callback(self, func):
        """Set the callback for outputting data to stdin/stdout."""
        self.output_callback = func

    def set_revc_generator_stop_function(self, func):
        self.recv_generator_stop_fn = func

    def set_input_generator_stop_function(self, func):
        self.input_generator_stop_fn = func

    def set_timed_action(self, intvl, func, *args, **kwargs):
        """Set a function that should be called periodically."""
        self.timed_action_intvl = intvl
        self.timed_action_func = func
        self.timed_action_args = args
        self.timed_action_kwargs = kwargs

    def run(self):
        """Run threaded NetCat."""
        global THREAD_TERMINATE

        assert hasattr(self, "recv_generator"), "Error, recv_generator not set"
        assert hasattr(self, "input_generator"), "Error, input_generator not set"
        assert hasattr(self, "send_callback"), "Error, send_callback not set"
        assert hasattr(self, "output_callback"), "Error, output_callback not set"

        def receiver():
            """Receive data from a socket and process it with a callback.

            receive: Must be a generator function to receive network data.
            callback: Must be a callback to process received data, e.g.: print to stdin/stdout.
            """
            self.log.trace("[Thread-Recv] START")
            for data in self.recv_generator():
                self.log.trace("[Thread-Recv] recv_generator() received: {}".format(repr(data)))
                self.output_callback(data)
            self.log.trace("[Thread-Recv] STOP")

        def sender():
            """Receive data from user-input/command-output and process it with a callback.

            receive: Must be a generator function to receive user-input or command output.
            callback: Must be a callback to send this data to a socket.
            """
            self.log.trace("[Thread-Send] START")
            for data in self.input_generator():
                self.log.trace("[Thread-Send] received via input_generator(): {}".format(data))
                self.send_callback(data)
            self.log.trace("[Thread-Send] STOP")

        def timer():
            """Execute periodic tasks by an optional provided time_action."""
            self.log.trace("[Thread-Time] START")
            self.log.debug(
                "Ready for timed action every {} seconds".format(self.timed_action_intvl)
            )
            time_last = int(time.time())
            while True:
                time_now = int(time.time())
                if time_now > time_last + self.timed_action_intvl:
                    self.log.debug("[{}] Executing timed function".format(time_now))
                    self.timed_action_func(*self.timed_action_args, **self.timed_action_kwargs)
                    time_last = time_now  # Reset previous time
                time.sleep(1)

        # Start sending and receiving threads
        self.tr = threading.Thread(target=receiver, name="Thread-Recv")
        self.ts = threading.Thread(target=sender, name="Thread-Send")
        # If the main thread kills, this thread will be killed too.
        self.tr.daemon = False  # No daemon, wait for each other (e.g.: data received
        self.ts.daemon = False  # should also be outputted)
        # Start threads
        self.tr.start()
        # time.sleep(0.1)
        self.ts.start()

        if hasattr(self, "timed_action_intvl"):
            self.tt = threading.Thread(target=timer, name="Thread-Time")
            self.tt.daemon = True
            self.tt.start()

        # Cleanup the main program
        while True:
            # TODO: is this required? (check if need to press Ctrl+c twice)
            # if not THREAD_TERMINATE:
            #     self.input_generator_stop_fn()
            #     self.recv_generator_stop_fn()
            if not self.tr.is_alive():
                self.log.trace("Setting THREAD_TERMINATE=True from Thread-Recv death")
                self.log.trace("Waiting for Thread-Send to finish")
                # time.sleep(0.1)
                THREAD_TERMINATE = True
                self.input_generator_stop_fn()
                self.ts.join()
                sys.exit(0)
            if not self.ts.is_alive():
                self.log.trace("Setting THREAD_TERMINATE=True from Thread-Send death")
                self.log.trace("Waiting for Thread-Recv to finish")
                # time.sleep(0.1)
                THREAD_TERMINATE = True
                self.recv_generator_stop_fn()
                self.tr.join()
                sys.exit(0)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pwncat.Runner">Runner</a></li>
          <li><a href="/builtins.object.ext">builtins.object</a></li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pwncat.Runner.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Constructor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.Runner.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.Runner.__init__" class="source">
    <pre><code>def __init__(self):
    """Constructor."""
    self.log = logging.getLogger(__name__)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.Runner.run">
    <p>def <span class="ident">run</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Run threaded NetCat.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.Runner.run', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.Runner.run" class="source">
    <pre><code>def run(self):
    """Run threaded NetCat."""
    global THREAD_TERMINATE
    assert hasattr(self, "recv_generator"), "Error, recv_generator not set"
    assert hasattr(self, "input_generator"), "Error, input_generator not set"
    assert hasattr(self, "send_callback"), "Error, send_callback not set"
    assert hasattr(self, "output_callback"), "Error, output_callback not set"
    def receiver():
        """Receive data from a socket and process it with a callback.
        receive: Must be a generator function to receive network data.
        callback: Must be a callback to process received data, e.g.: print to stdin/stdout.
        """
        self.log.trace("[Thread-Recv] START")
        for data in self.recv_generator():
            self.log.trace("[Thread-Recv] recv_generator() received: {}".format(repr(data)))
            self.output_callback(data)
        self.log.trace("[Thread-Recv] STOP")
    def sender():
        """Receive data from user-input/command-output and process it with a callback.
        receive: Must be a generator function to receive user-input or command output.
        callback: Must be a callback to send this data to a socket.
        """
        self.log.trace("[Thread-Send] START")
        for data in self.input_generator():
            self.log.trace("[Thread-Send] received via input_generator(): {}".format(data))
            self.send_callback(data)
        self.log.trace("[Thread-Send] STOP")
    def timer():
        """Execute periodic tasks by an optional provided time_action."""
        self.log.trace("[Thread-Time] START")
        self.log.debug(
            "Ready for timed action every {} seconds".format(self.timed_action_intvl)
        )
        time_last = int(time.time())
        while True:
            time_now = int(time.time())
            if time_now > time_last + self.timed_action_intvl:
                self.log.debug("[{}] Executing timed function".format(time_now))
                self.timed_action_func(*self.timed_action_args, **self.timed_action_kwargs)
                time_last = time_now  # Reset previous time
            time.sleep(1)
    # Start sending and receiving threads
    self.tr = threading.Thread(target=receiver, name="Thread-Recv")
    self.ts = threading.Thread(target=sender, name="Thread-Send")
    # If the main thread kills, this thread will be killed too.
    self.tr.daemon = False  # No daemon, wait for each other (e.g.: data received
    self.ts.daemon = False  # should also be outputted)
    # Start threads
    self.tr.start()
    # time.sleep(0.1)
    self.ts.start()
    if hasattr(self, "timed_action_intvl"):
        self.tt = threading.Thread(target=timer, name="Thread-Time")
        self.tt.daemon = True
        self.tt.start()
    # Cleanup the main program
    while True:
        # TODO: is this required? (check if need to press Ctrl+c twice)
        # if not THREAD_TERMINATE:
        #     self.input_generator_stop_fn()
        #     self.recv_generator_stop_fn()
        if not self.tr.is_alive():
            self.log.trace("Setting THREAD_TERMINATE=True from Thread-Recv death")
            self.log.trace("Waiting for Thread-Send to finish")
            # time.sleep(0.1)
            THREAD_TERMINATE = True
            self.input_generator_stop_fn()
            self.ts.join()
            sys.exit(0)
        if not self.ts.is_alive():
            self.log.trace("Setting THREAD_TERMINATE=True from Thread-Send death")
            self.log.trace("Waiting for Thread-Recv to finish")
            # time.sleep(0.1)
            THREAD_TERMINATE = True
            self.recv_generator_stop_fn()
            self.tr.join()
            sys.exit(0)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.Runner.set_input_generator">
    <p>def <span class="ident">set_input_generator</span>(</p><p>self, func)</p>
    </div>
    

    
  
    <div class="desc"><p>Set generator func which constantly receives input (shell output/user input).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.Runner.set_input_generator', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.Runner.set_input_generator" class="source">
    <pre><code>def set_input_generator(self, func):
    """Set generator func which constantly receives input (shell output/user input)."""
    self.input_generator = func
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.Runner.set_input_generator_stop_function">
    <p>def <span class="ident">set_input_generator_stop_function</span>(</p><p>self, func)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.Runner.set_input_generator_stop_function', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.Runner.set_input_generator_stop_function" class="source">
    <pre><code>def set_input_generator_stop_function(self, func):
    self.input_generator_stop_fn = func
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.Runner.set_output_callback">
    <p>def <span class="ident">set_output_callback</span>(</p><p>self, func)</p>
    </div>
    

    
  
    <div class="desc"><p>Set the callback for outputting data to stdin/stdout.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.Runner.set_output_callback', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.Runner.set_output_callback" class="source">
    <pre><code>def set_output_callback(self, func):
    """Set the callback for outputting data to stdin/stdout."""
    self.output_callback = func
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.Runner.set_recv_generator">
    <p>def <span class="ident">set_recv_generator</span>(</p><p>self, func)</p>
    </div>
    

    
  
    <div class="desc"><p>Set generator func which constantly receives network data.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.Runner.set_recv_generator', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.Runner.set_recv_generator" class="source">
    <pre><code>def set_recv_generator(self, func):
    """Set generator func which constantly receives network data."""
    self.recv_generator = func
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.Runner.set_revc_generator_stop_function">
    <p>def <span class="ident">set_revc_generator_stop_function</span>(</p><p>self, func)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.Runner.set_revc_generator_stop_function', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.Runner.set_revc_generator_stop_function" class="source">
    <pre><code>def set_revc_generator_stop_function(self, func):
    self.recv_generator_stop_fn = func
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.Runner.set_send_callback">
    <p>def <span class="ident">set_send_callback</span>(</p><p>self, func)</p>
    </div>
    

    
  
    <div class="desc"><p>Set the callback for sending data to a socket.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.Runner.set_send_callback', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.Runner.set_send_callback" class="source">
    <pre><code>def set_send_callback(self, func):
    """Set the callback for sending data to a socket."""
    self.send_callback = func
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.Runner.set_timed_action">
    <p>def <span class="ident">set_timed_action</span>(</p><p>self, intvl, func, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Set a function that should be called periodically.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.Runner.set_timed_action', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.Runner.set_timed_action" class="source">
    <pre><code>def set_timed_action(self, intvl, func, *args, **kwargs):
    """Set a function that should be called periodically."""
    self.timed_action_intvl = intvl
    self.timed_action_func = func
    self.timed_action_args = args
    self.timed_action_kwargs = kwargs
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pwncat.Runner.log" class="name">var <span class="ident">log</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="pwncat.StringEncoder" class="name">class <span class="ident">StringEncoder</span></p>
      
  
    <div class="desc"><p>Takes care about Python 2/3 string encoding/decoding.</p>
<p>This allows to parse all string/byte values internally between all
classes or functions as strings to keep full Python 2/3 compat.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.StringEncoder', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.StringEncoder" class="source">
    <pre><code>class StringEncoder(object):
    """
    Takes care about Python 2/3 string encoding/decoding.

    This allows to parse all string/byte values internally between all
    classes or functions as strings to keep full Python 2/3 compat.
    """

    # https://stackoverflow.com/questions/606191/27527728#27527728
    codec = "cp437"

    def __init__(self):
        self.py3 = sys.version_info >= (3, 0)

    def encode(self, data):
        """Convert string into a byte type for Python3."""
        if self.py3:
            data = data.encode("cp437")
        return data

    def decode(self, data):
        """Convert bytes into a string type for Python3."""
        if self.py3:
            data = data.decode("cp437")
        return data
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pwncat.StringEncoder">StringEncoder</a></li>
          <li><a href="/builtins.object.ext">builtins.object</a></li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="pwncat.StringEncoder.codec" class="name">var <span class="ident">codec</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pwncat.StringEncoder.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.StringEncoder.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.StringEncoder.__init__" class="source">
    <pre><code>def __init__(self):
    self.py3 = sys.version_info >= (3, 0)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.StringEncoder.decode">
    <p>def <span class="ident">decode</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>Convert bytes into a string type for Python3.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.StringEncoder.decode', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.StringEncoder.decode" class="source">
    <pre><code>def decode(self, data):
    """Convert bytes into a string type for Python3."""
    if self.py3:
        data = data.decode("cp437")
    return data
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.StringEncoder.encode">
    <p>def <span class="ident">encode</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>Convert string into a byte type for Python3.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.StringEncoder.encode', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.StringEncoder.encode" class="source">
    <pre><code>def encode(self, data):
    """Convert string into a byte type for Python3."""
    if self.py3:
        data = data.encode("cp437")
    return data
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pwncat.StringEncoder.py3" class="name">var <span class="ident">py3</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
