<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>pwncat API documentation</title>
    <meta name="description" content="Python netcat implementation." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#pwncat.APPNAME">APPNAME</a></li>
    <li class="mono"><a href="#pwncat.APPREPO">APPREPO</a></li>
    <li class="mono"><a href="#pwncat.PIPE">PIPE</a></li>
    <li class="mono"><a href="#pwncat.VERSION">VERSION</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#pwncat.get_args">get_args</a></li>
    <li class="mono"><a href="#pwncat.get_version">get_version</a></li>
    <li class="mono"><a href="#pwncat.main">main</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#pwncat.AbstractNetcatModule">AbstractNetcatModule</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pwncat.AbstractNetcatModule.__init__">__init__</a></li>
    <li class="mono"><a href="#pwncat.AbstractNetcatModule.input_generator">input_generator</a></li>
    <li class="mono"><a href="#pwncat.AbstractNetcatModule.output_callback">output_callback</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pwncat.AbstractSocket">AbstractSocket</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pwncat.AbstractSocket.__init__">__init__</a></li>
    <li class="mono"><a href="#pwncat.AbstractSocket.accept">accept</a></li>
    <li class="mono"><a href="#pwncat.AbstractSocket.bind">bind</a></li>
    <li class="mono"><a href="#pwncat.AbstractSocket.connect">connect</a></li>
    <li class="mono"><a href="#pwncat.AbstractSocket.create_socket">create_socket</a></li>
    <li class="mono"><a href="#pwncat.AbstractSocket.gethostbyname">gethostbyname</a></li>
    <li class="mono"><a href="#pwncat.AbstractSocket.listen">listen</a></li>
    <li class="mono"><a href="#pwncat.AbstractSocket.receive">receive</a></li>
    <li class="mono"><a href="#pwncat.AbstractSocket.send">send</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pwncat.Logger">Logger</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pwncat.Logger.__init__">__init__</a></li>
    <li class="mono"><a href="#pwncat.Logger.debug">debug</a></li>
    <li class="mono"><a href="#pwncat.Logger.error">error</a></li>
    <li class="mono"><a href="#pwncat.Logger.info">info</a></li>
    <li class="mono"><a href="#pwncat.Logger.trace">trace</a></li>
    <li class="mono"><a href="#pwncat.Logger.warning">warning</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pwncat.NetcatClient">NetcatClient</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pwncat.NetcatClient.__init__">__init__</a></li>
    <li class="mono"><a href="#pwncat.NetcatClient.accept">accept</a></li>
    <li class="mono"><a href="#pwncat.NetcatClient.bind">bind</a></li>
    <li class="mono"><a href="#pwncat.NetcatClient.connect">connect</a></li>
    <li class="mono"><a href="#pwncat.NetcatClient.create_socket">create_socket</a></li>
    <li class="mono"><a href="#pwncat.NetcatClient.gethostbyname">gethostbyname</a></li>
    <li class="mono"><a href="#pwncat.NetcatClient.listen">listen</a></li>
    <li class="mono"><a href="#pwncat.NetcatClient.receive">receive</a></li>
    <li class="mono"><a href="#pwncat.NetcatClient.send">send</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pwncat.NetcatModuleCommand">NetcatModuleCommand</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pwncat.NetcatModuleCommand.__init__">__init__</a></li>
    <li class="mono"><a href="#pwncat.NetcatModuleCommand.input_generator">input_generator</a></li>
    <li class="mono"><a href="#pwncat.NetcatModuleCommand.output_callback">output_callback</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pwncat.NetcatModuleOutput">NetcatModuleOutput</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pwncat.NetcatModuleOutput.__init__">__init__</a></li>
    <li class="mono"><a href="#pwncat.NetcatModuleOutput.input_generator">input_generator</a></li>
    <li class="mono"><a href="#pwncat.NetcatModuleOutput.output_callback">output_callback</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pwncat.NetcatServer">NetcatServer</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pwncat.NetcatServer.__init__">__init__</a></li>
    <li class="mono"><a href="#pwncat.NetcatServer.accept">accept</a></li>
    <li class="mono"><a href="#pwncat.NetcatServer.bind">bind</a></li>
    <li class="mono"><a href="#pwncat.NetcatServer.connect">connect</a></li>
    <li class="mono"><a href="#pwncat.NetcatServer.create_socket">create_socket</a></li>
    <li class="mono"><a href="#pwncat.NetcatServer.gethostbyname">gethostbyname</a></li>
    <li class="mono"><a href="#pwncat.NetcatServer.listen">listen</a></li>
    <li class="mono"><a href="#pwncat.NetcatServer.receive">receive</a></li>
    <li class="mono"><a href="#pwncat.NetcatServer.send">send</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pwncat.Runner">Runner</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pwncat.Runner.__init__">__init__</a></li>
    <li class="mono"><a href="#pwncat.Runner.run">run</a></li>
    <li class="mono"><a href="#pwncat.Runner.set_input_generator">set_input_generator</a></li>
    <li class="mono"><a href="#pwncat.Runner.set_output_callback">set_output_callback</a></li>
    <li class="mono"><a href="#pwncat.Runner.set_recv_generator">set_recv_generator</a></li>
    <li class="mono"><a href="#pwncat.Runner.set_send_callback">set_send_callback</a></li>
    <li class="mono"><a href="#pwncat.Runner.set_time_action">set_time_action</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pwncat.StringEncoder">StringEncoder</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pwncat.StringEncoder.__init__">__init__</a></li>
    <li class="mono"><a href="#pwncat.StringEncoder.decode">decode</a></li>
    <li class="mono"><a href="#pwncat.StringEncoder.encode">encode</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">pwncat</span> module</h1>
  <p>Python netcat implementation.</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat', this);">Show source &equiv;</a></p>
  <div id="source-pwncat" class="source">
    <pre><code>#!/usr/bin/env python3
"""Python netcat implementation."""

from __future__ import print_function
from builtins import input
from abc import ABCMeta, abstractmethod
from subprocess import Popen, PIPE
import argparse
import atexit
import inspect
import os
import re
import socket
import subprocess
import sys
import threading
import time

# -------------------------------------------------------------------------------------------------
# GLOBALS
# -------------------------------------------------------------------------------------------------

APPNAME = "pwncat"
APPREPO = "https://github.com/cytopia/pwncat"
VERSION = "0.0.4-alpha"


# -------------------------------------------------------------------------------------------------
# ABSTRACT CLASS: AbstractNetcatModule
# -------------------------------------------------------------------------------------------------
class AbstractNetcatModule:
    """
    Abstract class to for netcat modules.

    This is a skeleton that defines how the modules for Netcat should look like.

    The data_generator should constantly yield data received from sort sort of input
    which could be user input, output from a shell command data from a socket.

    The data_callback will apply some sort of action on the data received from a data_generator
    which could be output to stdout, send it to the shell or to a socket.
    """

    __metaclass__ = ABCMeta

    @abstractmethod
    def __init__(self, logger, encoder, options={}):
        """Set specific options for this module."""
        pass

    @abstractmethod
    def input_generator(self):
        """Implement a generator function which constantly yields data from some input."""
        while False:
            yield None

    @abstractmethod
    def output_callback(self, data):
        """Implement a callback which processes the input into some output."""
        print(data)


# -------------------------------------------------------------------------------------------------
# ABSTRCT CLASS: AbstractSocket
# -------------------------------------------------------------------------------------------------
class AbstractSocket(object):
    """Abstract class which provides TCP, UDP and IPv4, IPv6 Socket funcionality."""

    sock = None  # server binding socket (until accept())
    conn = None  # client/server communication socket

    # The instance role must be 'server' or 'client' and
    # is used to determine how to reconnect broken connections.
    # Either listen again (tcp-only) or re-connect to upstream.
    role = None  # Must be 'server' or 'client'

    options = {
        "udp": False,  # Is TCP or UDP server?
        "bufsize": 1024,  # Receive buffer size
        "backlog": 0,  # Listen backlog
        "nodns": False,  # Do not resolve hostnames
        "reinit": False,  # False (never), True (indefinite) or int for how many times to reinit
        "reconn": False,  # False (never), True (indefinite) or int for how many times to reconnect
        "reinit_robin": [],  # Ports to round-robin during failed init phase
        "reconn_robin": [],  # Ports to round-robin during failed phase (after 1st succ init)
        "reinit_wait": 0,  # Time in seconds to wait between reinits
        "reconn_wait": 0,  # Time in seconds to wait between reconnects
        "udp_ping_intvl": False,  # Interval in sec for UDP client to ping server
    }

    # In case the server is running in UDP mode,
    # it must wait for the client to connect in order
    # to retrieve its addr and port in order to be able
    # to send data back to it.
    udp_client_addr = None
    udp_client_port = None

    # For client role only
    # Store the address and port of the remote server to connect to.
    # This is required for self.connect()
    remote_addr = None
    remote_addr = None

    # ------------------------------------------------------------------------------
    # Constructor / Destructor
    # ------------------------------------------------------------------------------
    def __init__(self, logger, encoder, role, options={}):
        """Constructor."""
        assert type(self) is not AbstractSocket, "AbstractSocket cannot be instantiated directly."
        assert role in ["server", "client"], "The role must be 'server' or 'client'."

        self.log = logger
        self.enc = encoder
        self.role = role

        if "udp" in options:
            self.options["udp"] = options["udp"]
        if "bufsize" in options:
            self.options["bufsize"] = options["bufsize"]
        if "backlog" in options:
            self.options["backlog"] = options["backlog"]
        if "nodns" in options:
            self.options["nodns"] = options["nodns"]
        if "reinit" in options:
            self.options["reinit"] = options["reinit"]
        if "reconn" in options:
            self.options["reconn"] = options["reconn"]
        if "reinit_robin" in options:
            self.options["reinit_robin"] = options["reinit_robin"]
        if "reconn_robin" in options:
            self.options["reconn_robin"] = options["reconn_robin"]
        if "reinit_wait" in options:
            self.options["reinit_wait"] = options["reinit_wait"]
        if "reconn_wait" in options:
            self.options["reconn_wait"] = options["reconn_wait"]
        if "udp_ping_intvl" in options:
            self.options["udp_ping_intvl"] = options["udp_ping_intvl"]

        # Register destructor
        atexit.register(self.__exit__)

    def __exit__(self):
        """Destructor."""
        if self.conn is not None:
            self.log.trace("Closing 'conn' socket")
            self.__close_socket(self.conn)
            self.conn = None
        if self.sock is not None:
            self.log.trace("Closing 'sock' socket")
            self.__close_socket(self.sock)
            self.sock = None

    # ------------------------------------------------------------------------------
    # Private Functions
    # ------------------------------------------------------------------------------
    def __close_socket(self, sock):
        """Close a socket."""
        try:
            sock.shutdown(socket.SHUT_RDWR)
        except (ValueError, OSError, socket.error):
            pass
        sock.close()

    def __reconnect(self):
        """Reconnect to a server if upstream has gone."""
        self.__close_socket(self.conn)
        self.__close_socket(self.sock)
        self.create_socket()
        self.conn = self.sock
        if not self.connect():
            self.__reconnect_to_server()

    def __reaccept_from_client(self):
        """Ensure the server is able to accept clients again, after current client has left."""
        # Only for server
        assert self.role == "server", "Only the role 'server' can accept connections."
        # Do not re-accept for UDP
        assert not self.options["udp"], "This should have been caught during arg check."

        # [NO] Never re-accept
        if type(self.options["reconn"]) is bool and not self.options["reconn"]:
            self.log.info("No automatic re-accept specified. Shutting down.")
            return False
        # [YES] Always re-accept indefinitely
        if type(self.options["reconn"]) is bool and self.options["reconn"]:
            self.log.info(
                "Re-accepting in {} sec (indefinitely)".format(self.options["reconn_wait"])
            )
            time.sleep(self.options["reconn_wait"])
            self.accept()
            return True
        # [YES] Re-accept x many times
        if self.options["reconn"] > 0:
            self.log.info(
                "Re-accepting in {} sec ({} more times left)".format(
                    self.options["reconn_wait"], self.options["reconn"]
                )
            )
            self.options["reconn"] -= 1
            time.sleep(self.options["reconn_wait"])
            self.accept()
            return True
        # [NO] Re-accept count is used up
        self.log.info("Re-accept count is used up. Shutting down.")
        return False

    def __reconnect_to_server(self):
        """Ensure the client re-connects to the remote server, if the remote server hang up."""
        # Only for Clients
        assert self.role == "client", "Only the role 'client' can re-connect."
        # Do not re-connect with UDP
        assert not self.options["udp"], "This should have been caught during arg check."

        # [NO] Never re-connect
        if type(self.options["reconn"]) is bool and not self.options["reconn"]:
            self.log.info("No automatic reconnect specified. Shutting down.")
            return False
        # [YES] Always re-connect indefinitely
        if type(self.options["reconn"]) is bool and self.options["reconn"]:
            self.log.info(
                "Reconnecting in {} sec (indefinitely)".format(self.options["reconn_wait"])
            )
            time.sleep(self.options["reconn_wait"])
            self.__reconnect()
            return True
        # [YES] Re-connect x many times
        if self.options["reconn"] > 0:
            self.log.info(
                "Reconnecting in {} sec ({} more times left)".format(
                    self.options["reconn_wait"], self.options["reconn"]
                )
            )
            self.options["reconn"] -= 1
            time.sleep(self.options["reconn_wait"])
            self.__reconnect()
            return True
        # [NO] Re-connect count is used up
        self.log.info("Reconnect count is used up. Shutting down.")
        return False

    # ------------------------------------------------------------------------------
    # Helper Functions
    # ------------------------------------------------------------------------------
    def gethostbyname(self, host):
        """Translate hostname into IP address."""
        if self.options["nodns"]:
            return host
        try:
            self.log.debug("Resolving hostname: {}".format(host))
            addr = socket.gethostbyname(host)
            self.log.debug("Resolved hostname:  {}".format(addr))
            return addr
        except socket.gaierror as error:
            self.log.error("Resolve Error: {}".format(error))
            sys.exit(1)

    def create_socket(self):
        """Create TCP or UDP socket."""
        try:
            if self.options["udp"]:
                self.log.debug("Creating UDP socket")
                self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            else:
                self.log.debug("Creating TCP socket")
                self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        except socket.error as error:
            self.log.error("Failed to create the socket: {}".format(error))
            sys.exit(1)

    def bind(self, addr, port):
        """Bind the socket to an address."""
        try:
            self.log.debug("Binding socket to {}:{}".format(addr, port))
            self.sock.bind((addr, port))
        except (OverflowError, OSError, socket.error) as error:
            self.log.error("Binding socket to {}:{} failed: {}".format(addr, port, error))
            sys.exit(1)

    def listen(self):
        """Listen for connections made to the socket."""
        try:
            self.log.debug("Listening with backlog={}".format(self.options["backlog"]))
            self.sock.listen(self.options["backlog"])
        except socket.error as error:
            self.log.error("Listening failed: {}".format(error))
            sys.exit(1)

    def accept(self):
        """Accept a connection."""
        try:
            self.log.debug("Waiting for TCP client")
            self.conn, client = self.sock.accept()
            addr, port = client
            self.log.info("Client connected from {}:{}".format(addr, port))
        except (socket.gaierror, socket.error) as error:
            self.log.error("Accept failed: {}".format(error))
            sys.exit(1)

    def connect(self):
        """Connect to a remote socket at given address and port (TCP-only)."""
        try:
            self.log.debug("Connecting to {}:{}".format(self.remote_addr, self.remote_port))
            self.sock.connect((self.remote_addr, self.remote_port))
            return True
        except socket.error as error:
            self.log.error(
                "Connecting to {}:{} failed: {}".format(self.remote_addr, self.remote_port, error)
            )
            return False

    # ------------------------------------------------------------------------------
    # Send / Receive Functions
    # ------------------------------------------------------------------------------
    def send(self, data):
        """Send data."""
        # In case of sending data back to an udp client we need to wait
        # until the client has first connected and told us its addr/port
        if self.options["udp"] and self.udp_client_addr is None and self.udp_client_port is None:
            self.log.info("Waiting for UDP client to connect")
            while self.udp_client_addr is None and self.udp_client_port is None:
                pass

        send = 0
        size = len(data)
        data = self.enc.encode(data)
        assert size == len(data), "Encoding messed up string length, might need to do len() after."
        # Loop until all bytes have been send
        while send < size:
            if self.conn is None:
                self.log.error("Socket is gone")
                return
            try:
                self.log.trace("Trying to send: {}".format(data))
                if self.options["udp"]:
                    send += self.conn.sendto(data, (self.udp_client_addr, self.udp_client_port))
                else:
                    send += self.conn.send(data)
                # Remove 'send' many bytes from data
                data = data[send:]
            except (OSError, socket.error) as error:
                self.log.error("Send Error: {}".format(error))
                # exit the thread gracefully (program shuts down fine)
                return

    def receive(self):
        """Generate received data endlessly by yielding it."""
        while True:
            if self.conn is None:
                self.log.error("Socket is gone")
                return
            try:
                self.log.trace(
                    "Waiting to receive data (bufsize={})...".format(self.options["bufsize"])
                )
                (byte, addr) = self.conn.recvfrom(self.options["bufsize"])
                data = byte
                data = self.enc.decode(byte)
                self.log.trace("Received: {}".format(data))

                # If we're receiving data from a UDP client
                # we can firstly/finally set its addr/port in order
                # to send data back to it (see send() function)
                if self.options["udp"]:
                    self.udp_client_addr, self.udp_client_port = addr
                    # Avoid the noise on UDP connections to spam on every send
                    if self.udp_client_addr is None or self.udp_client_port is None:
                        self.log.info(
                            "Client connected: {}:{}".format(
                                self.udp_client_addr, self.udp_client_port
                            )
                        )
                    # Find for debug
                    else:
                        self.log.debug(
                            "Client connected: {}:{}".format(
                                self.udp_client_addr, self.udp_client_port
                            )
                        )

            except socket.error as error:
                self.log.error("Receive Error: {}".format(error))
                sys.exit(1)

            if not data:
                # Upstream (server or client) is gone. Do we reconnect or quit?
                self.log.warning("Upstream connection is gone")
                if self.role == "server":
                    if not self.__reaccept_from_client():
                        sys.exit(0)
                if self.role == "client":
                    if not self.__reconnect_to_server():
                        sys.exit(0)

            yield data


# -------------------------------------------------------------------------------------------------
# CLASS: StringEncoder
# -------------------------------------------------------------------------------------------------
class StringEncoder(object):
    """
    Takes care about Python 2/3 string encoding/decoding.

    This allows to parse all string/byte values internally between all
    classes or functions as strings to keep full Python 2/3 compat.
    """

    # https://stackoverflow.com/questions/606191/27527728#27527728
    codec = "cp437"

    def __init__(self, logger):
        self.log = logger
        self.py3 = sys.version_info >= (3, 0)

    def encode(self, data):
        """Convert string into a byte type for Python3."""
        if self.py3:
            self.log.trace("Encoding: {}".format(data))
            data = data.encode("cp437")
            self.log.trace("Encoded: {}".format(data))
        return data

    def decode(self, data):
        """Convert bytes into a string type for Python3."""
        if self.py3:
            self.log.trace("Decoding: {}".format(data))
            data = data.decode("cp437")
            self.log.trace("Decoded: {}".format(data))
        return data


# -------------------------------------------------------------------------------------------------
# CLASS: Logger
# -------------------------------------------------------------------------------------------------
class Logger(object):
    """Logger class."""

    # ------------------------------------------------------------------------------
    # Constructor / Destructor
    # ------------------------------------------------------------------------------
    def __init__(self, verbosity=1):
        """Constructor.

        verbosity == 0: Log errors
        verbosity == 1: Log errors, warnings
        verbosity == 2: Log errors, warnings, info
        verbosity == 3: Log errors, warnings, info, debug, class/func names
        verbosity == 4: Log errors, warnings, info, debug, trace, class/func names
        """
        assert verbosity >= 0, "Verbosity cannot be less than 0."
        self.verbosity = verbosity

    # ------------------------------------------------------------------------------
    # Public Functions
    # ------------------------------------------------------------------------------
    def error(self, message):
        """Log error messages."""
        if self.verbosity > 2:
            _stack = inspect.stack()[1]
            cls = _stack[0].f_locals["self"].__class__.__name__
            fnc = _stack[3]
            print("[ERROR] %s.%s(): %s" % (cls, fnc, repr(message)), file=sys.stderr)
        else:
            print("[ERROR] %s" % repr(message), file=sys.stderr)

    def warning(self, message):
        """Log warning messages."""
        if self.verbosity > 2:
            _stack = inspect.stack()[1]
            cls = _stack[0].f_locals["self"].__class__.__name__
            fnc = _stack[3]
            print("[WARN]  %s.%s(): %s" % (cls, fnc, repr(message)), file=sys.stderr)
        elif self.verbosity > 0:
            print("[WARN]  %s" % repr(message), file=sys.stderr)

    def info(self, message):
        """Log info messages."""
        if self.verbosity > 2:
            _stack = inspect.stack()[1]
            cls = _stack[0].f_locals["self"].__class__.__name__
            fnc = _stack[3]
            print("[INFO]  %s.%s(): %s" % (cls, fnc, repr(message)), file=sys.stderr)
        elif self.verbosity > 1:
            print("[INFO]  %s" % repr(message), file=sys.stderr)

    def debug(self, message):
        """Log debug messages."""
        if self.verbosity > 2:
            _stack = inspect.stack()[1]
            cls = _stack[0].f_locals["self"].__class__.__name__
            fnc = _stack[3]
            print("[DEBUG] %s.%s(): %s" % (cls, fnc, repr(message)), file=sys.stderr)
        elif self.verbosity > 2:
            print("[DEBUG] %s" % repr(message), file=sys.stderr)

    def trace(self, message):
        """Log trace messages."""
        if self.verbosity > 3:
            _stack = inspect.stack()[1]
            cls = _stack[0].f_locals["self"].__class__.__name__
            fnc = _stack[3]
            print("[TRACE] %s.%s(): %s" % (cls, fnc, repr(message)), file=sys.stderr)


# -------------------------------------------------------------------------------------------------
# CLASS: Runner
# -------------------------------------------------------------------------------------------------
class Runner(object):
    """Runner class that takes care about putting everything into threads."""

    # ------------------------------------------------------------------------------
    # Constructor / Destructor
    # ------------------------------------------------------------------------------
    def __init__(self, logger):
        """Constructor."""
        self.log = logger

    # ------------------------------------------------------------------------------
    # Public Functions
    # ------------------------------------------------------------------------------
    def set_recv_generator(self, func):
        """Set generator func which constantly receives network data."""
        self.recv_generator = func

    def set_input_generator(self, func):
        """Set generator func which constantly receives input (shell output/user input)."""
        self.input_generator = func

    def set_send_callback(self, func):
        """Set the callback for sending data to a socket."""
        self.send_callback = func

    def set_output_callback(self, func):
        """Set the callback for outputting data to stdin/stdout."""
        self.output_callback = func

    def set_time_action(self, intvl, func, *args, **kwargs):
        """Set a function that should be called periodically."""
        self.timed_action_intvl = intvl
        self.timed_action_func = func
        self.timed_action_args = args
        self.timed_action_kwargs = kwargs

    def run(self):
        """Run threaded NetCat."""

        assert hasattr(self, "recv_generator"), "Error, recv_generator not set"
        assert hasattr(self, "input_generator"), "Error, input_generator not set"
        assert hasattr(self, "send_callback"), "Error, send_callback not set"
        assert hasattr(self, "output_callback"), "Error, output_callback not set"

        def receiver():
            """Receive data from a socket and process it with a callback.

            receive: Must be a generator function to receive network data.
            callback: Must be a callback to process received data, e.g.: print to stdin/stdout.
            """
            while True:
                self.log.trace("[Thread] receiver loop")
                for data in self.recv_generator():
                    self.log.trace("[Thread] receiver received: {}".format(data))
                    self.output_callback(data)

        def sender():
            """Receive data from user-input/command-output and process it with a callback.

            receive: Must be a generator function to receive user-input or command output.
            callback: Must be a callback to send this data to a socket.
            """
            while True:
                self.log.trace("[Thread] sender")
                for data in self.input_generator():
                    self.log.trace("[Thread] sender received: {}".format(data))
                    self.send_callback(data)

        def timer():
            """Execute periodic tasks by an optional provided time_action."""
            self.log.debug(
                "Ready for timed action every {} seconds".format(self.timed_action_intvl)
            )
            time_last = int(time.time())
            while True:
                time_now = int(time.time())
                if time_now > time_last + self.timed_action_intvl:
                    self.log.debug("[{}] Executing timed function".format(time_now))
                    self.timed_action_func(*self.timed_action_args, **self.timed_action_kwargs)
                    time_last = time_now  # Reset previous time
                time.sleep(1)

        # Start sending and receiving threads
        tr = threading.Thread(target=receiver)
        ts = threading.Thread(target=sender)
        # If the main thread kills, this thread will be killed too.
        tr.daemon = True
        ts.daemon = True
        # Start threads
        tr.start()
        self.log.trace("Receiving thread started")
        ts.start()
        self.log.trace("Sending thread started")

        if hasattr(self, "timed_action_intvl"):
            tt = threading.Thread(target=timer)
            tt.daemon = True
            tt.start()
            self.log.trace("Timer thread started")

        # Cleanup the main program
        while True:
            if not tr.is_alive():
                sys.exit(0)
            if not ts.is_alive():
                sys.exit(0)
            if hasattr(self, "time_action_intvl"):
                if not tt.is_alive():
                    sys.exit(0)


# -------------------------------------------------------------------------------------------------
# CLASS: NetcatModuleOutput (Module for: user-input -> send -> receive -> output)
# -------------------------------------------------------------------------------------------------
class NetcatModuleOutput(AbstractNetcatModule):
    """Implement basic chat module functionality."""

    linefeed = "\n"

    # ------------------------------------------------------------------------------
    # Constructor / Destructor
    # ------------------------------------------------------------------------------
    def __init__(self, logger, encoder, options={}):
        """Set specific options for this module."""
        self.log = logger
        self.enc = encoder
        if "linefeed" in options:
            self.linefeed = options["linefeed"]

    # ------------------------------------------------------------------------------
    # Public Functions
    # ------------------------------------------------------------------------------
    def input_generator(self):
        """Constantly ask for user input."""
        while True:
            data = input()
            yield data + self.linefeed

    def output_callback(self, data):
        """Print received data to stdout."""
        if data.endswith("\r\n"):
            data = data[:-2]
        elif data.endswith("\n") or data.endswith("\r"):
            data = data[:-1]
        print(data)


# -------------------------------------------------------------------------------------------------
# CLASS: NetcatModuleCommand (Module for user-input -> send -> execute -> send-back -> output)
# -------------------------------------------------------------------------------------------------
class NetcatModuleCommand(AbstractNetcatModule):
    """Implement command execution functionality."""

    executable = None

    # ------------------------------------------------------------------------------
    # Constructor / Destructor
    # ------------------------------------------------------------------------------
    def __init__(self, logger, encoder, options={}):
        """Set specific options for this module."""
        self.log = logger
        self.enc = encoder
        assert "executable" in options
        self.log.debug("Setting '{}' as executable".format(options["executable"]))
        self.executable = options["executable"]

        # Open executable to wait for commands
        env = os.environ.copy()
        self.p = Popen(
            self.executable, stdin=PIPE, stdout=PIPE, stderr=subprocess.STDOUT, shell=False, env=env
        )
        # Define destructor
        atexit.register(self.__exit__)

    def __exit__(self):
        """Destructor."""
        self.log.trace("Killing executable: {} with pid {}".format(self.executable, self.p.pid))
        self.p.kill()

    # ------------------------------------------------------------------------------
    # Public Functions
    # ------------------------------------------------------------------------------
    def input_generator(self):
        """Constantly ask for input."""
        while True:
            self.log.trace("Reading command output")
            data = self.p.stdout.readline()  # Much better performance than self.p.read(1)
            data = self.enc.decode(data)
            self.log.trace("Command output: {}".format(data))
            if not data:
                self.log.error("No program output received")
                break
            yield data

    def output_callback(self, data):
        """Send data received to stdin (command input)."""
        data = self.enc.encode(data)
        self.log.trace("Appending to stdin: {}".format(data))
        self.p.stdin.write(data)
        self.p.stdin.flush()


# -------------------------------------------------------------------------------------------------
# CLASS: NetcatServer
# -------------------------------------------------------------------------------------------------
class NetcatServer(AbstractSocket):
    """Netcat Server implementation."""

    def __init__(self, logger, encoder, host, port, options={}):
        """Construct a listening server."""
        super(NetcatServer, self).__init__(logger, encoder, "server", options)

        # Setup server
        addr = self.gethostbyname(host)
        self.create_socket()
        self.bind(addr, port)
        if self.options["udp"]:
            self.conn = self.sock
            self.log.info("Waiting on {}:{} (UDP)".format(addr, port))
        else:
            self.listen()
            self.log.info("Listening on {}:{} (TCP)".format(addr, port))
            self.accept()


# -------------------------------------------------------------------------------------------------
# CLASS: NetcatClient
# -------------------------------------------------------------------------------------------------
class NetcatClient(AbstractSocket):
    """Netcat Client implementation."""

    def __init__(self, logger, encoder, host, port, options={}):
        """Construct a connecting clientt."""
        super(NetcatClient, self).__init__(logger, encoder, "client", options)

        # Setup client
        addr = self.gethostbyname(host)
        self.create_socket()
        self.conn = self.sock
        if self.options["udp"]:
            self.udp_client_addr = addr
            self.udp_client_port = port
        else:
            self.remote_addr = addr
            self.remote_port = port
            if not self.connect():
                sys.exit(1)


# -------------------------------------------------------------------------------------------------
# COMMAND LINE ARGUMENTS
# -------------------------------------------------------------------------------------------------


def get_version():
    """Return version information."""
    return """%(prog)s: Version %(version)s (%(url)s) by %(author)s""" % (
        {"prog": APPNAME, "version": VERSION, "url": APPREPO, "author": "cytopia"}
    )


def _args_check_port(value):
    """Check arguments for invalid port number."""
    min_port = 1
    max_port = 65535
    intvalue = int(value)

    if intvalue < min_port or intvalue > max_port:
        raise argparse.ArgumentTypeError("%s is an invalid port number" % value)
    return intvalue


def _args_check_forwards(value):
    """Check forward argument (-L/-R) for correct pattern."""
    match = re.search(r"(.+):(.+)", value)
    if match is None or len(match.groups()) != 2:
        raise argparse.ArgumentTypeError("%s is not a valid 'addr:port' format." % value)
    _args_check_port(match.group(2))
    return value


def _args_check_reinit(value):
    """Check reinit argument for correct value."""
    intvalue = int(value)
    if intvalue < 0:
        raise argparse.ArgumentTypeError("must be equal or greater than 0." % value)
    return intvalue


def _args_check_reconn(value):
    """Check reconn argument for correct value."""
    intvalue = int(value)
    if intvalue < 0:
        raise argparse.ArgumentTypeError("must be equal or greater than 0." % value)
    return intvalue


def _args_check_robin_ports(value):
    """Check reinit-robin argument for comma separated string or range."""
    mcomma = re.search(r"^[0-9]+(,([0-9]+))*$", value)
    mrange = re.search(r"^[0-9]+\-[0-9]+$", value)

    if mcomma is None:
        if mrange is None:
            raise argparse.ArgumentTypeError("%s is not a valid port specifier" % value)

    if mcomma:
        ports = mcomma.group(0).split(",")
        for port in ports:
            _args_check_port(port)
        return ports

    if mrange:
        ranges = mrange.group(0).split("-")
        if int(ranges[0]) >= (int(ranges[1]) + 1):
            raise argparse.ArgumentTypeError(
                "Left side of range must be smaller or equal than right side."
            )
        ports = []
        for port in range(int(ranges[0]), int(ranges[1]) + 1):
            _args_check_port(port)
            ports.append(port)
        return ports


def _args_check_mutually_exclusive(parser, args):
    """Check mutually exclusive arguments."""

    # [MODE] --listen
    if args.listen and (args.zero or args.local or args.remote):
        parser.print_usage()
        print(
            "%s: error: -l/--listen mutually exclusive with -z/-zero, -L/--local or -R/--remote"
            % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # [MODE] --zero
    if args.zero and (args.listen or args.local or args.remote):
        parser.print_usage()
        print(
            "%s: error: -z/--zero mutually exclusive with -l/--listen, -L/--local or -R/--remote"
            % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # [MODE --local
    if args.local and (args.listen or args.zero or args.remote):
        parser.print_usage()
        print(
            "%s: error: -L/--local mutually exclusive with -l/--listen, -z/--zero or -R/--remote"
            % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # [MODE] --remote
    if args.remote and (args.listen or args.zero or args.local):
        parser.print_usage()
        print(
            "%s: error: -R/--remote mutually exclusive with -l/--listen, -z/--zero or -L/--local"
            % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # [MODULE] --exec
    if args.cmd and (args.local or args.remote or args.zero):
        parser.print_usage()
        print(
            "%s: error: -e/--exec mutually exclusive with -L/--local, -R/-remote or -z/--zero"
            % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # [OPTIONS] --udp
    if args.udp and args.zero:
        parser.print_usage()
        print(
            "%s: error: -u/--udp mutually exclusive with -z/--zero" % (APPNAME), file=sys.stderr,
        )
        sys.exit(1)

    # [ADVANCED] --reinit
    if args.reinit is not False and (args.udp or args.local or args.remote):
        parser.print_usage()
        print(
            "%s: error: --reinit mutually exclusive with -u/--udp, -L/--local or -R/--remote"
            % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # [ADVANCED] --reconn
    if args.reconn is not False and (args.udp or args.local or args.remote or args.zero):
        parser.print_usage()
        print(
            "%s: error: --reinit mutually excl. with -u/--udp, -L/--local -R/--remote or -z/--zero"
            % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # [ADVANCED] --udp-ping-interval
    if args.udp_ping_intvl and not args.udp:
        parser.print_usage()
        print(
            "%s: error: --udp-ping-intvl mutually exclusive with -u/--udp" % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)


def get_args():
    """Retrieve command line arguments."""
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawTextHelpFormatter,
        add_help=False,
        usage="""%(prog)s [-Cnuv] [-e cmd] hostname port
       %(prog)s [-Cnuv] [-e cmd] -l [hostname] port
       %(prog)s [-Cnuv] -z hostname port
       %(prog)s [-Cnuv] -L addr:port [hostname] port
       %(prog)s [-Cnuv] -R addr:port hostname port
       %(prog)s -V, --version
       %(prog)s -h, --help
       """
        % ({"prog": APPNAME}),
        description="""
Enhanced and comptaible Netcat implementation written in Python (2 and 3) with
connect, zero-i/o, listen and forward modes and techniques to detect and evade
firewalls and intrusion prevention systems.""",
    )

    positional = parser.add_argument_group("positional arguments")
    mode = parser.add_argument_group("mode arguments")
    optional = parser.add_argument_group("optional arguments")
    advanced = parser.add_argument_group("advanced arguments")
    misc = parser.add_argument_group("misc arguments")

    positional.add_argument(
        "hostname", nargs="?", type=str, help="Address to listen, forward or connect to"
    )
    positional.add_argument(
        "port", type=_args_check_port, help="Port to listen, forward or connect to"
    )

    mode.add_argument(
        "-l",
        "--listen",
        action="store_true",
        default=False,
        help="""[Listen mode]:
Start server and listen for incoming connections.

""",
    )
    mode.add_argument(
        "-z",
        "--zero",
        action="store_true",
        default=False,
        help="""[Zero-I/0 mode]:
Connect to a remote endpoint and report status only.

""",
    )
    mode.add_argument(
        "-L",
        "--local",
        metavar="addr:port",
        default=False,
        type=_args_check_forwards,
        help="""[Local forward mode]:
Specify local <addr>:<port> to which traffic should be
forwarded to. %(prog)s will listen locally
(specified by hostname and port) and forward all
traffic to the specified value for -L/--local.

"""
        % ({"prog": APPNAME}),
    )
    mode.add_argument(
        "-R",
        "--remote",
        metavar="addr:port",
        default=False,
        type=_args_check_forwards,
        help="""[Remote forward mode]:
Specify local <addr>:<port> from which traffic should be
forwarded from. %(prog)s will connect remotely
(specified by hostname and port) and for ward all
traffic from the specified value for -R/--remote.
"""
        % ({"prog": APPNAME}),
    )

    optional.add_argument(
        "-e",
        "--exec",
        metavar="cmd",
        dest="cmd",
        default=False,
        type=str,
        help="Execute shell command. Only for connect or listen mode.",
    )
    optional.add_argument(
        "-C",
        "--crlf",
        action="store_true",
        default=False,
        help="Send CRLF line-endings in connect mode (default: LF)",
    )
    optional.add_argument(
        "-n", "--nodns", action="store_true", default=False, help="Do not resolve DNS.",
    )
    optional.add_argument("-u", "--udp", action="store_true", default=False, help="UDP mode")
    optional.add_argument(
        "-v",
        "--verbose",
        action="count",
        default=0,
        help="""Be verbose and print info to stderr. Use -v, -vv, -vvv
or -vvvv for more verbosity. The server performance will
decrease drastically if you use more than three -v.""",
    )
    advanced.add_argument(
        "--reinit",
        metavar="x",
        default=False,
        type=_args_check_reinit,
        help="""Listen mode (TCP only):
If the server is unable to bind or accept clients, it
will re-initialize itself x many times before giving up.
Use 0 to re-initialize endlessly. (default: don't).

Connect mode (TCP only):
If the client is unable to connect to a remote endpoint,
it will try again x many times before giving up.
Use 0 to retry endlessly. (default: don't)

Zero-I/O mode (TCP only):
Same as connect mode.

""",
    )
    advanced.add_argument(
        "--reconn",
        metavar="x",
        default=False,
        type=_args_check_reconn,
        help="""Listen mode (TCP only):
If the client has hung up, the server will re-accept a
new client x many times before quitting. Use 0 to accept
endlessly. (default: quit after a client has hung up)

Connect mode (TCP only):
If the remote server is gone, the client will re-connect
to it x many times before giving up. Use 0 to reconnect
endlessy. (default: don't)
This might be handy for reverse shells ;-)

""",
    )
    advanced.add_argument(
        "--reinit-robin",
        metavar="port",
        default=[],
        type=_args_check_robin_ports,
        help="""Connect mode (TCP only):
If the client does multiple initial connections to a
remote endpoint (via --reinit), this option instructs it
to also "round-robin" different ports to connect to. It
will stop iterating after first successfull connection
and stick with it or quit if --reinit limit is reached.
Use comma separated string: 80,81,82 or a range 80-100.
Set --reinit to at least the number of ports to probe +1
Set --reinit-wait to 0
This helps to evade EGRESS firewalls for reverse shells
Use with -z/--zero to probe outbound allowed ports.
Ensure to have enough listeners at the remote endpoint.

""",
    )
    advanced.add_argument(
        "--reconn-robin",
        metavar="port",
        default=[],
        type=_args_check_robin_ports,
        help="""Connect mode (TCP only):
If the remote endpoint is gone after initial successful
connection, and the the client is set to reconnect with
(--reconn), it will connect back by "round-robin" to
different ports. It will stop after --reconn limit has
reached.
Set --reconn to at least the number of ports to probe +1
Set --reconn-wait to 0
This help your reverse shell to evade intrusion
prevention systems that will cut your connection and
block the outbound port.

""",
    )
    advanced.add_argument(
        "--reinit-wait",
        metavar="s",
        default=1,
        type=int,
        help="Wait x seconds between re-inits. (default: 1)\n\n",
    )
    advanced.add_argument(
        "--reconn-wait",
        metavar="s",
        default=1,
        type=int,
        help="Wait x seconds between re-connects. (default: 1)\n\n",
    )
    advanced.add_argument(
        "--udp-ping-intvl",
        metavar="s",
        default=False,
        type=int,
        help="""Connect mode (UDP only):
As UDP is stateless, a client must first connect to a
server before the server can communicate with it.
If you listen on UDP and wait for a reverse UDP client
or reverse UDP shell, you can only talk to it after it
has sent you some initial data, as UDP does not have a
"connect" state like TCP.
This option instructs the UDP client to send a single
newline every s seconds. By not only doing it once,
but in intervals, you can also maintain a connection
if you restart your listening server.
""",
    )
    misc.add_argument("-h", "--help", action="help", help="Show this help message and exit")
    misc.add_argument(
        "-V",
        "--version",
        action="version",
        version=get_version(),
        help="Show version information and exit",
    )

    # Retrieve arguments
    args = parser.parse_args()

    # Check mutually exclive arguments
    _args_check_mutually_exclusive(parser, args)

    # TODO: Exit on unimplemented features
    if args.local or args.remote:
        parser.print_usage()
        print(
            "%s: error: -L/--local and -R/--remote are not yet implemented" % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    return args


# -------------------------------------------------------------------------------------------------
# MAIN ENTRYPOINT
# -------------------------------------------------------------------------------------------------
def main():
    """Run the program."""
    args = get_args()

    host = args.hostname if args.hostname is not None else "0.0.0.0"
    port = args.port

    # TODO: :-)
    # * Retry feature for reverse shell
    # * Reconnect at different ports (round robin)
    # * Make binaries for windows!!!

    # Set netcat options
    net_opts = {
        "udp": args.udp,
        "bufsize": 1024,
        "backlog": 0,
        "nodns": args.nodns,
        "reinit": True if (type(args.reinit) is int and args.reinit == 0) else args.reinit,
        "reconn": True if (type(args.reconn) is int and args.reconn == 0) else args.reconn,
        "reinit_robin": args.reinit_robin,
        "reconn_robin": args.reconn_robin,
        "reinit_wait": args.reinit_wait,
        "reconn_wait": args.reconn_wait,
        "udp_ping_intvl": args.udp_ping_intvl,  # only for udp client and only for rev-shell (0:off)
    }

    # Initialize logger
    logger = Logger(args.verbose)

    # Initialize encoder
    encoder = StringEncoder(logger)

    # Use command modulde
    if args.cmd:
        module_opts = {"executable": args.cmd}
        mod = NetcatModuleCommand(logger, encoder, module_opts)
    # Use output module
    else:
        module_opts = {"linefeed": "\r\n" if args.crlf else "\n"}
        mod = NetcatModuleOutput(logger, encoder, module_opts)

    # Run server
    if args.listen:
        net = NetcatServer(logger, encoder, host, port, net_opts)
        run = Runner(logger)
        run.set_recv_generator(net.receive)
        run.set_input_generator(mod.input_generator)
        run.set_send_callback(net.send)
        run.set_output_callback(mod.output_callback)
        run.run()
    # Run client
    else:
        net = NetcatClient(logger, encoder, host, port, net_opts)
        run = Runner(logger)
        run.set_recv_generator(net.receive)
        run.set_input_generator(mod.input_generator)
        run.set_send_callback(net.send)
        run.set_output_callback(mod.output_callback)
        if type(args.udp_ping_intvl) is int and args.udp_ping_intvl > 0:
            run.set_time_action(args.udp_ping_intvl, net.send, "\x00")
        run.run()


if __name__ == "__main__":
    # Catch Ctrl+c and exit without error message
    try:
        main()
    except KeyboardInterrupt:
        print()
        sys.exit(1)
</code></pre>
  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="pwncat.APPNAME" class="name">var <span class="ident">APPNAME</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pwncat.APPREPO" class="name">var <span class="ident">APPREPO</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pwncat.PIPE" class="name">var <span class="ident">PIPE</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pwncat.VERSION" class="name">var <span class="ident">VERSION</span></p>
      
  
  <div class="source_cont">
</div>

      </div>

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="pwncat.get_args">
    <p>def <span class="ident">get_args</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>Retrieve command line arguments.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.get_args', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.get_args" class="source">
    <pre><code>def get_args():
    """Retrieve command line arguments."""
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawTextHelpFormatter,
        add_help=False,
        usage="""%(prog)s [-Cnuv] [-e cmd] hostname port
       %(prog)s [-Cnuv] [-e cmd] -l [hostname] port
       %(prog)s [-Cnuv] -z hostname port
       %(prog)s [-Cnuv] -L addr:port [hostname] port
       %(prog)s [-Cnuv] -R addr:port hostname port
       %(prog)s -V, --version
       %(prog)s -h, --help
       """
        % ({"prog": APPNAME}),
        description="""
Enhanced and comptaible Netcat implementation written in Python (2 and 3) with
connect, zero-i/o, listen and forward modes and techniques to detect and evade
firewalls and intrusion prevention systems.""",
    )

    positional = parser.add_argument_group("positional arguments")
    mode = parser.add_argument_group("mode arguments")
    optional = parser.add_argument_group("optional arguments")
    advanced = parser.add_argument_group("advanced arguments")
    misc = parser.add_argument_group("misc arguments")

    positional.add_argument(
        "hostname", nargs="?", type=str, help="Address to listen, forward or connect to"
    )
    positional.add_argument(
        "port", type=_args_check_port, help="Port to listen, forward or connect to"
    )

    mode.add_argument(
        "-l",
        "--listen",
        action="store_true",
        default=False,
        help="""[Listen mode]:
Start server and listen for incoming connections.

""",
    )
    mode.add_argument(
        "-z",
        "--zero",
        action="store_true",
        default=False,
        help="""[Zero-I/0 mode]:
Connect to a remote endpoint and report status only.

""",
    )
    mode.add_argument(
        "-L",
        "--local",
        metavar="addr:port",
        default=False,
        type=_args_check_forwards,
        help="""[Local forward mode]:
Specify local <addr>:<port> to which traffic should be
forwarded to. %(prog)s will listen locally
(specified by hostname and port) and forward all
traffic to the specified value for -L/--local.

"""
        % ({"prog": APPNAME}),
    )
    mode.add_argument(
        "-R",
        "--remote",
        metavar="addr:port",
        default=False,
        type=_args_check_forwards,
        help="""[Remote forward mode]:
Specify local <addr>:<port> from which traffic should be
forwarded from. %(prog)s will connect remotely
(specified by hostname and port) and for ward all
traffic from the specified value for -R/--remote.
"""
        % ({"prog": APPNAME}),
    )

    optional.add_argument(
        "-e",
        "--exec",
        metavar="cmd",
        dest="cmd",
        default=False,
        type=str,
        help="Execute shell command. Only for connect or listen mode.",
    )
    optional.add_argument(
        "-C",
        "--crlf",
        action="store_true",
        default=False,
        help="Send CRLF line-endings in connect mode (default: LF)",
    )
    optional.add_argument(
        "-n", "--nodns", action="store_true", default=False, help="Do not resolve DNS.",
    )
    optional.add_argument("-u", "--udp", action="store_true", default=False, help="UDP mode")
    optional.add_argument(
        "-v",
        "--verbose",
        action="count",
        default=0,
        help="""Be verbose and print info to stderr. Use -v, -vv, -vvv
or -vvvv for more verbosity. The server performance will
decrease drastically if you use more than three -v.""",
    )
    advanced.add_argument(
        "--reinit",
        metavar="x",
        default=False,
        type=_args_check_reinit,
        help="""Listen mode (TCP only):
If the server is unable to bind or accept clients, it
will re-initialize itself x many times before giving up.
Use 0 to re-initialize endlessly. (default: don't).

Connect mode (TCP only):
If the client is unable to connect to a remote endpoint,
it will try again x many times before giving up.
Use 0 to retry endlessly. (default: don't)

Zero-I/O mode (TCP only):
Same as connect mode.

""",
    )
    advanced.add_argument(
        "--reconn",
        metavar="x",
        default=False,
        type=_args_check_reconn,
        help="""Listen mode (TCP only):
If the client has hung up, the server will re-accept a
new client x many times before quitting. Use 0 to accept
endlessly. (default: quit after a client has hung up)

Connect mode (TCP only):
If the remote server is gone, the client will re-connect
to it x many times before giving up. Use 0 to reconnect
endlessy. (default: don't)
This might be handy for reverse shells ;-)

""",
    )
    advanced.add_argument(
        "--reinit-robin",
        metavar="port",
        default=[],
        type=_args_check_robin_ports,
        help="""Connect mode (TCP only):
If the client does multiple initial connections to a
remote endpoint (via --reinit), this option instructs it
to also "round-robin" different ports to connect to. It
will stop iterating after first successfull connection
and stick with it or quit if --reinit limit is reached.
Use comma separated string: 80,81,82 or a range 80-100.
Set --reinit to at least the number of ports to probe +1
Set --reinit-wait to 0
This helps to evade EGRESS firewalls for reverse shells
Use with -z/--zero to probe outbound allowed ports.
Ensure to have enough listeners at the remote endpoint.

""",
    )
    advanced.add_argument(
        "--reconn-robin",
        metavar="port",
        default=[],
        type=_args_check_robin_ports,
        help="""Connect mode (TCP only):
If the remote endpoint is gone after initial successful
connection, and the the client is set to reconnect with
(--reconn), it will connect back by "round-robin" to
different ports. It will stop after --reconn limit has
reached.
Set --reconn to at least the number of ports to probe +1
Set --reconn-wait to 0
This help your reverse shell to evade intrusion
prevention systems that will cut your connection and
block the outbound port.

""",
    )
    advanced.add_argument(
        "--reinit-wait",
        metavar="s",
        default=1,
        type=int,
        help="Wait x seconds between re-inits. (default: 1)\n\n",
    )
    advanced.add_argument(
        "--reconn-wait",
        metavar="s",
        default=1,
        type=int,
        help="Wait x seconds between re-connects. (default: 1)\n\n",
    )
    advanced.add_argument(
        "--udp-ping-intvl",
        metavar="s",
        default=False,
        type=int,
        help="""Connect mode (UDP only):
As UDP is stateless, a client must first connect to a
server before the server can communicate with it.
If you listen on UDP and wait for a reverse UDP client
or reverse UDP shell, you can only talk to it after it
has sent you some initial data, as UDP does not have a
"connect" state like TCP.
This option instructs the UDP client to send a single
newline every s seconds. By not only doing it once,
but in intervals, you can also maintain a connection
if you restart your listening server.
""",
    )
    misc.add_argument("-h", "--help", action="help", help="Show this help message and exit")
    misc.add_argument(
        "-V",
        "--version",
        action="version",
        version=get_version(),
        help="Show version information and exit",
    )

    # Retrieve arguments
    args = parser.parse_args()

    # Check mutually exclive arguments
    _args_check_mutually_exclusive(parser, args)

    # TODO: Exit on unimplemented features
    if args.local or args.remote:
        parser.print_usage()
        print(
            "%s: error: -L/--local and -R/--remote are not yet implemented" % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    return args
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pwncat.get_version">
    <p>def <span class="ident">get_version</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>Return version information.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.get_version', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.get_version" class="source">
    <pre><code>def get_version():
    """Return version information."""
    return """%(prog)s: Version %(version)s (%(url)s) by %(author)s""" % (
        {"prog": APPNAME, "version": VERSION, "url": APPREPO, "author": "cytopia"}
    )
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pwncat.main">
    <p>def <span class="ident">main</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>Run the program.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.main', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.main" class="source">
    <pre><code>def main():
    """Run the program."""
    args = get_args()

    host = args.hostname if args.hostname is not None else "0.0.0.0"
    port = args.port

    # TODO: :-)
    # * Retry feature for reverse shell
    # * Reconnect at different ports (round robin)
    # * Make binaries for windows!!!

    # Set netcat options
    net_opts = {
        "udp": args.udp,
        "bufsize": 1024,
        "backlog": 0,
        "nodns": args.nodns,
        "reinit": True if (type(args.reinit) is int and args.reinit == 0) else args.reinit,
        "reconn": True if (type(args.reconn) is int and args.reconn == 0) else args.reconn,
        "reinit_robin": args.reinit_robin,
        "reconn_robin": args.reconn_robin,
        "reinit_wait": args.reinit_wait,
        "reconn_wait": args.reconn_wait,
        "udp_ping_intvl": args.udp_ping_intvl,  # only for udp client and only for rev-shell (0:off)
    }

    # Initialize logger
    logger = Logger(args.verbose)

    # Initialize encoder
    encoder = StringEncoder(logger)

    # Use command modulde
    if args.cmd:
        module_opts = {"executable": args.cmd}
        mod = NetcatModuleCommand(logger, encoder, module_opts)
    # Use output module
    else:
        module_opts = {"linefeed": "\r\n" if args.crlf else "\n"}
        mod = NetcatModuleOutput(logger, encoder, module_opts)

    # Run server
    if args.listen:
        net = NetcatServer(logger, encoder, host, port, net_opts)
        run = Runner(logger)
        run.set_recv_generator(net.receive)
        run.set_input_generator(mod.input_generator)
        run.set_send_callback(net.send)
        run.set_output_callback(mod.output_callback)
        run.run()
    # Run client
    else:
        net = NetcatClient(logger, encoder, host, port, net_opts)
        run = Runner(logger)
        run.set_recv_generator(net.receive)
        run.set_input_generator(mod.input_generator)
        run.set_send_callback(net.send)
        run.set_output_callback(mod.output_callback)
        if type(args.udp_ping_intvl) is int and args.udp_ping_intvl > 0:
            run.set_time_action(args.udp_ping_intvl, net.send, "\x00")
        run.run()
</code></pre>
  </div>
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="pwncat.AbstractNetcatModule" class="name">class <span class="ident">AbstractNetcatModule</span></p>
      
  
    <div class="desc"><p>Abstract class to for netcat modules.</p>
<p>This is a skeleton that defines how the modules for Netcat should look like.</p>
<p>The data_generator should constantly yield data received from sort sort of input
which could be user input, output from a shell command data from a socket.</p>
<p>The data_callback will apply some sort of action on the data received from a data_generator
which could be output to stdout, send it to the shell or to a socket.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractNetcatModule', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractNetcatModule" class="source">
    <pre><code>class AbstractNetcatModule:
    """
    Abstract class to for netcat modules.

    This is a skeleton that defines how the modules for Netcat should look like.

    The data_generator should constantly yield data received from sort sort of input
    which could be user input, output from a shell command data from a socket.

    The data_callback will apply some sort of action on the data received from a data_generator
    which could be output to stdout, send it to the shell or to a socket.
    """

    __metaclass__ = ABCMeta

    @abstractmethod
    def __init__(self, logger, encoder, options={}):
        """Set specific options for this module."""
        pass

    @abstractmethod
    def input_generator(self):
        """Implement a generator function which constantly yields data from some input."""
        while False:
            yield None

    @abstractmethod
    def output_callback(self, data):
        """Implement a callback which processes the input into some output."""
        print(data)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pwncat.AbstractNetcatModule">AbstractNetcatModule</a></li>
          <li><a href="/builtins.object.ext">builtins.object</a></li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractNetcatModule.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, logger, encoder, options={})</p>
    </div>
    

    
  
    <div class="desc"><p>Set specific options for this module.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractNetcatModule.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractNetcatModule.__init__" class="source">
    <pre><code>@abstractmethod
def __init__(self, logger, encoder, options={}):
    """Set specific options for this module."""
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractNetcatModule.input_generator">
    <p>def <span class="ident">input_generator</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Implement a generator function which constantly yields data from some input.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractNetcatModule.input_generator', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractNetcatModule.input_generator" class="source">
    <pre><code>@abstractmethod
def input_generator(self):
    """Implement a generator function which constantly yields data from some input."""
    while False:
        yield None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractNetcatModule.output_callback">
    <p>def <span class="ident">output_callback</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>Implement a callback which processes the input into some output.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractNetcatModule.output_callback', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractNetcatModule.output_callback" class="source">
    <pre><code>@abstractmethod
def output_callback(self, data):
    """Implement a callback which processes the input into some output."""
    print(data)
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="pwncat.AbstractSocket" class="name">class <span class="ident">AbstractSocket</span></p>
      
  
    <div class="desc"><p>Abstract class which provides TCP, UDP and IPv4, IPv6 Socket funcionality.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractSocket', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractSocket" class="source">
    <pre><code>class AbstractSocket(object):
    """Abstract class which provides TCP, UDP and IPv4, IPv6 Socket funcionality."""

    sock = None  # server binding socket (until accept())
    conn = None  # client/server communication socket

    # The instance role must be 'server' or 'client' and
    # is used to determine how to reconnect broken connections.
    # Either listen again (tcp-only) or re-connect to upstream.
    role = None  # Must be 'server' or 'client'

    options = {
        "udp": False,  # Is TCP or UDP server?
        "bufsize": 1024,  # Receive buffer size
        "backlog": 0,  # Listen backlog
        "nodns": False,  # Do not resolve hostnames
        "reinit": False,  # False (never), True (indefinite) or int for how many times to reinit
        "reconn": False,  # False (never), True (indefinite) or int for how many times to reconnect
        "reinit_robin": [],  # Ports to round-robin during failed init phase
        "reconn_robin": [],  # Ports to round-robin during failed phase (after 1st succ init)
        "reinit_wait": 0,  # Time in seconds to wait between reinits
        "reconn_wait": 0,  # Time in seconds to wait between reconnects
        "udp_ping_intvl": False,  # Interval in sec for UDP client to ping server
    }

    # In case the server is running in UDP mode,
    # it must wait for the client to connect in order
    # to retrieve its addr and port in order to be able
    # to send data back to it.
    udp_client_addr = None
    udp_client_port = None

    # For client role only
    # Store the address and port of the remote server to connect to.
    # This is required for self.connect()
    remote_addr = None
    remote_addr = None

    # ------------------------------------------------------------------------------
    # Constructor / Destructor
    # ------------------------------------------------------------------------------
    def __init__(self, logger, encoder, role, options={}):
        """Constructor."""
        assert type(self) is not AbstractSocket, "AbstractSocket cannot be instantiated directly."
        assert role in ["server", "client"], "The role must be 'server' or 'client'."

        self.log = logger
        self.enc = encoder
        self.role = role

        if "udp" in options:
            self.options["udp"] = options["udp"]
        if "bufsize" in options:
            self.options["bufsize"] = options["bufsize"]
        if "backlog" in options:
            self.options["backlog"] = options["backlog"]
        if "nodns" in options:
            self.options["nodns"] = options["nodns"]
        if "reinit" in options:
            self.options["reinit"] = options["reinit"]
        if "reconn" in options:
            self.options["reconn"] = options["reconn"]
        if "reinit_robin" in options:
            self.options["reinit_robin"] = options["reinit_robin"]
        if "reconn_robin" in options:
            self.options["reconn_robin"] = options["reconn_robin"]
        if "reinit_wait" in options:
            self.options["reinit_wait"] = options["reinit_wait"]
        if "reconn_wait" in options:
            self.options["reconn_wait"] = options["reconn_wait"]
        if "udp_ping_intvl" in options:
            self.options["udp_ping_intvl"] = options["udp_ping_intvl"]

        # Register destructor
        atexit.register(self.__exit__)

    def __exit__(self):
        """Destructor."""
        if self.conn is not None:
            self.log.trace("Closing 'conn' socket")
            self.__close_socket(self.conn)
            self.conn = None
        if self.sock is not None:
            self.log.trace("Closing 'sock' socket")
            self.__close_socket(self.sock)
            self.sock = None

    # ------------------------------------------------------------------------------
    # Private Functions
    # ------------------------------------------------------------------------------
    def __close_socket(self, sock):
        """Close a socket."""
        try:
            sock.shutdown(socket.SHUT_RDWR)
        except (ValueError, OSError, socket.error):
            pass
        sock.close()

    def __reconnect(self):
        """Reconnect to a server if upstream has gone."""
        self.__close_socket(self.conn)
        self.__close_socket(self.sock)
        self.create_socket()
        self.conn = self.sock
        if not self.connect():
            self.__reconnect_to_server()

    def __reaccept_from_client(self):
        """Ensure the server is able to accept clients again, after current client has left."""
        # Only for server
        assert self.role == "server", "Only the role 'server' can accept connections."
        # Do not re-accept for UDP
        assert not self.options["udp"], "This should have been caught during arg check."

        # [NO] Never re-accept
        if type(self.options["reconn"]) is bool and not self.options["reconn"]:
            self.log.info("No automatic re-accept specified. Shutting down.")
            return False
        # [YES] Always re-accept indefinitely
        if type(self.options["reconn"]) is bool and self.options["reconn"]:
            self.log.info(
                "Re-accepting in {} sec (indefinitely)".format(self.options["reconn_wait"])
            )
            time.sleep(self.options["reconn_wait"])
            self.accept()
            return True
        # [YES] Re-accept x many times
        if self.options["reconn"] > 0:
            self.log.info(
                "Re-accepting in {} sec ({} more times left)".format(
                    self.options["reconn_wait"], self.options["reconn"]
                )
            )
            self.options["reconn"] -= 1
            time.sleep(self.options["reconn_wait"])
            self.accept()
            return True
        # [NO] Re-accept count is used up
        self.log.info("Re-accept count is used up. Shutting down.")
        return False

    def __reconnect_to_server(self):
        """Ensure the client re-connects to the remote server, if the remote server hang up."""
        # Only for Clients
        assert self.role == "client", "Only the role 'client' can re-connect."
        # Do not re-connect with UDP
        assert not self.options["udp"], "This should have been caught during arg check."

        # [NO] Never re-connect
        if type(self.options["reconn"]) is bool and not self.options["reconn"]:
            self.log.info("No automatic reconnect specified. Shutting down.")
            return False
        # [YES] Always re-connect indefinitely
        if type(self.options["reconn"]) is bool and self.options["reconn"]:
            self.log.info(
                "Reconnecting in {} sec (indefinitely)".format(self.options["reconn_wait"])
            )
            time.sleep(self.options["reconn_wait"])
            self.__reconnect()
            return True
        # [YES] Re-connect x many times
        if self.options["reconn"] > 0:
            self.log.info(
                "Reconnecting in {} sec ({} more times left)".format(
                    self.options["reconn_wait"], self.options["reconn"]
                )
            )
            self.options["reconn"] -= 1
            time.sleep(self.options["reconn_wait"])
            self.__reconnect()
            return True
        # [NO] Re-connect count is used up
        self.log.info("Reconnect count is used up. Shutting down.")
        return False

    # ------------------------------------------------------------------------------
    # Helper Functions
    # ------------------------------------------------------------------------------
    def gethostbyname(self, host):
        """Translate hostname into IP address."""
        if self.options["nodns"]:
            return host
        try:
            self.log.debug("Resolving hostname: {}".format(host))
            addr = socket.gethostbyname(host)
            self.log.debug("Resolved hostname:  {}".format(addr))
            return addr
        except socket.gaierror as error:
            self.log.error("Resolve Error: {}".format(error))
            sys.exit(1)

    def create_socket(self):
        """Create TCP or UDP socket."""
        try:
            if self.options["udp"]:
                self.log.debug("Creating UDP socket")
                self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            else:
                self.log.debug("Creating TCP socket")
                self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        except socket.error as error:
            self.log.error("Failed to create the socket: {}".format(error))
            sys.exit(1)

    def bind(self, addr, port):
        """Bind the socket to an address."""
        try:
            self.log.debug("Binding socket to {}:{}".format(addr, port))
            self.sock.bind((addr, port))
        except (OverflowError, OSError, socket.error) as error:
            self.log.error("Binding socket to {}:{} failed: {}".format(addr, port, error))
            sys.exit(1)

    def listen(self):
        """Listen for connections made to the socket."""
        try:
            self.log.debug("Listening with backlog={}".format(self.options["backlog"]))
            self.sock.listen(self.options["backlog"])
        except socket.error as error:
            self.log.error("Listening failed: {}".format(error))
            sys.exit(1)

    def accept(self):
        """Accept a connection."""
        try:
            self.log.debug("Waiting for TCP client")
            self.conn, client = self.sock.accept()
            addr, port = client
            self.log.info("Client connected from {}:{}".format(addr, port))
        except (socket.gaierror, socket.error) as error:
            self.log.error("Accept failed: {}".format(error))
            sys.exit(1)

    def connect(self):
        """Connect to a remote socket at given address and port (TCP-only)."""
        try:
            self.log.debug("Connecting to {}:{}".format(self.remote_addr, self.remote_port))
            self.sock.connect((self.remote_addr, self.remote_port))
            return True
        except socket.error as error:
            self.log.error(
                "Connecting to {}:{} failed: {}".format(self.remote_addr, self.remote_port, error)
            )
            return False

    # ------------------------------------------------------------------------------
    # Send / Receive Functions
    # ------------------------------------------------------------------------------
    def send(self, data):
        """Send data."""
        # In case of sending data back to an udp client we need to wait
        # until the client has first connected and told us its addr/port
        if self.options["udp"] and self.udp_client_addr is None and self.udp_client_port is None:
            self.log.info("Waiting for UDP client to connect")
            while self.udp_client_addr is None and self.udp_client_port is None:
                pass

        send = 0
        size = len(data)
        data = self.enc.encode(data)
        assert size == len(data), "Encoding messed up string length, might need to do len() after."
        # Loop until all bytes have been send
        while send < size:
            if self.conn is None:
                self.log.error("Socket is gone")
                return
            try:
                self.log.trace("Trying to send: {}".format(data))
                if self.options["udp"]:
                    send += self.conn.sendto(data, (self.udp_client_addr, self.udp_client_port))
                else:
                    send += self.conn.send(data)
                # Remove 'send' many bytes from data
                data = data[send:]
            except (OSError, socket.error) as error:
                self.log.error("Send Error: {}".format(error))
                # exit the thread gracefully (program shuts down fine)
                return

    def receive(self):
        """Generate received data endlessly by yielding it."""
        while True:
            if self.conn is None:
                self.log.error("Socket is gone")
                return
            try:
                self.log.trace(
                    "Waiting to receive data (bufsize={})...".format(self.options["bufsize"])
                )
                (byte, addr) = self.conn.recvfrom(self.options["bufsize"])
                data = byte
                data = self.enc.decode(byte)
                self.log.trace("Received: {}".format(data))

                # If we're receiving data from a UDP client
                # we can firstly/finally set its addr/port in order
                # to send data back to it (see send() function)
                if self.options["udp"]:
                    self.udp_client_addr, self.udp_client_port = addr
                    # Avoid the noise on UDP connections to spam on every send
                    if self.udp_client_addr is None or self.udp_client_port is None:
                        self.log.info(
                            "Client connected: {}:{}".format(
                                self.udp_client_addr, self.udp_client_port
                            )
                        )
                    # Find for debug
                    else:
                        self.log.debug(
                            "Client connected: {}:{}".format(
                                self.udp_client_addr, self.udp_client_port
                            )
                        )

            except socket.error as error:
                self.log.error("Receive Error: {}".format(error))
                sys.exit(1)

            if not data:
                # Upstream (server or client) is gone. Do we reconnect or quit?
                self.log.warning("Upstream connection is gone")
                if self.role == "server":
                    if not self.__reaccept_from_client():
                        sys.exit(0)
                if self.role == "client":
                    if not self.__reconnect_to_server():
                        sys.exit(0)

            yield data
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pwncat.AbstractSocket">AbstractSocket</a></li>
          <li><a href="/builtins.object.ext">builtins.object</a></li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="pwncat.AbstractSocket.conn" class="name">var <span class="ident">conn</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.options" class="name">var <span class="ident">options</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.remote_addr" class="name">var <span class="ident">remote_addr</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.role" class="name">var <span class="ident">role</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.sock" class="name">var <span class="ident">sock</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.udp_client_addr" class="name">var <span class="ident">udp_client_addr</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.udp_client_port" class="name">var <span class="ident">udp_client_port</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractSocket.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, logger, encoder, role, options={})</p>
    </div>
    

    
  
    <div class="desc"><p>Constructor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractSocket.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractSocket.__init__" class="source">
    <pre><code>def __init__(self, logger, encoder, role, options={}):
    """Constructor."""
    assert type(self) is not AbstractSocket, "AbstractSocket cannot be instantiated directly."
    assert role in ["server", "client"], "The role must be 'server' or 'client'."
    self.log = logger
    self.enc = encoder
    self.role = role
    if "udp" in options:
        self.options["udp"] = options["udp"]
    if "bufsize" in options:
        self.options["bufsize"] = options["bufsize"]
    if "backlog" in options:
        self.options["backlog"] = options["backlog"]
    if "nodns" in options:
        self.options["nodns"] = options["nodns"]
    if "reinit" in options:
        self.options["reinit"] = options["reinit"]
    if "reconn" in options:
        self.options["reconn"] = options["reconn"]
    if "reinit_robin" in options:
        self.options["reinit_robin"] = options["reinit_robin"]
    if "reconn_robin" in options:
        self.options["reconn_robin"] = options["reconn_robin"]
    if "reinit_wait" in options:
        self.options["reinit_wait"] = options["reinit_wait"]
    if "reconn_wait" in options:
        self.options["reconn_wait"] = options["reconn_wait"]
    if "udp_ping_intvl" in options:
        self.options["udp_ping_intvl"] = options["udp_ping_intvl"]
    # Register destructor
    atexit.register(self.__exit__)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractSocket.accept">
    <p>def <span class="ident">accept</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Accept a connection.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractSocket.accept', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractSocket.accept" class="source">
    <pre><code>def accept(self):
    """Accept a connection."""
    try:
        self.log.debug("Waiting for TCP client")
        self.conn, client = self.sock.accept()
        addr, port = client
        self.log.info("Client connected from {}:{}".format(addr, port))
    except (socket.gaierror, socket.error) as error:
        self.log.error("Accept failed: {}".format(error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractSocket.bind">
    <p>def <span class="ident">bind</span>(</p><p>self, addr, port)</p>
    </div>
    

    
  
    <div class="desc"><p>Bind the socket to an address.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractSocket.bind', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractSocket.bind" class="source">
    <pre><code>def bind(self, addr, port):
    """Bind the socket to an address."""
    try:
        self.log.debug("Binding socket to {}:{}".format(addr, port))
        self.sock.bind((addr, port))
    except (OverflowError, OSError, socket.error) as error:
        self.log.error("Binding socket to {}:{} failed: {}".format(addr, port, error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractSocket.connect">
    <p>def <span class="ident">connect</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Connect to a remote socket at given address and port (TCP-only).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractSocket.connect', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractSocket.connect" class="source">
    <pre><code>def connect(self):
    """Connect to a remote socket at given address and port (TCP-only)."""
    try:
        self.log.debug("Connecting to {}:{}".format(self.remote_addr, self.remote_port))
        self.sock.connect((self.remote_addr, self.remote_port))
        return True
    except socket.error as error:
        self.log.error(
            "Connecting to {}:{} failed: {}".format(self.remote_addr, self.remote_port, error)
        )
        return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractSocket.create_socket">
    <p>def <span class="ident">create_socket</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Create TCP or UDP socket.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractSocket.create_socket', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractSocket.create_socket" class="source">
    <pre><code>def create_socket(self):
    """Create TCP or UDP socket."""
    try:
        if self.options["udp"]:
            self.log.debug("Creating UDP socket")
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        else:
            self.log.debug("Creating TCP socket")
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    except socket.error as error:
        self.log.error("Failed to create the socket: {}".format(error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractSocket.gethostbyname">
    <p>def <span class="ident">gethostbyname</span>(</p><p>self, host)</p>
    </div>
    

    
  
    <div class="desc"><p>Translate hostname into IP address.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractSocket.gethostbyname', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractSocket.gethostbyname" class="source">
    <pre><code>def gethostbyname(self, host):
    """Translate hostname into IP address."""
    if self.options["nodns"]:
        return host
    try:
        self.log.debug("Resolving hostname: {}".format(host))
        addr = socket.gethostbyname(host)
        self.log.debug("Resolved hostname:  {}".format(addr))
        return addr
    except socket.gaierror as error:
        self.log.error("Resolve Error: {}".format(error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractSocket.listen">
    <p>def <span class="ident">listen</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Listen for connections made to the socket.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractSocket.listen', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractSocket.listen" class="source">
    <pre><code>def listen(self):
    """Listen for connections made to the socket."""
    try:
        self.log.debug("Listening with backlog={}".format(self.options["backlog"]))
        self.sock.listen(self.options["backlog"])
    except socket.error as error:
        self.log.error("Listening failed: {}".format(error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractSocket.receive">
    <p>def <span class="ident">receive</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Generate received data endlessly by yielding it.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractSocket.receive', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractSocket.receive" class="source">
    <pre><code>def receive(self):
    """Generate received data endlessly by yielding it."""
    while True:
        if self.conn is None:
            self.log.error("Socket is gone")
            return
        try:
            self.log.trace(
                "Waiting to receive data (bufsize={})...".format(self.options["bufsize"])
            )
            (byte, addr) = self.conn.recvfrom(self.options["bufsize"])
            data = byte
            data = self.enc.decode(byte)
            self.log.trace("Received: {}".format(data))
            # If we're receiving data from a UDP client
            # we can firstly/finally set its addr/port in order
            # to send data back to it (see send() function)
            if self.options["udp"]:
                self.udp_client_addr, self.udp_client_port = addr
                # Avoid the noise on UDP connections to spam on every send
                if self.udp_client_addr is None or self.udp_client_port is None:
                    self.log.info(
                        "Client connected: {}:{}".format(
                            self.udp_client_addr, self.udp_client_port
                        )
                    )
                # Find for debug
                else:
                    self.log.debug(
                        "Client connected: {}:{}".format(
                            self.udp_client_addr, self.udp_client_port
                        )
                    )
        except socket.error as error:
            self.log.error("Receive Error: {}".format(error))
            sys.exit(1)
        if not data:
            # Upstream (server or client) is gone. Do we reconnect or quit?
            self.log.warning("Upstream connection is gone")
            if self.role == "server":
                if not self.__reaccept_from_client():
                    sys.exit(0)
            if self.role == "client":
                if not self.__reconnect_to_server():
                    sys.exit(0)
        yield data
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.AbstractSocket.send">
    <p>def <span class="ident">send</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>Send data.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.AbstractSocket.send', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.AbstractSocket.send" class="source">
    <pre><code>def send(self, data):
    """Send data."""
    # In case of sending data back to an udp client we need to wait
    # until the client has first connected and told us its addr/port
    if self.options["udp"] and self.udp_client_addr is None and self.udp_client_port is None:
        self.log.info("Waiting for UDP client to connect")
        while self.udp_client_addr is None and self.udp_client_port is None:
            pass
    send = 0
    size = len(data)
    data = self.enc.encode(data)
    assert size == len(data), "Encoding messed up string length, might need to do len() after."
    # Loop until all bytes have been send
    while send < size:
        if self.conn is None:
            self.log.error("Socket is gone")
            return
        try:
            self.log.trace("Trying to send: {}".format(data))
            if self.options["udp"]:
                send += self.conn.sendto(data, (self.udp_client_addr, self.udp_client_port))
            else:
                send += self.conn.send(data)
            # Remove 'send' many bytes from data
            data = data[send:]
        except (OSError, socket.error) as error:
            self.log.error("Send Error: {}".format(error))
            # exit the thread gracefully (program shuts down fine)
            return
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pwncat.AbstractSocket.enc" class="name">var <span class="ident">enc</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.log" class="name">var <span class="ident">log</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.AbstractSocket.role" class="name">var <span class="ident">role</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="pwncat.Logger" class="name">class <span class="ident">Logger</span></p>
      
  
    <div class="desc"><p>Logger class.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.Logger', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.Logger" class="source">
    <pre><code>class Logger(object):
    """Logger class."""

    # ------------------------------------------------------------------------------
    # Constructor / Destructor
    # ------------------------------------------------------------------------------
    def __init__(self, verbosity=1):
        """Constructor.

        verbosity == 0: Log errors
        verbosity == 1: Log errors, warnings
        verbosity == 2: Log errors, warnings, info
        verbosity == 3: Log errors, warnings, info, debug, class/func names
        verbosity == 4: Log errors, warnings, info, debug, trace, class/func names
        """
        assert verbosity >= 0, "Verbosity cannot be less than 0."
        self.verbosity = verbosity

    # ------------------------------------------------------------------------------
    # Public Functions
    # ------------------------------------------------------------------------------
    def error(self, message):
        """Log error messages."""
        if self.verbosity > 2:
            _stack = inspect.stack()[1]
            cls = _stack[0].f_locals["self"].__class__.__name__
            fnc = _stack[3]
            print("[ERROR] %s.%s(): %s" % (cls, fnc, repr(message)), file=sys.stderr)
        else:
            print("[ERROR] %s" % repr(message), file=sys.stderr)

    def warning(self, message):
        """Log warning messages."""
        if self.verbosity > 2:
            _stack = inspect.stack()[1]
            cls = _stack[0].f_locals["self"].__class__.__name__
            fnc = _stack[3]
            print("[WARN]  %s.%s(): %s" % (cls, fnc, repr(message)), file=sys.stderr)
        elif self.verbosity > 0:
            print("[WARN]  %s" % repr(message), file=sys.stderr)

    def info(self, message):
        """Log info messages."""
        if self.verbosity > 2:
            _stack = inspect.stack()[1]
            cls = _stack[0].f_locals["self"].__class__.__name__
            fnc = _stack[3]
            print("[INFO]  %s.%s(): %s" % (cls, fnc, repr(message)), file=sys.stderr)
        elif self.verbosity > 1:
            print("[INFO]  %s" % repr(message), file=sys.stderr)

    def debug(self, message):
        """Log debug messages."""
        if self.verbosity > 2:
            _stack = inspect.stack()[1]
            cls = _stack[0].f_locals["self"].__class__.__name__
            fnc = _stack[3]
            print("[DEBUG] %s.%s(): %s" % (cls, fnc, repr(message)), file=sys.stderr)
        elif self.verbosity > 2:
            print("[DEBUG] %s" % repr(message), file=sys.stderr)

    def trace(self, message):
        """Log trace messages."""
        if self.verbosity > 3:
            _stack = inspect.stack()[1]
            cls = _stack[0].f_locals["self"].__class__.__name__
            fnc = _stack[3]
            print("[TRACE] %s.%s(): %s" % (cls, fnc, repr(message)), file=sys.stderr)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pwncat.Logger">Logger</a></li>
          <li><a href="/builtins.object.ext">builtins.object</a></li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pwncat.Logger.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, verbosity=1)</p>
    </div>
    

    
  
    <div class="desc"><p>Constructor.</p>
<p>verbosity == 0: Log errors
verbosity == 1: Log errors, warnings
verbosity == 2: Log errors, warnings, info
verbosity == 3: Log errors, warnings, info, debug, class/func names
verbosity == 4: Log errors, warnings, info, debug, trace, class/func names</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.Logger.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.Logger.__init__" class="source">
    <pre><code>def __init__(self, verbosity=1):
    """Constructor.
    verbosity == 0: Log errors
    verbosity == 1: Log errors, warnings
    verbosity == 2: Log errors, warnings, info
    verbosity == 3: Log errors, warnings, info, debug, class/func names
    verbosity == 4: Log errors, warnings, info, debug, trace, class/func names
    """
    assert verbosity >= 0, "Verbosity cannot be less than 0."
    self.verbosity = verbosity
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.Logger.debug">
    <p>def <span class="ident">debug</span>(</p><p>self, message)</p>
    </div>
    

    
  
    <div class="desc"><p>Log debug messages.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.Logger.debug', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.Logger.debug" class="source">
    <pre><code>def debug(self, message):
    """Log debug messages."""
    if self.verbosity > 2:
        _stack = inspect.stack()[1]
        cls = _stack[0].f_locals["self"].__class__.__name__
        fnc = _stack[3]
        print("[DEBUG] %s.%s(): %s" % (cls, fnc, repr(message)), file=sys.stderr)
    elif self.verbosity > 2:
        print("[DEBUG] %s" % repr(message), file=sys.stderr)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.Logger.error">
    <p>def <span class="ident">error</span>(</p><p>self, message)</p>
    </div>
    

    
  
    <div class="desc"><p>Log error messages.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.Logger.error', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.Logger.error" class="source">
    <pre><code>def error(self, message):
    """Log error messages."""
    if self.verbosity > 2:
        _stack = inspect.stack()[1]
        cls = _stack[0].f_locals["self"].__class__.__name__
        fnc = _stack[3]
        print("[ERROR] %s.%s(): %s" % (cls, fnc, repr(message)), file=sys.stderr)
    else:
        print("[ERROR] %s" % repr(message), file=sys.stderr)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.Logger.info">
    <p>def <span class="ident">info</span>(</p><p>self, message)</p>
    </div>
    

    
  
    <div class="desc"><p>Log info messages.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.Logger.info', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.Logger.info" class="source">
    <pre><code>def info(self, message):
    """Log info messages."""
    if self.verbosity > 2:
        _stack = inspect.stack()[1]
        cls = _stack[0].f_locals["self"].__class__.__name__
        fnc = _stack[3]
        print("[INFO]  %s.%s(): %s" % (cls, fnc, repr(message)), file=sys.stderr)
    elif self.verbosity > 1:
        print("[INFO]  %s" % repr(message), file=sys.stderr)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.Logger.trace">
    <p>def <span class="ident">trace</span>(</p><p>self, message)</p>
    </div>
    

    
  
    <div class="desc"><p>Log trace messages.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.Logger.trace', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.Logger.trace" class="source">
    <pre><code>def trace(self, message):
    """Log trace messages."""
    if self.verbosity > 3:
        _stack = inspect.stack()[1]
        cls = _stack[0].f_locals["self"].__class__.__name__
        fnc = _stack[3]
        print("[TRACE] %s.%s(): %s" % (cls, fnc, repr(message)), file=sys.stderr)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.Logger.warning">
    <p>def <span class="ident">warning</span>(</p><p>self, message)</p>
    </div>
    

    
  
    <div class="desc"><p>Log warning messages.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.Logger.warning', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.Logger.warning" class="source">
    <pre><code>def warning(self, message):
    """Log warning messages."""
    if self.verbosity > 2:
        _stack = inspect.stack()[1]
        cls = _stack[0].f_locals["self"].__class__.__name__
        fnc = _stack[3]
        print("[WARN]  %s.%s(): %s" % (cls, fnc, repr(message)), file=sys.stderr)
    elif self.verbosity > 0:
        print("[WARN]  %s" % repr(message), file=sys.stderr)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pwncat.Logger.verbosity" class="name">var <span class="ident">verbosity</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="pwncat.NetcatClient" class="name">class <span class="ident">NetcatClient</span></p>
      
  
    <div class="desc"><p>Netcat Client implementation.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatClient', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatClient" class="source">
    <pre><code>class NetcatClient(AbstractSocket):
    """Netcat Client implementation."""

    def __init__(self, logger, encoder, host, port, options={}):
        """Construct a connecting clientt."""
        super(NetcatClient, self).__init__(logger, encoder, "client", options)

        # Setup client
        addr = self.gethostbyname(host)
        self.create_socket()
        self.conn = self.sock
        if self.options["udp"]:
            self.udp_client_addr = addr
            self.udp_client_port = port
        else:
            self.remote_addr = addr
            self.remote_port = port
            if not self.connect():
                sys.exit(1)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pwncat.NetcatClient">NetcatClient</a></li>
          <li><a href="#pwncat.AbstractSocket">AbstractSocket</a></li>
          <li><a href="/builtins.object.ext">builtins.object</a></li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="pwncat.NetcatClient.options" class="name">var <span class="ident">options</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatClient.remote_addr" class="name">var <span class="ident">remote_addr</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatClient.role" class="name">var <span class="ident">role</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatClient.sock" class="name">var <span class="ident">sock</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatClient.udp_client_addr" class="name">var <span class="ident">udp_client_addr</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatClient.udp_client_port" class="name">var <span class="ident">udp_client_port</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatClient.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, logger, encoder, host, port, options={})</p>
    </div>
    

    
  
    <div class="desc"><p>Construct a connecting clientt.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatClient.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatClient.__init__" class="source">
    <pre><code>def __init__(self, logger, encoder, host, port, options={}):
    """Construct a connecting clientt."""
    super(NetcatClient, self).__init__(logger, encoder, "client", options)
    # Setup client
    addr = self.gethostbyname(host)
    self.create_socket()
    self.conn = self.sock
    if self.options["udp"]:
        self.udp_client_addr = addr
        self.udp_client_port = port
    else:
        self.remote_addr = addr
        self.remote_port = port
        if not self.connect():
            sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatClient.accept">
    <p>def <span class="ident">accept</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Accept a connection.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatClient.accept', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatClient.accept" class="source">
    <pre><code>def accept(self):
    """Accept a connection."""
    try:
        self.log.debug("Waiting for TCP client")
        self.conn, client = self.sock.accept()
        addr, port = client
        self.log.info("Client connected from {}:{}".format(addr, port))
    except (socket.gaierror, socket.error) as error:
        self.log.error("Accept failed: {}".format(error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatClient.bind">
    <p>def <span class="ident">bind</span>(</p><p>self, addr, port)</p>
    </div>
    

    
  
    <div class="desc"><p>Bind the socket to an address.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatClient.bind', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatClient.bind" class="source">
    <pre><code>def bind(self, addr, port):
    """Bind the socket to an address."""
    try:
        self.log.debug("Binding socket to {}:{}".format(addr, port))
        self.sock.bind((addr, port))
    except (OverflowError, OSError, socket.error) as error:
        self.log.error("Binding socket to {}:{} failed: {}".format(addr, port, error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatClient.connect">
    <p>def <span class="ident">connect</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Connect to a remote socket at given address and port (TCP-only).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatClient.connect', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatClient.connect" class="source">
    <pre><code>def connect(self):
    """Connect to a remote socket at given address and port (TCP-only)."""
    try:
        self.log.debug("Connecting to {}:{}".format(self.remote_addr, self.remote_port))
        self.sock.connect((self.remote_addr, self.remote_port))
        return True
    except socket.error as error:
        self.log.error(
            "Connecting to {}:{} failed: {}".format(self.remote_addr, self.remote_port, error)
        )
        return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatClient.create_socket">
    <p>def <span class="ident">create_socket</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Create TCP or UDP socket.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatClient.create_socket', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatClient.create_socket" class="source">
    <pre><code>def create_socket(self):
    """Create TCP or UDP socket."""
    try:
        if self.options["udp"]:
            self.log.debug("Creating UDP socket")
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        else:
            self.log.debug("Creating TCP socket")
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    except socket.error as error:
        self.log.error("Failed to create the socket: {}".format(error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatClient.gethostbyname">
    <p>def <span class="ident">gethostbyname</span>(</p><p>self, host)</p>
    </div>
    

    
  
    <div class="desc"><p>Translate hostname into IP address.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatClient.gethostbyname', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatClient.gethostbyname" class="source">
    <pre><code>def gethostbyname(self, host):
    """Translate hostname into IP address."""
    if self.options["nodns"]:
        return host
    try:
        self.log.debug("Resolving hostname: {}".format(host))
        addr = socket.gethostbyname(host)
        self.log.debug("Resolved hostname:  {}".format(addr))
        return addr
    except socket.gaierror as error:
        self.log.error("Resolve Error: {}".format(error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatClient.listen">
    <p>def <span class="ident">listen</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Listen for connections made to the socket.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatClient.listen', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatClient.listen" class="source">
    <pre><code>def listen(self):
    """Listen for connections made to the socket."""
    try:
        self.log.debug("Listening with backlog={}".format(self.options["backlog"]))
        self.sock.listen(self.options["backlog"])
    except socket.error as error:
        self.log.error("Listening failed: {}".format(error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatClient.receive">
    <p>def <span class="ident">receive</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Generate received data endlessly by yielding it.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatClient.receive', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatClient.receive" class="source">
    <pre><code>def receive(self):
    """Generate received data endlessly by yielding it."""
    while True:
        if self.conn is None:
            self.log.error("Socket is gone")
            return
        try:
            self.log.trace(
                "Waiting to receive data (bufsize={})...".format(self.options["bufsize"])
            )
            (byte, addr) = self.conn.recvfrom(self.options["bufsize"])
            data = byte
            data = self.enc.decode(byte)
            self.log.trace("Received: {}".format(data))
            # If we're receiving data from a UDP client
            # we can firstly/finally set its addr/port in order
            # to send data back to it (see send() function)
            if self.options["udp"]:
                self.udp_client_addr, self.udp_client_port = addr
                # Avoid the noise on UDP connections to spam on every send
                if self.udp_client_addr is None or self.udp_client_port is None:
                    self.log.info(
                        "Client connected: {}:{}".format(
                            self.udp_client_addr, self.udp_client_port
                        )
                    )
                # Find for debug
                else:
                    self.log.debug(
                        "Client connected: {}:{}".format(
                            self.udp_client_addr, self.udp_client_port
                        )
                    )
        except socket.error as error:
            self.log.error("Receive Error: {}".format(error))
            sys.exit(1)
        if not data:
            # Upstream (server or client) is gone. Do we reconnect or quit?
            self.log.warning("Upstream connection is gone")
            if self.role == "server":
                if not self.__reaccept_from_client():
                    sys.exit(0)
            if self.role == "client":
                if not self.__reconnect_to_server():
                    sys.exit(0)
        yield data
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatClient.send">
    <p>def <span class="ident">send</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>Send data.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatClient.send', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatClient.send" class="source">
    <pre><code>def send(self, data):
    """Send data."""
    # In case of sending data back to an udp client we need to wait
    # until the client has first connected and told us its addr/port
    if self.options["udp"] and self.udp_client_addr is None and self.udp_client_port is None:
        self.log.info("Waiting for UDP client to connect")
        while self.udp_client_addr is None and self.udp_client_port is None:
            pass
    send = 0
    size = len(data)
    data = self.enc.encode(data)
    assert size == len(data), "Encoding messed up string length, might need to do len() after."
    # Loop until all bytes have been send
    while send < size:
        if self.conn is None:
            self.log.error("Socket is gone")
            return
        try:
            self.log.trace("Trying to send: {}".format(data))
            if self.options["udp"]:
                send += self.conn.sendto(data, (self.udp_client_addr, self.udp_client_port))
            else:
                send += self.conn.send(data)
            # Remove 'send' many bytes from data
            data = data[send:]
        except (OSError, socket.error) as error:
            self.log.error("Send Error: {}".format(error))
            # exit the thread gracefully (program shuts down fine)
            return
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pwncat.NetcatClient.conn" class="name">var <span class="ident">conn</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="pwncat.NetcatModuleCommand" class="name">class <span class="ident">NetcatModuleCommand</span></p>
      
  
    <div class="desc"><p>Implement command execution functionality.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatModuleCommand', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatModuleCommand" class="source">
    <pre><code>class NetcatModuleCommand(AbstractNetcatModule):
    """Implement command execution functionality."""

    executable = None

    # ------------------------------------------------------------------------------
    # Constructor / Destructor
    # ------------------------------------------------------------------------------
    def __init__(self, logger, encoder, options={}):
        """Set specific options for this module."""
        self.log = logger
        self.enc = encoder
        assert "executable" in options
        self.log.debug("Setting '{}' as executable".format(options["executable"]))
        self.executable = options["executable"]

        # Open executable to wait for commands
        env = os.environ.copy()
        self.p = Popen(
            self.executable, stdin=PIPE, stdout=PIPE, stderr=subprocess.STDOUT, shell=False, env=env
        )
        # Define destructor
        atexit.register(self.__exit__)

    def __exit__(self):
        """Destructor."""
        self.log.trace("Killing executable: {} with pid {}".format(self.executable, self.p.pid))
        self.p.kill()

    # ------------------------------------------------------------------------------
    # Public Functions
    # ------------------------------------------------------------------------------
    def input_generator(self):
        """Constantly ask for input."""
        while True:
            self.log.trace("Reading command output")
            data = self.p.stdout.readline()  # Much better performance than self.p.read(1)
            data = self.enc.decode(data)
            self.log.trace("Command output: {}".format(data))
            if not data:
                self.log.error("No program output received")
                break
            yield data

    def output_callback(self, data):
        """Send data received to stdin (command input)."""
        data = self.enc.encode(data)
        self.log.trace("Appending to stdin: {}".format(data))
        self.p.stdin.write(data)
        self.p.stdin.flush()
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pwncat.NetcatModuleCommand">NetcatModuleCommand</a></li>
          <li><a href="#pwncat.AbstractNetcatModule">AbstractNetcatModule</a></li>
          <li><a href="/builtins.object.ext">builtins.object</a></li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="pwncat.NetcatModuleCommand.executable" class="name">var <span class="ident">executable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatModuleCommand.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, logger, encoder, options={})</p>
    </div>
    

    
  
    <div class="desc"><p>Set specific options for this module.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatModuleCommand.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatModuleCommand.__init__" class="source">
    <pre><code>def __init__(self, logger, encoder, options={}):
    """Set specific options for this module."""
    self.log = logger
    self.enc = encoder
    assert "executable" in options
    self.log.debug("Setting '{}' as executable".format(options["executable"]))
    self.executable = options["executable"]
    # Open executable to wait for commands
    env = os.environ.copy()
    self.p = Popen(
        self.executable, stdin=PIPE, stdout=PIPE, stderr=subprocess.STDOUT, shell=False, env=env
    )
    # Define destructor
    atexit.register(self.__exit__)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatModuleCommand.input_generator">
    <p>def <span class="ident">input_generator</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Constantly ask for input.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatModuleCommand.input_generator', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatModuleCommand.input_generator" class="source">
    <pre><code>def input_generator(self):
    """Constantly ask for input."""
    while True:
        self.log.trace("Reading command output")
        data = self.p.stdout.readline()  # Much better performance than self.p.read(1)
        data = self.enc.decode(data)
        self.log.trace("Command output: {}".format(data))
        if not data:
            self.log.error("No program output received")
            break
        yield data
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatModuleCommand.output_callback">
    <p>def <span class="ident">output_callback</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>Send data received to stdin (command input).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatModuleCommand.output_callback', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatModuleCommand.output_callback" class="source">
    <pre><code>def output_callback(self, data):
    """Send data received to stdin (command input)."""
    data = self.enc.encode(data)
    self.log.trace("Appending to stdin: {}".format(data))
    self.p.stdin.write(data)
    self.p.stdin.flush()
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pwncat.NetcatModuleCommand.enc" class="name">var <span class="ident">enc</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatModuleCommand.executable" class="name">var <span class="ident">executable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatModuleCommand.log" class="name">var <span class="ident">log</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatModuleCommand.p" class="name">var <span class="ident">p</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="pwncat.NetcatModuleOutput" class="name">class <span class="ident">NetcatModuleOutput</span></p>
      
  
    <div class="desc"><p>Implement basic chat module functionality.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatModuleOutput', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatModuleOutput" class="source">
    <pre><code>class NetcatModuleOutput(AbstractNetcatModule):
    """Implement basic chat module functionality."""

    linefeed = "\n"

    # ------------------------------------------------------------------------------
    # Constructor / Destructor
    # ------------------------------------------------------------------------------
    def __init__(self, logger, encoder, options={}):
        """Set specific options for this module."""
        self.log = logger
        self.enc = encoder
        if "linefeed" in options:
            self.linefeed = options["linefeed"]

    # ------------------------------------------------------------------------------
    # Public Functions
    # ------------------------------------------------------------------------------
    def input_generator(self):
        """Constantly ask for user input."""
        while True:
            data = input()
            yield data + self.linefeed

    def output_callback(self, data):
        """Print received data to stdout."""
        if data.endswith("\r\n"):
            data = data[:-2]
        elif data.endswith("\n") or data.endswith("\r"):
            data = data[:-1]
        print(data)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pwncat.NetcatModuleOutput">NetcatModuleOutput</a></li>
          <li><a href="#pwncat.AbstractNetcatModule">AbstractNetcatModule</a></li>
          <li><a href="/builtins.object.ext">builtins.object</a></li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="pwncat.NetcatModuleOutput.linefeed" class="name">var <span class="ident">linefeed</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatModuleOutput.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, logger, encoder, options={})</p>
    </div>
    

    
  
    <div class="desc"><p>Set specific options for this module.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatModuleOutput.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatModuleOutput.__init__" class="source">
    <pre><code>def __init__(self, logger, encoder, options={}):
    """Set specific options for this module."""
    self.log = logger
    self.enc = encoder
    if "linefeed" in options:
        self.linefeed = options["linefeed"]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatModuleOutput.input_generator">
    <p>def <span class="ident">input_generator</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Constantly ask for user input.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatModuleOutput.input_generator', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatModuleOutput.input_generator" class="source">
    <pre><code>def input_generator(self):
    """Constantly ask for user input."""
    while True:
        data = input()
        yield data + self.linefeed
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatModuleOutput.output_callback">
    <p>def <span class="ident">output_callback</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>Print received data to stdout.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatModuleOutput.output_callback', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatModuleOutput.output_callback" class="source">
    <pre><code>def output_callback(self, data):
    """Print received data to stdout."""
    if data.endswith("\r\n"):
        data = data[:-2]
    elif data.endswith("\n") or data.endswith("\r"):
        data = data[:-1]
    print(data)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pwncat.NetcatModuleOutput.enc" class="name">var <span class="ident">enc</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatModuleOutput.log" class="name">var <span class="ident">log</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="pwncat.NetcatServer" class="name">class <span class="ident">NetcatServer</span></p>
      
  
    <div class="desc"><p>Netcat Server implementation.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatServer', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatServer" class="source">
    <pre><code>class NetcatServer(AbstractSocket):
    """Netcat Server implementation."""

    def __init__(self, logger, encoder, host, port, options={}):
        """Construct a listening server."""
        super(NetcatServer, self).__init__(logger, encoder, "server", options)

        # Setup server
        addr = self.gethostbyname(host)
        self.create_socket()
        self.bind(addr, port)
        if self.options["udp"]:
            self.conn = self.sock
            self.log.info("Waiting on {}:{} (UDP)".format(addr, port))
        else:
            self.listen()
            self.log.info("Listening on {}:{} (TCP)".format(addr, port))
            self.accept()
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pwncat.NetcatServer">NetcatServer</a></li>
          <li><a href="#pwncat.AbstractSocket">AbstractSocket</a></li>
          <li><a href="/builtins.object.ext">builtins.object</a></li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="pwncat.NetcatServer.conn" class="name">var <span class="ident">conn</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatServer.options" class="name">var <span class="ident">options</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatServer.remote_addr" class="name">var <span class="ident">remote_addr</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatServer.role" class="name">var <span class="ident">role</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatServer.sock" class="name">var <span class="ident">sock</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatServer.udp_client_addr" class="name">var <span class="ident">udp_client_addr</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.NetcatServer.udp_client_port" class="name">var <span class="ident">udp_client_port</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatServer.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, logger, encoder, host, port, options={})</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#pwncat.AbstractSocket">AbstractSocket</a></code>.<code><a href="#pwncat.AbstractSocket.__init__">__init__</a></code>
    </p>

    
  
    <div class="desc"><p>Construct a listening server.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatServer.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatServer.__init__" class="source">
    <pre><code>def __init__(self, logger, encoder, host, port, options={}):
    """Construct a listening server."""
    super(NetcatServer, self).__init__(logger, encoder, "server", options)
    # Setup server
    addr = self.gethostbyname(host)
    self.create_socket()
    self.bind(addr, port)
    if self.options["udp"]:
        self.conn = self.sock
        self.log.info("Waiting on {}:{} (UDP)".format(addr, port))
    else:
        self.listen()
        self.log.info("Listening on {}:{} (TCP)".format(addr, port))
        self.accept()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatServer.accept">
    <p>def <span class="ident">accept</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Accept a connection.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatServer.accept', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatServer.accept" class="source">
    <pre><code>def accept(self):
    """Accept a connection."""
    try:
        self.log.debug("Waiting for TCP client")
        self.conn, client = self.sock.accept()
        addr, port = client
        self.log.info("Client connected from {}:{}".format(addr, port))
    except (socket.gaierror, socket.error) as error:
        self.log.error("Accept failed: {}".format(error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatServer.bind">
    <p>def <span class="ident">bind</span>(</p><p>self, addr, port)</p>
    </div>
    

    
  
    <div class="desc"><p>Bind the socket to an address.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatServer.bind', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatServer.bind" class="source">
    <pre><code>def bind(self, addr, port):
    """Bind the socket to an address."""
    try:
        self.log.debug("Binding socket to {}:{}".format(addr, port))
        self.sock.bind((addr, port))
    except (OverflowError, OSError, socket.error) as error:
        self.log.error("Binding socket to {}:{} failed: {}".format(addr, port, error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatServer.connect">
    <p>def <span class="ident">connect</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Connect to a remote socket at given address and port (TCP-only).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatServer.connect', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatServer.connect" class="source">
    <pre><code>def connect(self):
    """Connect to a remote socket at given address and port (TCP-only)."""
    try:
        self.log.debug("Connecting to {}:{}".format(self.remote_addr, self.remote_port))
        self.sock.connect((self.remote_addr, self.remote_port))
        return True
    except socket.error as error:
        self.log.error(
            "Connecting to {}:{} failed: {}".format(self.remote_addr, self.remote_port, error)
        )
        return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatServer.create_socket">
    <p>def <span class="ident">create_socket</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Create TCP or UDP socket.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatServer.create_socket', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatServer.create_socket" class="source">
    <pre><code>def create_socket(self):
    """Create TCP or UDP socket."""
    try:
        if self.options["udp"]:
            self.log.debug("Creating UDP socket")
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        else:
            self.log.debug("Creating TCP socket")
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    except socket.error as error:
        self.log.error("Failed to create the socket: {}".format(error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatServer.gethostbyname">
    <p>def <span class="ident">gethostbyname</span>(</p><p>self, host)</p>
    </div>
    

    
  
    <div class="desc"><p>Translate hostname into IP address.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatServer.gethostbyname', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatServer.gethostbyname" class="source">
    <pre><code>def gethostbyname(self, host):
    """Translate hostname into IP address."""
    if self.options["nodns"]:
        return host
    try:
        self.log.debug("Resolving hostname: {}".format(host))
        addr = socket.gethostbyname(host)
        self.log.debug("Resolved hostname:  {}".format(addr))
        return addr
    except socket.gaierror as error:
        self.log.error("Resolve Error: {}".format(error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatServer.listen">
    <p>def <span class="ident">listen</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Listen for connections made to the socket.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatServer.listen', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatServer.listen" class="source">
    <pre><code>def listen(self):
    """Listen for connections made to the socket."""
    try:
        self.log.debug("Listening with backlog={}".format(self.options["backlog"]))
        self.sock.listen(self.options["backlog"])
    except socket.error as error:
        self.log.error("Listening failed: {}".format(error))
        sys.exit(1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatServer.receive">
    <p>def <span class="ident">receive</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Generate received data endlessly by yielding it.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatServer.receive', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatServer.receive" class="source">
    <pre><code>def receive(self):
    """Generate received data endlessly by yielding it."""
    while True:
        if self.conn is None:
            self.log.error("Socket is gone")
            return
        try:
            self.log.trace(
                "Waiting to receive data (bufsize={})...".format(self.options["bufsize"])
            )
            (byte, addr) = self.conn.recvfrom(self.options["bufsize"])
            data = byte
            data = self.enc.decode(byte)
            self.log.trace("Received: {}".format(data))
            # If we're receiving data from a UDP client
            # we can firstly/finally set its addr/port in order
            # to send data back to it (see send() function)
            if self.options["udp"]:
                self.udp_client_addr, self.udp_client_port = addr
                # Avoid the noise on UDP connections to spam on every send
                if self.udp_client_addr is None or self.udp_client_port is None:
                    self.log.info(
                        "Client connected: {}:{}".format(
                            self.udp_client_addr, self.udp_client_port
                        )
                    )
                # Find for debug
                else:
                    self.log.debug(
                        "Client connected: {}:{}".format(
                            self.udp_client_addr, self.udp_client_port
                        )
                    )
        except socket.error as error:
            self.log.error("Receive Error: {}".format(error))
            sys.exit(1)
        if not data:
            # Upstream (server or client) is gone. Do we reconnect or quit?
            self.log.warning("Upstream connection is gone")
            if self.role == "server":
                if not self.__reaccept_from_client():
                    sys.exit(0)
            if self.role == "client":
                if not self.__reconnect_to_server():
                    sys.exit(0)
        yield data
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.NetcatServer.send">
    <p>def <span class="ident">send</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>Send data.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.NetcatServer.send', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.NetcatServer.send" class="source">
    <pre><code>def send(self, data):
    """Send data."""
    # In case of sending data back to an udp client we need to wait
    # until the client has first connected and told us its addr/port
    if self.options["udp"] and self.udp_client_addr is None and self.udp_client_port is None:
        self.log.info("Waiting for UDP client to connect")
        while self.udp_client_addr is None and self.udp_client_port is None:
            pass
    send = 0
    size = len(data)
    data = self.enc.encode(data)
    assert size == len(data), "Encoding messed up string length, might need to do len() after."
    # Loop until all bytes have been send
    while send < size:
        if self.conn is None:
            self.log.error("Socket is gone")
            return
        try:
            self.log.trace("Trying to send: {}".format(data))
            if self.options["udp"]:
                send += self.conn.sendto(data, (self.udp_client_addr, self.udp_client_port))
            else:
                send += self.conn.send(data)
            # Remove 'send' many bytes from data
            data = data[send:]
        except (OSError, socket.error) as error:
            self.log.error("Send Error: {}".format(error))
            # exit the thread gracefully (program shuts down fine)
            return
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="pwncat.Runner" class="name">class <span class="ident">Runner</span></p>
      
  
    <div class="desc"><p>Runner class that takes care about putting everything into threads.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.Runner', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.Runner" class="source">
    <pre><code>class Runner(object):
    """Runner class that takes care about putting everything into threads."""

    # ------------------------------------------------------------------------------
    # Constructor / Destructor
    # ------------------------------------------------------------------------------
    def __init__(self, logger):
        """Constructor."""
        self.log = logger

    # ------------------------------------------------------------------------------
    # Public Functions
    # ------------------------------------------------------------------------------
    def set_recv_generator(self, func):
        """Set generator func which constantly receives network data."""
        self.recv_generator = func

    def set_input_generator(self, func):
        """Set generator func which constantly receives input (shell output/user input)."""
        self.input_generator = func

    def set_send_callback(self, func):
        """Set the callback for sending data to a socket."""
        self.send_callback = func

    def set_output_callback(self, func):
        """Set the callback for outputting data to stdin/stdout."""
        self.output_callback = func

    def set_time_action(self, intvl, func, *args, **kwargs):
        """Set a function that should be called periodically."""
        self.timed_action_intvl = intvl
        self.timed_action_func = func
        self.timed_action_args = args
        self.timed_action_kwargs = kwargs

    def run(self):
        """Run threaded NetCat."""

        assert hasattr(self, "recv_generator"), "Error, recv_generator not set"
        assert hasattr(self, "input_generator"), "Error, input_generator not set"
        assert hasattr(self, "send_callback"), "Error, send_callback not set"
        assert hasattr(self, "output_callback"), "Error, output_callback not set"

        def receiver():
            """Receive data from a socket and process it with a callback.

            receive: Must be a generator function to receive network data.
            callback: Must be a callback to process received data, e.g.: print to stdin/stdout.
            """
            while True:
                self.log.trace("[Thread] receiver loop")
                for data in self.recv_generator():
                    self.log.trace("[Thread] receiver received: {}".format(data))
                    self.output_callback(data)

        def sender():
            """Receive data from user-input/command-output and process it with a callback.

            receive: Must be a generator function to receive user-input or command output.
            callback: Must be a callback to send this data to a socket.
            """
            while True:
                self.log.trace("[Thread] sender")
                for data in self.input_generator():
                    self.log.trace("[Thread] sender received: {}".format(data))
                    self.send_callback(data)

        def timer():
            """Execute periodic tasks by an optional provided time_action."""
            self.log.debug(
                "Ready for timed action every {} seconds".format(self.timed_action_intvl)
            )
            time_last = int(time.time())
            while True:
                time_now = int(time.time())
                if time_now > time_last + self.timed_action_intvl:
                    self.log.debug("[{}] Executing timed function".format(time_now))
                    self.timed_action_func(*self.timed_action_args, **self.timed_action_kwargs)
                    time_last = time_now  # Reset previous time
                time.sleep(1)

        # Start sending and receiving threads
        tr = threading.Thread(target=receiver)
        ts = threading.Thread(target=sender)
        # If the main thread kills, this thread will be killed too.
        tr.daemon = True
        ts.daemon = True
        # Start threads
        tr.start()
        self.log.trace("Receiving thread started")
        ts.start()
        self.log.trace("Sending thread started")

        if hasattr(self, "timed_action_intvl"):
            tt = threading.Thread(target=timer)
            tt.daemon = True
            tt.start()
            self.log.trace("Timer thread started")

        # Cleanup the main program
        while True:
            if not tr.is_alive():
                sys.exit(0)
            if not ts.is_alive():
                sys.exit(0)
            if hasattr(self, "time_action_intvl"):
                if not tt.is_alive():
                    sys.exit(0)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pwncat.Runner">Runner</a></li>
          <li><a href="/builtins.object.ext">builtins.object</a></li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pwncat.Runner.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, logger)</p>
    </div>
    

    
  
    <div class="desc"><p>Constructor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.Runner.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.Runner.__init__" class="source">
    <pre><code>def __init__(self, logger):
    """Constructor."""
    self.log = logger
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.Runner.run">
    <p>def <span class="ident">run</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Run threaded NetCat.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.Runner.run', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.Runner.run" class="source">
    <pre><code>def run(self):
    """Run threaded NetCat."""
    assert hasattr(self, "recv_generator"), "Error, recv_generator not set"
    assert hasattr(self, "input_generator"), "Error, input_generator not set"
    assert hasattr(self, "send_callback"), "Error, send_callback not set"
    assert hasattr(self, "output_callback"), "Error, output_callback not set"
    def receiver():
        """Receive data from a socket and process it with a callback.
        receive: Must be a generator function to receive network data.
        callback: Must be a callback to process received data, e.g.: print to stdin/stdout.
        """
        while True:
            self.log.trace("[Thread] receiver loop")
            for data in self.recv_generator():
                self.log.trace("[Thread] receiver received: {}".format(data))
                self.output_callback(data)
    def sender():
        """Receive data from user-input/command-output and process it with a callback.
        receive: Must be a generator function to receive user-input or command output.
        callback: Must be a callback to send this data to a socket.
        """
        while True:
            self.log.trace("[Thread] sender")
            for data in self.input_generator():
                self.log.trace("[Thread] sender received: {}".format(data))
                self.send_callback(data)
    def timer():
        """Execute periodic tasks by an optional provided time_action."""
        self.log.debug(
            "Ready for timed action every {} seconds".format(self.timed_action_intvl)
        )
        time_last = int(time.time())
        while True:
            time_now = int(time.time())
            if time_now > time_last + self.timed_action_intvl:
                self.log.debug("[{}] Executing timed function".format(time_now))
                self.timed_action_func(*self.timed_action_args, **self.timed_action_kwargs)
                time_last = time_now  # Reset previous time
            time.sleep(1)
    # Start sending and receiving threads
    tr = threading.Thread(target=receiver)
    ts = threading.Thread(target=sender)
    # If the main thread kills, this thread will be killed too.
    tr.daemon = True
    ts.daemon = True
    # Start threads
    tr.start()
    self.log.trace("Receiving thread started")
    ts.start()
    self.log.trace("Sending thread started")
    if hasattr(self, "timed_action_intvl"):
        tt = threading.Thread(target=timer)
        tt.daemon = True
        tt.start()
        self.log.trace("Timer thread started")
    # Cleanup the main program
    while True:
        if not tr.is_alive():
            sys.exit(0)
        if not ts.is_alive():
            sys.exit(0)
        if hasattr(self, "time_action_intvl"):
            if not tt.is_alive():
                sys.exit(0)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.Runner.set_input_generator">
    <p>def <span class="ident">set_input_generator</span>(</p><p>self, func)</p>
    </div>
    

    
  
    <div class="desc"><p>Set generator func which constantly receives input (shell output/user input).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.Runner.set_input_generator', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.Runner.set_input_generator" class="source">
    <pre><code>def set_input_generator(self, func):
    """Set generator func which constantly receives input (shell output/user input)."""
    self.input_generator = func
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.Runner.set_output_callback">
    <p>def <span class="ident">set_output_callback</span>(</p><p>self, func)</p>
    </div>
    

    
  
    <div class="desc"><p>Set the callback for outputting data to stdin/stdout.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.Runner.set_output_callback', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.Runner.set_output_callback" class="source">
    <pre><code>def set_output_callback(self, func):
    """Set the callback for outputting data to stdin/stdout."""
    self.output_callback = func
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.Runner.set_recv_generator">
    <p>def <span class="ident">set_recv_generator</span>(</p><p>self, func)</p>
    </div>
    

    
  
    <div class="desc"><p>Set generator func which constantly receives network data.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.Runner.set_recv_generator', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.Runner.set_recv_generator" class="source">
    <pre><code>def set_recv_generator(self, func):
    """Set generator func which constantly receives network data."""
    self.recv_generator = func
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.Runner.set_send_callback">
    <p>def <span class="ident">set_send_callback</span>(</p><p>self, func)</p>
    </div>
    

    
  
    <div class="desc"><p>Set the callback for sending data to a socket.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.Runner.set_send_callback', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.Runner.set_send_callback" class="source">
    <pre><code>def set_send_callback(self, func):
    """Set the callback for sending data to a socket."""
    self.send_callback = func
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.Runner.set_time_action">
    <p>def <span class="ident">set_time_action</span>(</p><p>self, intvl, func, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Set a function that should be called periodically.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.Runner.set_time_action', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.Runner.set_time_action" class="source">
    <pre><code>def set_time_action(self, intvl, func, *args, **kwargs):
    """Set a function that should be called periodically."""
    self.timed_action_intvl = intvl
    self.timed_action_func = func
    self.timed_action_args = args
    self.timed_action_kwargs = kwargs
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pwncat.Runner.log" class="name">var <span class="ident">log</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="pwncat.StringEncoder" class="name">class <span class="ident">StringEncoder</span></p>
      
  
    <div class="desc"><p>Takes care about Python 2/3 string encoding/decoding.</p>
<p>This allows to parse all string/byte values internally between all
classes or functions as strings to keep full Python 2/3 compat.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.StringEncoder', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.StringEncoder" class="source">
    <pre><code>class StringEncoder(object):
    """
    Takes care about Python 2/3 string encoding/decoding.

    This allows to parse all string/byte values internally between all
    classes or functions as strings to keep full Python 2/3 compat.
    """

    # https://stackoverflow.com/questions/606191/27527728#27527728
    codec = "cp437"

    def __init__(self, logger):
        self.log = logger
        self.py3 = sys.version_info >= (3, 0)

    def encode(self, data):
        """Convert string into a byte type for Python3."""
        if self.py3:
            self.log.trace("Encoding: {}".format(data))
            data = data.encode("cp437")
            self.log.trace("Encoded: {}".format(data))
        return data

    def decode(self, data):
        """Convert bytes into a string type for Python3."""
        if self.py3:
            self.log.trace("Decoding: {}".format(data))
            data = data.decode("cp437")
            self.log.trace("Decoded: {}".format(data))
        return data
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pwncat.StringEncoder">StringEncoder</a></li>
          <li><a href="/builtins.object.ext">builtins.object</a></li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="pwncat.StringEncoder.codec" class="name">var <span class="ident">codec</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pwncat.StringEncoder.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, logger)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.StringEncoder.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.StringEncoder.__init__" class="source">
    <pre><code>def __init__(self, logger):
    self.log = logger
    self.py3 = sys.version_info >= (3, 0)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.StringEncoder.decode">
    <p>def <span class="ident">decode</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>Convert bytes into a string type for Python3.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.StringEncoder.decode', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.StringEncoder.decode" class="source">
    <pre><code>def decode(self, data):
    """Convert bytes into a string type for Python3."""
    if self.py3:
        self.log.trace("Decoding: {}".format(data))
        data = data.decode("cp437")
        self.log.trace("Decoded: {}".format(data))
    return data
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pwncat.StringEncoder.encode">
    <p>def <span class="ident">encode</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>Convert string into a byte type for Python3.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pwncat.StringEncoder.encode', this);">Show source &equiv;</a></p>
  <div id="source-pwncat.StringEncoder.encode" class="source">
    <pre><code>def encode(self, data):
    """Convert string into a byte type for Python3."""
    if self.py3:
        self.log.trace("Encoding: {}".format(data))
        data = data.encode("cp437")
        self.log.trace("Encoded: {}".format(data))
    return data
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pwncat.StringEncoder.log" class="name">var <span class="ident">log</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pwncat.StringEncoder.py3" class="name">var <span class="ident">py3</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
